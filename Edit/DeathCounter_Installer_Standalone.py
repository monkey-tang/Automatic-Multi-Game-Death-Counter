"""
Death Counter - Single File Installer
This is a self-extracting installer that contains all necessary files.
"""

# CRITICAL: Single instance check BEFORE any imports
# This must be the absolute first thing that happens
import sys
if sys.platform == 'win32':
    import ctypes
    from ctypes import wintypes
    
    # Try to create a named mutex
    mutex_name = "DeathCounterInstaller_SingleInstance_Mutex"
    mutex = ctypes.windll.kernel32.CreateMutexW(None, False, mutex_name)
    last_error = ctypes.windll.kernel32.GetLastError()
    
    # If mutex already exists, another instance is running
    if last_error == 183:  # ERROR_ALREADY_EXISTS
        import ctypes.wintypes
        user32 = ctypes.windll.user32
        kernel32 = ctypes.windll.kernel32
        
        # Try to find and bring existing window to front
        def enum_windows_callback(hwnd, lParam):
            if user32.IsWindowVisible(hwnd):
                length = user32.GetWindowTextLengthW(hwnd)
                if length > 0:
                    buffer = ctypes.create_unicode_buffer(length + 1)
                    user32.GetWindowTextW(hwnd, buffer, length + 1)
                    if "Death Counter" in buffer.value:
                        user32.SetForegroundWindow(hwnd)
                        user32.ShowWindow(hwnd, 9)  # SW_RESTORE
                        return False  # Stop enumeration
            return True
        
        EnumWindowsProc = ctypes.WINFUNCTYPE(ctypes.c_bool, ctypes.POINTER(ctypes.c_int), ctypes.POINTER(ctypes.c_int))
        callback = EnumWindowsProc(enum_windows_callback)
        user32.EnumWindows(callback, None)
        
        sys.exit(0)

import os
import base64
import subprocess
import shutil
import tempfile
from pathlib import Path

# CRITICAL: Fix Tcl/Tk version conflicts BEFORE importing tkinter
# This must be done for maximum compatibility across Python 3.8-3.12
def setup_tcl_tk_environment():
    """Set up Tcl/Tk environment variables to use system Python's Tcl/Tk.
    This prevents version conflicts when running as PyInstaller bundle."""
    try:
        # Only run if we're a PyInstaller bundle (frozen=True)
        if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
            # Strategy 1: Try to find system Python's Tcl/Tk from common locations
            possible_python_paths = []
            
            # Check if Python is in PATH
            try:
                result = subprocess.run(['python', '--version'], 
                                      capture_output=True, text=True, timeout=2)
                if result.returncode == 0:
                    python_exe = shutil.which('python')
                    if python_exe:
                        possible_python_paths.append(python_exe)
            except:
                pass
            
            # Check common Python installation locations
            common_paths = [
                os.path.join(os.environ.get('LOCALAPPDATA', ''), 'Programs', 'Python'),
                os.path.join(os.environ.get('PROGRAMFILES', ''), 'Python'),
                os.path.join(os.environ.get('PROGRAMFILES(X86)', ''), 'Python'),
            ]
            
            for base_path in common_paths:
                if os.path.exists(base_path):
                    try:
                        for item in os.listdir(base_path):
                            python_dir = os.path.join(base_path, item)
                            if os.path.isdir(python_dir):
                                python_exe = os.path.join(python_dir, 'python.exe')
                                if os.path.exists(python_exe):
                                    possible_python_paths.append(python_exe)
                    except:
                        continue
            
            # Try each Python installation to find Tcl/Tk
            for python_exe in possible_python_paths:
                try:
                    python_dir = os.path.dirname(os.path.abspath(python_exe))
                    python_lib = os.path.join(python_dir, 'Lib')
                    tkinter_path = os.path.join(python_lib, 'tkinter')
                    
                    if os.path.exists(tkinter_path):
                        tcl_path = os.path.join(tkinter_path, 'tcl')
                        tk_path = os.path.join(tkinter_path, 'tk')
                        
                        # Verify Tcl/Tk directories exist and contain init files
                        if os.path.exists(tcl_path) and os.path.exists(tk_path):
                            init_tcl = os.path.join(tcl_path, 'init.tcl')
                            if os.path.exists(init_tcl):
                                # Use system Tcl/Tk (works with Python 3.8-3.12)
                                tcl_abs = os.path.abspath(tcl_path)
                                tk_abs = os.path.abspath(tk_path)
                                os.environ['TCL_LIBRARY'] = tcl_abs
                                os.environ['TK_LIBRARY'] = tk_abs
                                # Also set PATH variables
                                os.environ['TCL_LIBRARY_PATH'] = tcl_abs
                                os.environ['TK_LIBRARY_PATH'] = tk_abs
                                return  # Found working Tcl/Tk, stop searching
                except Exception:
                    continue  # Try next Python installation
            
            # Strategy 2: If no system Tcl/Tk found, ensure bundled version works
            # PyInstaller should have bundled Tcl/Tk in _MEIPASS
            meipass = getattr(sys, '_MEIPASS', '')
            if meipass:
                bundled_tcl = os.path.join(meipass, '_internal', 'tcl')
                bundled_tk = os.path.join(meipass, '_internal', 'tk')
                if os.path.exists(bundled_tcl) and os.path.exists(bundled_tk):
                    os.environ['TCL_LIBRARY'] = os.path.abspath(bundled_tcl)
                    os.environ['TK_LIBRARY'] = os.path.abspath(bundled_tk)
    except Exception:
        pass  # Fall back to default behavior

# Call setup BEFORE importing tkinter
setup_tcl_tk_environment()

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
import webbrowser

# Embedded files (base64 encoded)
EMBEDDED_FILES = {
  "multi_game_death_counter.py": "IiIiDQpNdWx0aS1HYW1lIERlYXRoIENvdW50ZXIgRGFlbW9uDQpTdXBwb3J0cyBtdWx0aXBsZSBnYW1lcyB3aXRoIGNvbmZpZ3VyYWJsZSBkZXRlY3Rpb24gcmVnaW9ucyBhbmQga2V5d29yZHMuDQpBdXRvbWF0aWNhbGx5IHRyYWNrcyBkZWF0aHMgYWNyb3NzIGRpZmZlcmVudCBnYW1lcy4NCkF1dG8tZGV0ZWN0cyB3aGljaCBnYW1lIGlzIHJ1bm5pbmcgYnkgY2hlY2tpbmcgcHJvY2VzcyBuYW1lcy4NCg0KUmVxdWlyZW1lbnRzOg0KICAgIHBpcCBpbnN0YWxsIG1zcyBwaWxsb3cgcHl0ZXNzZXJhY3Qgb3BlbmN2LXB5dGhvbiBudW1weSBwc3V0aWwNCiIiIg0KDQppbXBvcnQgb3MNCmltcG9ydCBzeXMNCmltcG9ydCB0aW1lDQppbXBvcnQgY3R5cGVzDQppbXBvcnQganNvbg0KaW1wb3J0IHRyYWNlYmFjaw0KaW1wb3J0IHN1YnByb2Nlc3MNCmltcG9ydCBwc3V0aWwNCmZyb20gZGF0ZXRpbWUgaW1wb3J0IGRhdGV0aW1lDQpmcm9tIHR5cGluZyBpbXBvcnQgRGljdCwgTGlzdCwgVHVwbGUsIE9wdGlvbmFsDQoNCiMgV2luZG93cyBBUEkgdHlwZXMgZm9yIHdpbmRvdyBkZXRlY3Rpb24NCnRyeToNCiAgICBmcm9tIGN0eXBlcyBpbXBvcnQgd2ludHlwZXMNCmV4Y2VwdCBJbXBvcnRFcnJvcjoNCiAgICB3aW50eXBlcyA9IE5vbmUNCg0KaW1wb3J0IGN2Mg0KaW1wb3J0IG51bXB5IGFzIG5wDQpmcm9tIFBJTCBpbXBvcnQgSW1hZ2UNCmZyb20gbXNzIGltcG9ydCBtc3MNCmltcG9ydCBweXRlc3NlcmFjdA0KDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCiMgQ09ORklHVVJBVElPTg0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQojIEdldCB0aGUgZGlyZWN0b3J5IHdoZXJlIHRoaXMgc2NyaXB0IGlzIGxvY2F0ZWQgKHdvcmtzIGZvciBib3RoIC5leGUgYW5kIC5weSkNCmRlZiBnZXRfYmFzZV9kaXIoKToNCiAgICAiIiJHZXQgdGhlIGJhc2UgZGlyZWN0b3J5IC0gc2FtZSBmb2xkZXIgYXMgdGhpcyBzY3JpcHQuIiIiDQogICAgaWYgZ2V0YXR0cihzeXMsICdmcm96ZW4nLCBGYWxzZSk6DQogICAgICAgICMgUnVubmluZyBhcyBjb21waWxlZCAuZXhlIC0gdXNlIHRoZSBkaXJlY3Rvcnkgd2hlcmUgLmV4ZSBpcyBsb2NhdGVkDQogICAgICAgIHJldHVybiBvcy5wYXRoLmRpcm5hbWUob3MucGF0aC5hYnNwYXRoKHN5cy5leGVjdXRhYmxlKSkNCiAgICBlbHNlOg0KICAgICAgICAjIFJ1bm5pbmcgYXMgc2NyaXB0IC0gdXNlIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIHNjcmlwdCBpcyBsb2NhdGVkDQogICAgICAgIHJldHVybiBvcy5wYXRoLmRpcm5hbWUob3MucGF0aC5hYnNwYXRoKF9fZmlsZV9fKSkNCg0KQkFTRV9ESVIgPSBnZXRfYmFzZV9kaXIoKQ0KQ09ORklHX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJnYW1lc19jb25maWcuanNvbiIpDQpMT0NLX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkYWVtb24ubG9jayIpDQpSRUFEWV9GSUxFID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZGFlbW9uLnJlYWR5IikgICMgU2lnbmFsIGZpbGUgY3JlYXRlZCBhZnRlciBmdWxsIGluaXRpYWxpemF0aW9uDQpTVE9QX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJTVE9QIikNCg0KREVCVUdfUkFXID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZGVidWdfY2FwdHVyZV9yYXcucG5nIikNCkRFQlVHX09DUiA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYnVnX2NhcHR1cmUucG5nIikNCkRFQlVHX0xPRyA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYnVnLmxvZyIpDQoNCkRFQVRIX1RYVCA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYXRoX2NvdW50ZXIudHh0IikNClNUQVRFX0pTT04gPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkZWF0aF9zdGF0ZS5qc29uIikNCkNVUlJFTlRfR0FNRV9UWFQgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJjdXJyZW50X2dhbWUudHh0IikgICMgQ3VycmVudCBnYW1lIG5hbWUgZm9yIFN0cmVhbWVyLmJvdA0KQ1VSUkVOVF9ERUFUSFNfVFhUID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiY3VycmVudF9kZWF0aHMudHh0IikgICMgQ3VycmVudCBnYW1lIGRlYXRoIGNvdW50IGZvciBTdHJlYW1lci5ib3QNClRPVEFMX0RFQVRIU19UWFQgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJ0b3RhbF9kZWF0aHMudHh0IikgICMgVG90YWwgZGVhdGhzIGFjcm9zcyBhbGwgZ2FtZXMgZm9yIFN0cmVhbWVyLmJvdA0KDQojIEZpbmQgVGVzc2VyYWN0IGV4ZWN1dGFibGUgLSBjaGVjayBjb21tb24gbG9jYXRpb25zDQpkZWYgZmluZF90ZXNzZXJhY3RfZXhlY3V0YWJsZSgpOg0KICAgICIiIkZpbmQgVGVzc2VyYWN0IE9DUiBleGVjdXRhYmxlIGluIGNvbW1vbiBpbnN0YWxsYXRpb24gbG9jYXRpb25zLiIiIg0KICAgICMgQ29tbW9uIFRlc3NlcmFjdCBpbnN0YWxsYXRpb24gcGF0aHMNCiAgICBjb21tb25fcGF0aHMgPSBbDQogICAgICAgIHIiQzpcUHJvZ3JhbSBGaWxlc1xUZXNzZXJhY3QtT0NSXHRlc3NlcmFjdC5leGUiLA0KICAgICAgICByIkM6XFByb2dyYW0gRmlsZXMgKHg4NilcVGVzc2VyYWN0LU9DUlx0ZXNzZXJhY3QuZXhlIiwNCiAgICAgICAgb3MucGF0aC5qb2luKG9zLmdldGVudignUHJvZ3JhbUZpbGVzJywgcidDOlxQcm9ncmFtIEZpbGVzJyksICdUZXNzZXJhY3QtT0NSJywgJ3Rlc3NlcmFjdC5leGUnKSwNCiAgICAgICAgb3MucGF0aC5qb2luKG9zLmdldGVudignUHJvZ3JhbUZpbGVzKHg4NiknLCByJ0M6XFByb2dyYW0gRmlsZXMgKHg4NiknKSwgJ1Rlc3NlcmFjdC1PQ1InLCAndGVzc2VyYWN0LmV4ZScpLA0KICAgIF0NCiAgICANCiAgICAjIENoZWNrIGlmIHRlc3NlcmFjdCBpcyBpbiBQQVRIDQogICAgdHJ5Og0KICAgICAgICByZXN1bHQgPSBzdWJwcm9jZXNzLnJ1bihbJ3Rlc3NlcmFjdCcsICctLXZlcnNpb24nXSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLCB0ZXh0PVRydWUsIHRpbWVvdXQ9MikNCiAgICAgICAgaWYgcmVzdWx0LnJldHVybmNvZGUgPT0gMDoNCiAgICAgICAgICAgIHJldHVybiAndGVzc2VyYWN0JyAgIyBVc2UgY29tbWFuZCBuYW1lIGlmIGluIFBBVEgNCiAgICBleGNlcHQ6DQogICAgICAgIHBhc3MNCiAgICANCiAgICAjIENoZWNrIGNvbW1vbiBwYXRocw0KICAgIGZvciBwYXRoIGluIGNvbW1vbl9wYXRoczoNCiAgICAgICAgaWYgb3MucGF0aC5leGlzdHMocGF0aCk6DQogICAgICAgICAgICByZXR1cm4gcGF0aA0KICAgIA0KICAgICMgRGVmYXVsdCBmYWxsYmFjaw0KICAgIHJldHVybiByIkM6XFByb2dyYW0gRmlsZXNcVGVzc2VyYWN0LU9DUlx0ZXNzZXJhY3QuZXhlIg0KDQpURVNTRVJBQ1RfRVhFID0gZmluZF90ZXNzZXJhY3RfZXhlY3V0YWJsZSgpDQpweXRlc3NlcmFjdC5weXRlc3NlcmFjdC50ZXNzZXJhY3RfY21kID0gVEVTU0VSQUNUX0VYRQ0KDQojIERlZmF1bHQgc2V0dGluZ3MNCkRFRkFVTFRfU0VUVElOR1MgPSB7DQogICAgInRpY2tfc2Vjb25kcyI6IDAuMzAsDQogICAgImRlYnVnX2V2ZXJ5X3RpY2tzIjogMzAsDQogICAgImNvbnNlY3V0aXZlX2hpdHMiOiAyLA0KICAgICJjb29sZG93bl9zZWNvbmRzIjogOC4wLA0KICAgICJtb25pdG9yX2luZGV4IjogMSwgICMgMS1pbmRleGVkIChtb25pdG9yIDEgaXMgcHJpbWFyeSkNCn0NCg0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQojIERFRkFVTFQgR0FNRSBDT05GSUdTDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCkRFRkFVTFRfR0FNRVMgPSB7DQogICAgIkVsZGVuIFJpbmciOiB7DQogICAgICAgICJyZWdpb24iOiB7InVzZV9wZXJjZW50YWdlcyI6IFRydWUsICJsZWZ0IjogMC4yNzA4LCAidG9wIjogMC40MzUyLCAid2lkdGgiOiAwLjQ1ODMsICJoZWlnaHQiOiAwLjE4NTJ9LA0KICAgICAgICAia2V5d29yZHMiOiBbIllPVURJRUQiLCAiWU9VRElFIiwgIkRJRUQiXSwNCiAgICAgICAgInRlc3NlcmFjdF9jb25maWciOiAiLS1vZW0gMyAtLXBzbSA3IC1jIHRlc3NlZGl0X2NoYXJfd2hpdGVsaXN0PVlPVURJRUFERlQiLA0KICAgICAgICAibW9uaXRvcl9pbmRleCI6IDIsDQogICAgICAgICJwcm9jZXNzX25hbWVzIjogWyJlbGRlbnJpbmcuZXhlIiwgImVsZGVuIHJpbmcuZXhlIl0sICAjIFByb2Nlc3MgbmFtZXMgdG8gZGV0ZWN0DQogICAgfSwNCiAgICAiRGFyayBTb3VscyAzIjogew0KICAgICAgICAicmVnaW9uIjogeyJ1c2VfcGVyY2VudGFnZXMiOiBUcnVlLCAibGVmdCI6IDAuMjcwOCwgInRvcCI6IDAuNDM1MiwgIndpZHRoIjogMC40NTgzLCAiaGVpZ2h0IjogMC4xODUyfSwNCiAgICAgICAgImtleXdvcmRzIjogWyJZT1VESUVEIiwgIllPVURJRSIsICJZT1VEMUVEIiwgIllPVURsRUQiLCAiWU9VREkiLCAiT1VESUVEIiwgIllPVURJRTAiXSwNCiAgICAgICAgInRlc3NlcmFjdF9jb25maWciOiAiLS1vZW0gMyAtLXBzbSA3IC1jIHRlc3NlZGl0X2NoYXJfd2hpdGVsaXN0PVlPVURJRUFERlQiLA0KICAgICAgICAibW9uaXRvcl9pbmRleCI6IDIsDQogICAgICAgICJwcm9jZXNzX25hbWVzIjogWyJkYXJrc291bHNpaWkuZXhlIiwgImRhcmsgc291bHMgaWlpLmV4ZSJdLA0KICAgIH0sDQogICAgIkRhcmsgU291bHMgUmVtYXN0ZXJlZCI6IHsNCiAgICAgICAgInJlZ2lvbiI6IHsidXNlX3BlcmNlbnRhZ2VzIjogVHJ1ZSwgImxlZnQiOiAwLjI3MDgsICJ0b3AiOiAwLjQzNTIsICJ3aWR0aCI6IDAuNDU4MywgImhlaWdodCI6IDAuMTg1Mn0sDQogICAgICAgICJrZXl3b3JkcyI6IFsiWU9VRElFRCIsICJZT1VESUUiLCAiWU9VRDFFRCIsICJZT1VEbEVEIiwgIllPVURJIiwgIk9VRElFRCIsICJZT1VESUUwIl0sDQogICAgICAgICJ0ZXNzZXJhY3RfY29uZmlnIjogIi0tb2VtIDMgLS1wc20gNyAtYyB0ZXNzZWRpdF9jaGFyX3doaXRlbGlzdD1ZT1VESUVBREZUIiwNCiAgICAgICAgIm1vbml0b3JfaW5kZXgiOiAyLA0KICAgICAgICAicHJvY2Vzc19uYW1lcyI6IFsiZGFya3NvdWxzcmVtYXN0ZXJlZC5leGUiLCAiZGFyayBzb3VscyByZW1hc3RlcmVkLmV4ZSJdLA0KICAgIH0sDQogICAgIkRhcmsgU291bHMgSUk6IFNjaG9sYXIgb2YgdGhlIEZpcnN0IFNpbiI6IHsNCiAgICAgICAgInJlZ2lvbiI6IHsidXNlX3BlcmNlbnRhZ2VzIjogVHJ1ZSwgImxlZnQiOiAwLjI3MDgsICJ0b3AiOiAwLjQzNTIsICJ3aWR0aCI6IDAuNDU4MywgImhlaWdodCI6IDAuMTg1Mn0sDQogICAgICAgICJrZXl3b3JkcyI6IFsiWU9VRElFRCIsICJZT1VESUUiLCAiWU9VRDFFRCIsICJZT1VEbEVEIiwgIllPVURJIiwgIk9VRElFRCIsICJZT1VESUUwIl0sDQogICAgICAgICJ0ZXNzZXJhY3RfY29uZmlnIjogIi0tb2VtIDMgLS1wc20gNyAtYyB0ZXNzZWRpdF9jaGFyX3doaXRlbGlzdD1ZT1VESUVBREZUIiwNCiAgICAgICAgIm1vbml0b3JfaW5kZXgiOiAyLA0KICAgICAgICAicHJvY2Vzc19uYW1lcyI6IFsiZGFya3NvdWxzaWkuZXhlIiwgImRhcmsgc291bHMgaWkuZXhlIiwgImRhcmtzb3VsczIuZXhlIl0sDQogICAgfSwNCiAgICAiU2VraXJvIjogew0KICAgICAgICAicmVnaW9uIjogeyJ1c2VfcGVyY2VudGFnZXMiOiBUcnVlLCAibGVmdCI6IDAuMzgwMiwgInRvcCI6IDAuMjY4NSwgIndpZHRoIjogMC4yMjQwLCAiaGVpZ2h0IjogMC40MDc0fSwNCiAgICAgICAgImtleXdvcmRzIjogWyJERUFUSCIsICLmrbsiXSwNCiAgICAgICAgInRlc3NlcmFjdF9jb25maWciOiAiLS1vZW0gMyAtLXBzbSA3IiwNCiAgICAgICAgInRlc3NlcmFjdF9sYW5nIjogImpwbitlbmciLA0KICAgICAgICAibW9uaXRvcl9pbmRleCI6IDIsDQogICAgICAgICJwcm9jZXNzX25hbWVzIjogWyJzZWtpcm8uZXhlIl0sDQogICAgfSwNCn0NCg0KDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCiMgRFBJIEFXQVJFTkVTUw0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQpkZWYgZW5hYmxlX2RwaV9hd2FyZW5lc3MoKToNCiAgICB0cnk6DQogICAgICAgIGN0eXBlcy53aW5kbGwuc2hjb3JlLlNldFByb2Nlc3NEcGlBd2FyZW5lc3MoMikNCiAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICB0cnk6DQogICAgICAgICAgICBjdHlwZXMud2luZGxsLnVzZXIzMi5TZXRQcm9jZXNzRFBJQXdhcmUoKQ0KICAgICAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICAgICAgcGFzcw0KDQoNCmRlZiBtb3ZlX2NvbnNvbGVfdG9fdG9wX3JpZ2h0KCk6DQogICAgIiIiTW92ZSBjb25zb2xlIHdpbmRvdyB0byB0b3AgcmlnaHQgY29ybmVyIHNvIGl0IGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggY2FwdHVyZS4iIiINCiAgICB0cnk6DQogICAgICAgIGltcG9ydCBzeXMNCiAgICAgICAgaWYgc3lzLnBsYXRmb3JtID09ICJ3aW4zMiI6DQogICAgICAgICAgICBpbXBvcnQgb3MNCiAgICAgICAgICAgICMgR2V0IGNvbnNvbGUgd2luZG93IGhhbmRsZQ0KICAgICAgICAgICAga2VybmVsMzIgPSBjdHlwZXMud2luZGxsLmtlcm5lbDMyDQogICAgICAgICAgICB1c2VyMzIgPSBjdHlwZXMud2luZGxsLnVzZXIzMg0KICAgICAgICAgICAgDQogICAgICAgICAgICAjIEdldCBjb25zb2xlIHdpbmRvdw0KICAgICAgICAgICAgaHduZCA9IGtlcm5lbDMyLkdldENvbnNvbGVXaW5kb3coKQ0KICAgICAgICAgICAgaWYgaHduZDoNCiAgICAgICAgICAgICAgICAjIEdldCBzY3JlZW4gZGltZW5zaW9ucw0KICAgICAgICAgICAgICAgIHNjcmVlbl93aWR0aCA9IHVzZXIzMi5HZXRTeXN0ZW1NZXRyaWNzKDApICAjIFNNX0NYU0NSRUVODQogICAgICAgICAgICAgICAgc2NyZWVuX2hlaWdodCA9IHVzZXIzMi5HZXRTeXN0ZW1NZXRyaWNzKDEpICAjIFNNX0NZU0NSRUVODQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgIyBDb25zb2xlIHdpbmRvdyBzaXplIChhcHByb3hpbWF0ZSkNCiAgICAgICAgICAgICAgICB3aW5kb3dfd2lkdGggPSA4MDANCiAgICAgICAgICAgICAgICB3aW5kb3dfaGVpZ2h0ID0gNjAwDQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgIyBQb3NpdGlvbiBpbiB0b3AgcmlnaHQgY29ybmVyDQogICAgICAgICAgICAgICAgeCA9IHNjcmVlbl93aWR0aCAtIHdpbmRvd193aWR0aCAtIDIwICAjIDIwcHggbWFyZ2luIGZyb20gcmlnaHQNCiAgICAgICAgICAgICAgICB5ID0gMjAgICMgMjBweCBtYXJnaW4gZnJvbSB0b3ANCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAjIE1vdmUgd2luZG93DQogICAgICAgICAgICAgICAgdXNlcjMyLlNldFdpbmRvd1Bvcyhod25kLCAwLCB4LCB5LCB3aW5kb3dfd2lkdGgsIHdpbmRvd19oZWlnaHQsIDB4MDA0MCkgICMgU1dQX1NIT1dXSU5ET1cNCiAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICBwYXNzICAjIFNpbGVudGx5IGZhaWwgaWYgd2UgY2FuJ3QgbW92ZSB0aGUgd2luZG93DQoNCg0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQojIExPR0dJTkcNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KZGVmIGxvZyhtc2c6IHN0cik6DQogICAgb3MubWFrZWRpcnMoQkFTRV9ESVIsIGV4aXN0X29rPVRydWUpDQogICAgdHMgPSBkYXRldGltZS5ub3coKS5zdHJmdGltZSgiWyVZLSVtLSVkICVIOiVNOiVTXSIpDQogICAgdHJ5Og0KICAgICAgICB3aXRoIG9wZW4oREVCVUdfTE9HLCAiYSIsIGVuY29kaW5nPSJ1dGYtOCIsIGVycm9ycz0ncmVwbGFjZScpIGFzIGY6DQogICAgICAgICAgICBmLndyaXRlKGYie3RzfSB7bXNnfVxuIikNCiAgICAgICAgIyBQcmludCB0byBjb25zb2xlIHdpdGggZXJyb3IgaGFuZGxpbmcgZm9yIFVuaWNvZGUNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgcHJpbnQobXNnKQ0KICAgICAgICBleGNlcHQgVW5pY29kZUVuY29kZUVycm9yOg0KICAgICAgICAgICAgIyBJZiBjb25zb2xlIGNhbid0IGhhbmRsZSBVbmljb2RlLCBwcmludCBBU0NJSSB2ZXJzaW9uDQogICAgICAgICAgICBwcmludChtc2cuZW5jb2RlKCdhc2NpaScsIGVycm9ycz0ncmVwbGFjZScpLmRlY29kZSgnYXNjaWknKSkNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgICMgU2lsZW50bHkgZmFpbCBpZiB3ZSBjYW4ndCB3cml0ZSB0byBsb2cNCiAgICAgICAgcGFzcw0KDQoNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KIyBDT05GSUdVUkFUSU9OIE1BTkFHRU1FTlQNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KZGVmIGxvYWRfY29uZmlnKCkgLT4gRGljdDoNCiAgICAiIiJMb2FkIGdhbWUgY29uZmlndXJhdGlvbnMgZnJvbSBKU09OIGZpbGUsIG9yIGNyZWF0ZSBkZWZhdWx0LiIiIg0KICAgIG9zLm1ha2VkaXJzKEJBU0VfRElSLCBleGlzdF9vaz1UcnVlKQ0KICAgIA0KICAgIGlmIG9zLnBhdGguZXhpc3RzKENPTkZJR19GSUxFKToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgd2l0aCBvcGVuKENPTkZJR19GSUxFLCAiciIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICAgICAgY29uZmlnID0ganNvbi5sb2FkKGYpDQogICAgICAgICAgICAjIE1lcmdlIHdpdGggZGVmYXVsdHMgdG8gZW5zdXJlIGFsbCBrZXlzIGV4aXN0DQogICAgICAgICAgICBzZXR0aW5ncyA9IHsqKkRFRkFVTFRfU0VUVElOR1MsICoqY29uZmlnLmdldCgic2V0dGluZ3MiLCB7fSl9DQogICAgICAgICAgICBnYW1lcyA9IHsqKkRFRkFVTFRfR0FNRVMsICoqY29uZmlnLmdldCgiZ2FtZXMiLCB7fSl9DQogICAgICAgICAgICByZXR1cm4geyJzZXR0aW5ncyI6IHNldHRpbmdzLCAiZ2FtZXMiOiBnYW1lc30NCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICAgICAgbG9nKGYiRXJyb3IgbG9hZGluZyBjb25maWc6IHtlfS4gVXNpbmcgZGVmYXVsdHMuIikNCiAgICANCiAgICAjIENyZWF0ZSBkZWZhdWx0IGNvbmZpZyBmaWxlDQogICAgZGVmYXVsdF9jb25maWcgPSB7DQogICAgICAgICJzZXR0aW5ncyI6IERFRkFVTFRfU0VUVElOR1MsDQogICAgICAgICJnYW1lcyI6IERFRkFVTFRfR0FNRVMsDQogICAgICAgICJjdXJyZW50X2dhbWUiOiBsaXN0KERFRkFVTFRfR0FNRVMua2V5cygpKVswXSBpZiBERUZBVUxUX0dBTUVTIGVsc2UgTm9uZQ0KICAgIH0NCiAgICBzYXZlX2NvbmZpZyhkZWZhdWx0X2NvbmZpZykNCiAgICByZXR1cm4gZGVmYXVsdF9jb25maWcNCg0KDQpkZWYgc2F2ZV9jb25maWcoY29uZmlnOiBEaWN0KToNCiAgICAiIiJTYXZlIGNvbmZpZ3VyYXRpb24gdG8gSlNPTiBmaWxlLiIiIg0KICAgIHRyeToNCiAgICAgICAgd2l0aCBvcGVuKENPTkZJR19GSUxFLCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBqc29uLmR1bXAoY29uZmlnLCBmLCBpbmRlbnQ9MikNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIGxvZyhmIkVycm9yIHNhdmluZyBjb25maWc6IHtlfSIpDQoNCg0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQojIExPQ0sgSEFORExJTkcNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KZGVmIGFjcXVpcmVfbG9jaygpIC0+IGJvb2w6DQogICAgIiIiQ3JlYXRlIGxvY2sgZmlsZSBpbW1lZGlhdGVseSAtIHRoaXMgaXMgdGhlIGZpcnN0IHRoaW5nIHdlIGRvLiIiIg0KICAgIG9zLm1ha2VkaXJzKEJBU0VfRElSLCBleGlzdF9vaz1UcnVlKQ0KICAgIGlmIG9zLnBhdGguZXhpc3RzKExPQ0tfRklMRSk6DQogICAgICAgIHRyeToNCiAgICAgICAgICAgIHdpdGggb3BlbihMT0NLX0ZJTEUsICJyIikgYXMgZjoNCiAgICAgICAgICAgICAgICBwaWQgPSBmLnJlYWQoKS5zdHJpcCgpDQogICAgICAgICAgICBsb2coZiJMT0NLIEVYSVNUUzogZGFlbW9uLmxvY2sgcHJlc2VudCAoUElEOiB7cGlkfSkuIEV4aXRpbmcgdG8gYXZvaWQgZHVwbGljYXRlcy4iKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBsb2coIkxPQ0sgRVhJU1RTOiBkYWVtb24ubG9jayBwcmVzZW50LiBFeGl0aW5nIHRvIGF2b2lkIGR1cGxpY2F0ZXMuIikNCiAgICAgICAgcmV0dXJuIEZhbHNlDQogICAgdHJ5Og0KICAgICAgICAjIENyZWF0ZSBsb2NrIGZpbGUgaW1tZWRpYXRlbHkgLSBiZWZvcmUgYW55IG90aGVyIGluaXRpYWxpemF0aW9uDQogICAgICAgIHdpdGggb3BlbihMT0NLX0ZJTEUsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgIGYud3JpdGUoc3RyKG9zLmdldHBpZCgpKSkNCiAgICAgICAgIyBGb3JjZSBmaWxlIHN5c3RlbSBmbHVzaA0KICAgICAgICBpbXBvcnQgc3lzDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgICAgICBzeXMuc3RkZXJyLmZsdXNoKCkNCiAgICAgICAgbG9nKGYiTE9DSyBDUkVBVEVEOiBkYWVtb24ubG9jayBjcmVhdGVkIHdpdGggUElEIHtvcy5nZXRwaWQoKX0iKQ0KICAgICAgICByZXR1cm4gVHJ1ZQ0KICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgbG9nKGYiTE9DSyBFUlJPUjoge2V9IikNCiAgICAgICAgcmV0dXJuIEZhbHNlDQoNCg0KZGVmIHJlbGVhc2VfbG9jaygpOg0KICAgIHRyeToNCiAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoTE9DS19GSUxFKToNCiAgICAgICAgICAgIG9zLnJlbW92ZShMT0NLX0ZJTEUpDQogICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpOg0KICAgICAgICAgICAgb3MucmVtb3ZlKFJFQURZX0ZJTEUpDQogICAgZXhjZXB0IEV4Y2VwdGlvbjoNCiAgICAgICAgcGFzcw0KDQoNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KIyBTVEFURSBNQU5BR0VNRU5UDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCmRlZiBsb2FkX3N0YXRlKCkgLT4gRGljdDoNCiAgICAiIiJMb2FkIHN0YXRlIGZyb20gSlNPTiBmaWxlLiIiIg0KICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhTVEFURV9KU09OKToNCiAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICJ0b3RhbF9kZWF0aHMiOiAwLA0KICAgICAgICAgICAgImdhbWVfZGVhdGhzIjoge30sDQogICAgICAgICAgICAidGljayI6IDAsDQogICAgICAgICAgICAic3RyZWFrIjogMCwNCiAgICAgICAgICAgICJsYXN0X2RlYXRoX3RzIjogMC4wLA0KICAgICAgICAgICAgImN1cnJlbnRfZ2FtZSI6IE5vbmUsDQogICAgICAgIH0NCiAgICB0cnk6DQogICAgICAgIHdpdGggb3BlbihTVEFURV9KU09OLCAiciIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBzdGF0ZSA9IGpzb24ubG9hZChmKQ0KICAgIGV4Y2VwdCBFeGNlcHRpb246DQogICAgICAgIHN0YXRlID0ge30NCiAgICANCiAgICBzdGF0ZS5zZXRkZWZhdWx0KCJ0b3RhbF9kZWF0aHMiLCAwKQ0KICAgIHN0YXRlLnNldGRlZmF1bHQoImdhbWVfZGVhdGhzIiwge30pDQogICAgc3RhdGUuc2V0ZGVmYXVsdCgidGljayIsIDApDQogICAgc3RhdGUuc2V0ZGVmYXVsdCgic3RyZWFrIiwgMCkNCiAgICBzdGF0ZS5zZXRkZWZhdWx0KCJsYXN0X2RlYXRoX3RzIiwgMC4wKQ0KICAgIHN0YXRlLnNldGRlZmF1bHQoImN1cnJlbnRfZ2FtZSIsIE5vbmUpDQogICAgcmV0dXJuIHN0YXRlDQoNCg0KZGVmIHNhdmVfc3RhdGUoc3RhdGU6IERpY3QpOg0KICAgICIiIlNhdmUgc3RhdGUgdG8gSlNPTiBmaWxlLiIiIg0KICAgIHRyeToNCiAgICAgICAgd2l0aCBvcGVuKFNUQVRFX0pTT04sICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgIGpzb24uZHVtcChzdGF0ZSwgZiwgaW5kZW50PTIpDQogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICBsb2coZiJFcnJvciBzYXZpbmcgc3RhdGU6IHtlfSIpDQoNCg0KZGVmIHdyaXRlX3RleHQoZGVhdGhzOiBpbnQsIGdhbWVfbmFtZTogc3RyID0gTm9uZSk6DQogICAgIiIiV3JpdGUgZGVhdGggY291bnQgdG8gdGV4dCBmaWxlIGZvciBPQlMuIiIiDQogICAgdHJ5Og0KICAgICAgICAjIFdyaXRlIHRvdGFsIGRlYXRocw0KICAgICAgICB3aXRoIG9wZW4oREVBVEhfVFhULCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBmLndyaXRlKHN0cihkZWF0aHMpKQ0KICAgICAgICANCiAgICAgICAgIyBBbHNvIHdyaXRlIHBlci1nYW1lIGZpbGUgaWYgZ2FtZSBuYW1lIHByb3ZpZGVkDQogICAgICAgIGlmIGdhbWVfbmFtZToNCiAgICAgICAgICAgIGdhbWVfdHh0ID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCBmImRlYXRoX2NvdW50ZXJfe2dhbWVfbmFtZS5yZXBsYWNlKCcgJywgJ18nKX0udHh0IikNCiAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICBzdGF0ZSA9IGxvYWRfc3RhdGUoKQ0KICAgICAgICAgICAgICAgIGdhbWVfZGVhdGhzID0gc3RhdGUuZ2V0KCJnYW1lX2RlYXRocyIsIHt9KS5nZXQoZ2FtZV9uYW1lLCAwKQ0KICAgICAgICAgICAgICAgIHdpdGggb3BlbihnYW1lX3R4dCwgInciLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOg0KICAgICAgICAgICAgICAgICAgICBmLndyaXRlKHN0cihnYW1lX2RlYXRocykpDQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgICAgICAgICAgbG9nKGYiRXJyb3Igd3JpdGluZyBnYW1lIHRleHQgZmlsZToge2V9IikNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIGxvZyhmIkVycm9yIHdyaXRpbmcgZGVhdGggdGV4dDoge2V9IikNCg0KDQpkZWYgd3JpdGVfY2hhdF9pbmZvKGdhbWVfbmFtZTogc3RyLCBkZWF0aF9jb3VudDogaW50KToNCiAgICAiIiJXcml0ZSBzaW1wbGUgdGV4dCBmaWxlcyBmb3IgU3RyZWFtZXIuYm90IGNoYXQgY29tbWFuZC4NCiAgICBDcmVhdGVzIHR3byBzZXBhcmF0ZSBmaWxlczoNCiAgICAtIGN1cnJlbnRfZ2FtZS50eHQ6IEp1c3QgdGhlIGdhbWUgbmFtZQ0KICAgIC0gY3VycmVudF9kZWF0aHMudHh0OiBKdXN0IHRoZSBkZWF0aCBjb3VudA0KICAgIFRoaXMgbWFrZXMgaXQgZWFzaWVyIGZvciBTdHJlYW1lci5ib3QgdG8gcmVhZC4NCiAgICAiIiINCiAgICB0cnk6DQogICAgICAgICMgV3JpdGUgZ2FtZSBuYW1lIHRvIHNlcGFyYXRlIGZpbGUNCiAgICAgICAgd2l0aCBvcGVuKENVUlJFTlRfR0FNRV9UWFQsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgIGYud3JpdGUoZ2FtZV9uYW1lKQ0KICAgICAgICANCiAgICAgICAgIyBXcml0ZSBkZWF0aCBjb3VudCB0byBzZXBhcmF0ZSBmaWxlDQogICAgICAgIHdpdGggb3BlbihDVVJSRU5UX0RFQVRIU19UWFQsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgIGYud3JpdGUoc3RyKGRlYXRoX2NvdW50KSkNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIGxvZyhmIkVycm9yIHdyaXRpbmcgY2hhdCBpbmZvOiB7ZX0iKQ0KDQoNCmRlZiB3cml0ZV90b3RhbF9kZWF0aHModG90YWxfZGVhdGhzOiBpbnQpOg0KICAgICIiIldyaXRlIHRvdGFsIGRlYXRocyBhY3Jvc3MgYWxsIGdhbWVzIHRvIGEgc2VwYXJhdGUgZmlsZSBmb3IgU3RyZWFtZXIuYm90LiIiIg0KICAgIHRyeToNCiAgICAgICAgd2l0aCBvcGVuKFRPVEFMX0RFQVRIU19UWFQsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgIGYud3JpdGUoc3RyKHRvdGFsX2RlYXRocykpDQogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICBsb2coZiJFcnJvciB3cml0aW5nIHRvdGFsIGRlYXRoczoge2V9IikNCg0KDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCiMgR0FNRSBERVRFQ1RJT04NCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KZGVmIGdldF9ydW5uaW5nX3Byb2Nlc3NlcygpIC0+IExpc3Rbc3RyXToNCiAgICAiIiJHZXQgbGlzdCBvZiBhbGwgcnVubmluZyBwcm9jZXNzIG5hbWVzIChsb3dlcmNhc2UsIHdpdGhvdXQgLmV4ZSkuIiIiDQogICAgcHJvY2Vzc2VzID0gW10NCiAgICB0cnk6DQogICAgICAgIGZvciBwcm9jIGluIHBzdXRpbC5wcm9jZXNzX2l0ZXIoWyduYW1lJ10pOg0KICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgIHByb2NfbmFtZSA9IHByb2MuaW5mb1snbmFtZSddLmxvd2VyKCkNCiAgICAgICAgICAgICAgICAjIFJlbW92ZSAuZXhlIGV4dGVuc2lvbiBmb3IgbWF0Y2hpbmcNCiAgICAgICAgICAgICAgICBpZiBwcm9jX25hbWUuZW5kc3dpdGgoJy5leGUnKToNCiAgICAgICAgICAgICAgICAgICAgcHJvY19uYW1lID0gcHJvY19uYW1lWzotNF0NCiAgICAgICAgICAgICAgICBwcm9jZXNzZXMuYXBwZW5kKHByb2NfbmFtZSkNCiAgICAgICAgICAgIGV4Y2VwdCAocHN1dGlsLk5vU3VjaFByb2Nlc3MsIHBzdXRpbC5BY2Nlc3NEZW5pZWQpOg0KICAgICAgICAgICAgICAgIHBhc3MNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIGxvZyhmIkVycm9yIGdldHRpbmcgcHJvY2Vzc2VzOiB7ZX0iKQ0KICAgIHJldHVybiBwcm9jZXNzZXMNCg0KDQpkZWYgZ2V0X2dhbWVfcHJvY2VzcyhnYW1lX2NvbmZpZzogRGljdCkgLT4gT3B0aW9uYWxbcHN1dGlsLlByb2Nlc3NdOg0KICAgICIiIkdldCB0aGUgcHJvY2VzcyBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGdhbWUuIiIiDQogICAgcHJvY2Vzc19uYW1lcyA9IGdhbWVfY29uZmlnLmdldCgicHJvY2Vzc19uYW1lcyIsIFtdKQ0KICAgIGlmIG5vdCBwcm9jZXNzX25hbWVzOg0KICAgICAgICByZXR1cm4gTm9uZQ0KICAgIA0KICAgIHRyeToNCiAgICAgICAgZm9yIHByb2MgaW4gcHN1dGlsLnByb2Nlc3NfaXRlcihbJ25hbWUnLCAncGlkJ10pOg0KICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgIHByb2NfbmFtZSA9IHByb2MuaW5mb1snbmFtZSddLmxvd2VyKCkNCiAgICAgICAgICAgICAgICBpZiBwcm9jX25hbWUuZW5kc3dpdGgoJy5leGUnKToNCiAgICAgICAgICAgICAgICAgICAgcHJvY19uYW1lID0gcHJvY19uYW1lWzotNF0NCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICBmb3IgZ2FtZV9wcm9jX25hbWUgaW4gcHJvY2Vzc19uYW1lczoNCiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IGdhbWVfcHJvY19uYW1lLmxvd2VyKCkNCiAgICAgICAgICAgICAgICAgICAgaWYgbm9ybWFsaXplZC5lbmRzd2l0aCgnLmV4ZScpOg0KICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWRbOi00XQ0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgaWYgbm9ybWFsaXplZCA9PSBwcm9jX25hbWU6DQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHN1dGlsLlByb2Nlc3MocHJvYy5pbmZvWydwaWQnXSkNCiAgICAgICAgICAgIGV4Y2VwdCAocHN1dGlsLk5vU3VjaFByb2Nlc3MsIHBzdXRpbC5BY2Nlc3NEZW5pZWQpOg0KICAgICAgICAgICAgICAgIHBhc3MNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIGxvZyhmIkVycm9yIGZpbmRpbmcgZ2FtZSBwcm9jZXNzOiB7ZX0iKQ0KICAgIHJldHVybiBOb25lDQoNCg0KZGVmIGdldF93aW5kb3dfcmVjdChwcm9jZXNzOiBwc3V0aWwuUHJvY2VzcykgLT4gT3B0aW9uYWxbZGljdF06DQogICAgIiIiR2V0IHRoZSB3aW5kb3cgcmVjdGFuZ2xlIGZvciBhIHByb2Nlc3MgdXNpbmcgV2luZG93cyBBUEkuIiIiDQogICAgdHJ5Og0KICAgICAgICAjIFdpbmRvd3MgQVBJIGNvbnN0YW50cw0KICAgICAgICBHV19PV05FUiA9IDQNCiAgICAgICAgDQogICAgICAgICMgRmluZCB3aW5kb3cgYnkgcHJvY2VzcyBJRA0KICAgICAgICB3aW5kb3dzID0gW10NCiAgICAgICAgDQogICAgICAgIGRlZiBlbnVtX3dpbmRvd3NfY2FsbGJhY2soaHduZCwgbFBhcmFtKToNCiAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICBpZiBjdHlwZXMud2luZGxsLnVzZXIzMi5Jc1dpbmRvd1Zpc2libGUoaHduZCk6DQogICAgICAgICAgICAgICAgICAgIHBpZCA9IGN0eXBlcy5jX3Vsb25nKCkNCiAgICAgICAgICAgICAgICAgICAgY3R5cGVzLndpbmRsbC51c2VyMzIuR2V0V2luZG93VGhyZWFkUHJvY2Vzc0lkKGh3bmQsIGN0eXBlcy5ieXJlZihwaWQpKQ0KICAgICAgICAgICAgICAgICAgICBpZiBwaWQudmFsdWUgPT0gcHJvY2Vzcy5waWQ6DQogICAgICAgICAgICAgICAgICAgICAgICAjIENoZWNrIGlmIGl0J3Mgbm90IGEgY2hpbGQgd2luZG93DQogICAgICAgICAgICAgICAgICAgICAgICBvd25lciA9IGN0eXBlcy53aW5kbGwudXNlcjMyLkdldFdpbmRvdyhod25kLCBHV19PV05FUikNCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG93bmVyID09IDA6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93cy5hcHBlbmQoaHduZCkNCiAgICAgICAgICAgIGV4Y2VwdDoNCiAgICAgICAgICAgICAgICBwYXNzDQogICAgICAgICAgICByZXR1cm4gVHJ1ZQ0KICAgICAgICANCiAgICAgICAgIyBEZWZpbmUgY2FsbGJhY2sgdHlwZQ0KICAgICAgICBFbnVtV2luZG93c1Byb2MgPSBjdHlwZXMuV0lORlVOQ1RZUEUoY3R5cGVzLmNfYm9vbCwgY3R5cGVzLmNfdm9pZF9wLCBjdHlwZXMuY192b2lkX3ApDQogICAgICAgIGNhbGxiYWNrID0gRW51bVdpbmRvd3NQcm9jKGVudW1fd2luZG93c19jYWxsYmFjaykNCiAgICAgICAgDQogICAgICAgICMgRmluZCBhbGwgd2luZG93cyBmb3IgdGhpcyBwcm9jZXNzDQogICAgICAgIGN0eXBlcy53aW5kbGwudXNlcjMyLkVudW1XaW5kb3dzKGNhbGxiYWNrLCBOb25lKQ0KICAgICAgICANCiAgICAgICAgaWYgbm90IHdpbmRvd3M6DQogICAgICAgICAgICByZXR1cm4gTm9uZQ0KICAgICAgICANCiAgICAgICAgIyBVc2UgdGhlIGZpcnN0IChtYWluKSB3aW5kb3cNCiAgICAgICAgaHduZCA9IHdpbmRvd3NbMF0NCiAgICAgICAgDQogICAgICAgICMgR2V0IHdpbmRvdyByZWN0YW5nbGUNCiAgICAgICAgY2xhc3MgUkVDVChjdHlwZXMuU3RydWN0dXJlKToNCiAgICAgICAgICAgIF9maWVsZHNfID0gWygibGVmdCIsIGN0eXBlcy5jX2xvbmcpLA0KICAgICAgICAgICAgICAgICAgICAgICAgKCJ0b3AiLCBjdHlwZXMuY19sb25nKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICgicmlnaHQiLCBjdHlwZXMuY19sb25nKSwNCiAgICAgICAgICAgICAgICAgICAgICAgICgiYm90dG9tIiwgY3R5cGVzLmNfbG9uZyldDQogICAgICAgIA0KICAgICAgICByZWN0ID0gUkVDVCgpDQogICAgICAgIGN0eXBlcy53aW5kbGwudXNlcjMyLkdldFdpbmRvd1JlY3QoaHduZCwgY3R5cGVzLmJ5cmVmKHJlY3QpKQ0KICAgICAgICANCiAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICdsZWZ0JzogcmVjdC5sZWZ0LA0KICAgICAgICAgICAgJ3RvcCc6IHJlY3QudG9wLA0KICAgICAgICAgICAgJ3JpZ2h0JzogcmVjdC5yaWdodCwNCiAgICAgICAgICAgICdib3R0b20nOiByZWN0LmJvdHRvbSwNCiAgICAgICAgICAgICd3aWR0aCc6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsDQogICAgICAgICAgICAnaGVpZ2h0JzogcmVjdC5ib3R0b20gLSByZWN0LnRvcA0KICAgICAgICB9DQogICAgZXhjZXB0IEV4Y2VwdGlvbjoNCiAgICAgICAgIyBTaWxlbnRseSBmYWlsIC0gd2lsbCBmYWxsIGJhY2sgdG8gY29uZmlndXJlZCBtb25pdG9yDQogICAgICAgIHJldHVybiBOb25lDQoNCg0KZGVmIGZpbmRfbW9uaXRvcl9mb3Jfd2luZG93KHdpbmRvd19yZWN0OiBkaWN0LCBtb25pdG9yczogTGlzdFtkaWN0XSkgLT4gT3B0aW9uYWxbaW50XToNCiAgICAiIiJGaW5kIHdoaWNoIG1vbml0b3IgY29udGFpbnMgdGhlIGNlbnRlciBvZiB0aGUgd2luZG93LiIiIg0KICAgIGlmIG5vdCB3aW5kb3dfcmVjdDoNCiAgICAgICAgcmV0dXJuIE5vbmUNCiAgICANCiAgICAjIEdldCB3aW5kb3cgY2VudGVyDQogICAgY2VudGVyX3ggPSB3aW5kb3dfcmVjdFsnbGVmdCddICsgd2luZG93X3JlY3RbJ3dpZHRoJ10gLy8gMg0KICAgIGNlbnRlcl95ID0gd2luZG93X3JlY3RbJ3RvcCddICsgd2luZG93X3JlY3RbJ2hlaWdodCddIC8vIDINCiAgICANCiAgICAjIEZpbmQgbW9uaXRvciB0aGF0IGNvbnRhaW5zIHRoaXMgcG9pbnQNCiAgICBmb3IgaSwgbW9uIGluIGVudW1lcmF0ZShtb25pdG9ycyk6DQogICAgICAgIGlmIChtb25bJ2xlZnQnXSA8PSBjZW50ZXJfeCA8IG1vblsnbGVmdCddICsgbW9uWyd3aWR0aCddIGFuZA0KICAgICAgICAgICAgbW9uWyd0b3AnXSA8PSBjZW50ZXJfeSA8IG1vblsndG9wJ10gKyBtb25bJ2hlaWdodCddKToNCiAgICAgICAgICAgIHJldHVybiBpDQogICAgDQogICAgcmV0dXJuIE5vbmUNCg0KDQpkZWYgaXNfd2luZG93X2Z1bGxzY3JlZW5fb3JfYm9yZGVybGVzcyh3aW5kb3dfcmVjdDogZGljdCwgbW9uaXRvcjogZGljdCwgdG9sZXJhbmNlOiBpbnQgPSA1KSAtPiBib29sOg0KICAgICIiIg0KICAgIERldGVybWluZSBpZiB3aW5kb3cgaXMgZnVsbHNjcmVlbiBvciBib3JkZXJsZXNzIChmaWxscyBtb25pdG9yKS4NCiAgICBSZXR1cm5zIFRydWUgaWYgd2luZG93IHNpemUgaXMgd2l0aGluIHRvbGVyYW5jZSBvZiBtb25pdG9yIHNpemUuDQogICAgVGhpcyBpcyB1c2VkIHRvIGF1dG8tZGV0ZWN0IGlmIHdlIHNob3VsZCB1c2Ugd2luZG93LXJlbGF0aXZlIG9yIG1vbml0b3ItcmVsYXRpdmUgY2FwdHVyZS4NCiAgICANCiAgICBBcmdzOg0KICAgICAgICB3aW5kb3dfcmVjdDogV2luZG93IHJlY3RhbmdsZSBkaWN0IHdpdGggJ3dpZHRoJyBhbmQgJ2hlaWdodCcNCiAgICAgICAgbW9uaXRvcjogTW9uaXRvciBkaWN0IHdpdGggJ3dpZHRoJyBhbmQgJ2hlaWdodCcNCiAgICAgICAgdG9sZXJhbmNlOiBQaXhlbCB0b2xlcmFuY2UgZm9yIHNpemUgY29tcGFyaXNvbiAoZGVmYXVsdCA1cHgpDQogICAgDQogICAgUmV0dXJuczoNCiAgICAgICAgVHJ1ZSBpZiB3aW5kb3cgYXBwZWFycyB0byBmaWxsIHRoZSBtb25pdG9yIChmdWxsc2NyZWVuL2JvcmRlcmxlc3MpLCBGYWxzZSBpZiB3aW5kb3dlZA0KICAgICIiIg0KICAgIHRyeToNCiAgICAgICAgaWYgbm90IHdpbmRvd19yZWN0IG9yIG5vdCBtb25pdG9yOg0KICAgICAgICAgICAgcmV0dXJuIFRydWUgICMgRGVmYXVsdCB0byBtb25pdG9yIG1vZGUgaWYgd2UgY2FuJ3QgZGV0ZXJtaW5lDQogICAgICAgIA0KICAgICAgICB3aW5kb3dfd2lkdGggPSB3aW5kb3dfcmVjdC5nZXQoJ3dpZHRoJywgMCkNCiAgICAgICAgd2luZG93X2hlaWdodCA9IHdpbmRvd19yZWN0LmdldCgnaGVpZ2h0JywgMCkNCiAgICAgICAgbW9uaXRvcl93aWR0aCA9IG1vbml0b3IuZ2V0KCd3aWR0aCcsIDApDQogICAgICAgIG1vbml0b3JfaGVpZ2h0ID0gbW9uaXRvci5nZXQoJ2hlaWdodCcsIDApDQogICAgICAgIA0KICAgICAgICBpZiBtb25pdG9yX3dpZHRoID09IDAgb3IgbW9uaXRvcl9oZWlnaHQgPT0gMDoNCiAgICAgICAgICAgIHJldHVybiBUcnVlICAjIEZhbGxiYWNrIHRvIG1vbml0b3IgbW9kZQ0KICAgICAgICANCiAgICAgICAgIyBDaGVjayBpZiB3aW5kb3cgc2l6ZSBpcyB3aXRoaW4gdG9sZXJhbmNlIG9mIG1vbml0b3Igc2l6ZQ0KICAgICAgICB3aWR0aF9kaWZmID0gYWJzKHdpbmRvd193aWR0aCAtIG1vbml0b3Jfd2lkdGgpDQogICAgICAgIGhlaWdodF9kaWZmID0gYWJzKHdpbmRvd19oZWlnaHQgLSBtb25pdG9yX2hlaWdodCkNCiAgICAgICAgDQogICAgICAgICMgSWYgd2luZG93IGlzIHdpdGhpbiB0b2xlcmFuY2UgcGl4ZWxzIG9mIG1vbml0b3Igc2l6ZSwgaXQncyBmdWxsc2NyZWVuL2JvcmRlcmxlc3MNCiAgICAgICAgaXNfZnVsbHNjcmVlbiA9ICh3aWR0aF9kaWZmIDw9IHRvbGVyYW5jZSBhbmQgaGVpZ2h0X2RpZmYgPD0gdG9sZXJhbmNlKQ0KICAgICAgICANCiAgICAgICAgcmV0dXJuIGlzX2Z1bGxzY3JlZW4NCiAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICAjIElmIGFueXRoaW5nIGZhaWxzLCBkZWZhdWx0IHRvIG1vbml0b3IgbW9kZSAoc2FmZSBmYWxsYmFjaykNCiAgICAgICAgcmV0dXJuIFRydWUNCg0KDQpkZWYgZGV0ZWN0X2dhbWUoZ2FtZXM6IERpY3QpIC0+IE9wdGlvbmFsW3N0cl06DQogICAgIiIiDQogICAgQXV0by1kZXRlY3Qgd2hpY2ggZ2FtZSBpcyBjdXJyZW50bHkgcnVubmluZyBieSBjaGVja2luZyBwcm9jZXNzIG5hbWVzLg0KICAgIFJldHVybnMgdGhlIGdhbWUgbmFtZSBpZiBkZXRlY3RlZCwgTm9uZSBvdGhlcndpc2UuDQogICAgIiIiDQogICAgcnVubmluZ19wcm9jcyA9IGdldF9ydW5uaW5nX3Byb2Nlc3NlcygpDQogICAgDQogICAgIyBDaGVjayBlYWNoIGdhbWUncyBwcm9jZXNzIG5hbWVzDQogICAgZm9yIGdhbWVfbmFtZSwgZ2FtZV9jb25maWcgaW4gZ2FtZXMuaXRlbXMoKToNCiAgICAgICAgcHJvY2Vzc19uYW1lcyA9IGdhbWVfY29uZmlnLmdldCgicHJvY2Vzc19uYW1lcyIsIFtdKQ0KICAgICAgICBpZiBub3QgcHJvY2Vzc19uYW1lczoNCiAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIA0KICAgICAgICAjIENoZWNrIGlmIGFueSBvZiB0aGlzIGdhbWUncyBwcm9jZXNzIG5hbWVzIGFyZSBydW5uaW5nDQogICAgICAgIGZvciBwcm9jX25hbWUgaW4gcHJvY2Vzc19uYW1lczoNCiAgICAgICAgICAgICMgTm9ybWFsaXplOiByZW1vdmUgLmV4ZSwgbG93ZXJjYXNlDQogICAgICAgICAgICBub3JtYWxpemVkID0gcHJvY19uYW1lLmxvd2VyKCkNCiAgICAgICAgICAgIGlmIG5vcm1hbGl6ZWQuZW5kc3dpdGgoJy5leGUnKToNCiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZFs6LTRdDQogICAgICAgICAgICANCiAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhpcyBwcm9jZXNzIGlzIHJ1bm5pbmcNCiAgICAgICAgICAgIGlmIG5vcm1hbGl6ZWQgaW4gcnVubmluZ19wcm9jczoNCiAgICAgICAgICAgICAgICBsb2coZiJBdXRvLWRldGVjdGVkIGdhbWU6IHtnYW1lX25hbWV9IChwcm9jZXNzOiB7cHJvY19uYW1lfSkiKQ0KICAgICAgICAgICAgICAgIHJldHVybiBnYW1lX25hbWUNCiAgICANCiAgICByZXR1cm4gTm9uZQ0KDQoNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KIyBJTUFHRSBQUk9DRVNTSU5HDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCmRlZiBncmFiX3JlZ2lvbihzY3Q6IG1zcywgbW9uaXRvcl9pbmRleDogaW50LCByZWdpb246IGRpY3QsIGdhbWVfY29uZmlnOiBEaWN0ID0gTm9uZSwgd2luZG93X3JlY3Q6IE9wdGlvbmFsW2RpY3RdID0gTm9uZSkgLT4gSW1hZ2UuSW1hZ2U6DQogICAgIiIiDQogICAgQ2FwdHVyZSBhIHJlZ2lvbiBmcm9tIHRoZSBzcGVjaWZpZWQgbW9uaXRvciBvciBnYW1lIHdpbmRvdy4NCiAgICBTdXBwb3J0cyBib3RoIGFic29sdXRlIHBpeGVsIGNvb3JkaW5hdGVzIGFuZCBwZXJjZW50YWdlLWJhc2VkIGNvb3JkaW5hdGVzIGZvciBtdWx0aS1yZXNvbHV0aW9uIHN1cHBvcnQuDQogICAgQXV0b21hdGljYWxseSBkZXRlY3RzIGlmIHdpbmRvdyBpcyBmdWxsc2NyZWVuL2JvcmRlcmxlc3MgKHVzZXMgbW9uaXRvci1yZWxhdGl2ZSkgb3Igd2luZG93ZWQgKHVzZXMgd2luZG93LXJlbGF0aXZlKS4NCiAgICANCiAgICBBcmdzOg0KICAgICAgICBzY3Q6IE1TUyBzY3JlZW5zaG90IGNvbnRleHQNCiAgICAgICAgbW9uaXRvcl9pbmRleDogTW9uaXRvciBpbmRleCB0byB1c2UgKGZhbGxiYWNrIGlmIHdpbmRvdyBkZXRlY3Rpb24gZmFpbHMpDQogICAgICAgIHJlZ2lvbjogUmVnaW9uIGNvbmZpZ3VyYXRpb24gZGljdA0KICAgICAgICBnYW1lX2NvbmZpZzogT3B0aW9uYWwgZ2FtZSBjb25maWd1cmF0aW9uIGRpY3QNCiAgICAgICAgd2luZG93X3JlY3Q6IE9wdGlvbmFsIHdpbmRvdyByZWN0YW5nbGUgZGljdCAoaWYgTm9uZSwgdXNlcyBtb25pdG9yLWJhc2VkIGNhcHR1cmUpDQogICAgDQogICAgTm90ZTogTW9uaXRvciBhdXRvLWRldGVjdGlvbiBpcyBub3cgaGFuZGxlZCBpbiB0aGUgbWFpbiBsb29wIHdpdGggdGhyb3R0bGluZw0KICAgIHRvIHByZXZlbnQgcmFjZSBjb25kaXRpb25zLiBUaGlzIGZ1bmN0aW9uIGp1c3QgdXNlcyB0aGUgcHJvdmlkZWQgbW9uaXRvcl9pbmRleC4NCiAgICAiIiINCiAgICANCiAgICAjIG1zcyB1c2VzIDAtaW5kZXhlZCBtb25pdG9ycyAoMCBpcyBhbGwgbW9uaXRvcnMsIDErIGFyZSBpbmRpdmlkdWFsKQ0KICAgICMgVmFsaWRhdGUgbW9uaXRvciBpbmRleCBiZWZvcmUgdXNpbmcgaXQNCiAgICBudW1fbW9uaXRvcnMgPSBsZW4oc2N0Lm1vbml0b3JzKQ0KICAgIG1heF92YWxpZF9pbmRleCA9IG51bV9tb25pdG9ycyAtIDENCiAgICANCiAgICBpZiBtb25pdG9yX2luZGV4IDwgMCBvciBtb25pdG9yX2luZGV4ID4gbWF4X3ZhbGlkX2luZGV4Og0KICAgICAgICAjIEludmFsaWQgbW9uaXRvciBpbmRleCAtIHVzZSBtb25pdG9yIDEgKHByaW1hcnkpIGFzIGZhbGxiYWNrDQogICAgICAgIGxvZyhmIldBUk5JTkc6IE1vbml0b3Ige21vbml0b3JfaW5kZXh9IGlzIGludmFsaWQgKHZhbGlkIHJhbmdlOiAwLXttYXhfdmFsaWRfaW5kZXh9KS4gVXNpbmcgbW9uaXRvciAxLiIpDQogICAgICAgIGFjdHVhbF9pbmRleCA9IDENCiAgICBlbHNlOg0KICAgICAgICBhY3R1YWxfaW5kZXggPSBtb25pdG9yX2luZGV4DQogICAgDQogICAgbW9uID0gc2N0Lm1vbml0b3JzW2FjdHVhbF9pbmRleF0NCiAgICBtb25fd2lkdGggPSBtb25bIndpZHRoIl0NCiAgICBtb25faGVpZ2h0ID0gbW9uWyJoZWlnaHQiXQ0KICAgIA0KICAgICMgQXV0by1kZXRlY3QgaWYgd2Ugc2hvdWxkIHVzZSB3aW5kb3ctcmVsYXRpdmUgb3IgbW9uaXRvci1yZWxhdGl2ZSBjYXB0dXJlDQogICAgdXNlX3dpbmRvd2VkX21vZGUgPSBGYWxzZQ0KICAgIGlmIHdpbmRvd19yZWN0Og0KICAgICAgICB0cnk6DQogICAgICAgICAgICAjIENoZWNrIGlmIHdpbmRvdyBpcyBmdWxsc2NyZWVuL2JvcmRlcmxlc3Mgb3Igd2luZG93ZWQNCiAgICAgICAgICAgIGlzX2Z1bGxzY3JlZW4gPSBpc193aW5kb3dfZnVsbHNjcmVlbl9vcl9ib3JkZXJsZXNzKHdpbmRvd19yZWN0LCBtb24pDQogICAgICAgICAgICB1c2Vfd2luZG93ZWRfbW9kZSA9IG5vdCBpc19mdWxsc2NyZWVuDQogICAgICAgICAgICANCiAgICAgICAgICAgIHdpbmRvd193aWR0aCA9IHdpbmRvd19yZWN0LmdldCgnd2lkdGgnLCAwKQ0KICAgICAgICAgICAgd2luZG93X2hlaWdodCA9IHdpbmRvd19yZWN0LmdldCgnaGVpZ2h0JywgMCkNCiAgICAgICAgICAgIG1vbl93aWR0aCA9IG1vbi5nZXQoJ3dpZHRoJywgMCkNCiAgICAgICAgICAgIG1vbl9oZWlnaHQgPSBtb24uZ2V0KCdoZWlnaHQnLCAwKQ0KICAgICAgICAgICAgDQogICAgICAgICAgICAjIE9ubHkgbG9nIHdpbmRvdyBkZXRlY3Rpb24gb24gZmlyc3QgdXNlIG9yIHdoZW4gbW9kZSBjaGFuZ2VzIChyZWR1Y2Ugc3BhbSkNCiAgICAgICAgICAgICMgTG9nZ2luZyBoYXBwZW5zIGluIG1haW4gbG9vcCB3aGVuIHdpbmRvdyBpcyBmaXJzdCBkZXRlY3RlZA0KICAgICAgICAgICAgDQogICAgICAgICAgICBpZiB1c2Vfd2luZG93ZWRfbW9kZToNCiAgICAgICAgICAgICAgICAjIFZhbGlkYXRlIHdpbmRvdyBkaW1lbnNpb25zIGJlZm9yZSB1c2luZyB3aW5kb3dlZCBtb2RlDQogICAgICAgICAgICAgICAgIyBJZiB3aW5kb3cgaXMgdG9vIHNtYWxsIG9yIGludmFsaWQsIGZhbGxiYWNrIHRvIG1vbml0b3IgbW9kZQ0KICAgICAgICAgICAgICAgIGlmIHdpbmRvd193aWR0aCA8IDEwMCBvciB3aW5kb3dfaGVpZ2h0IDwgMTAwOg0KICAgICAgICAgICAgICAgICAgICBsb2coZiJXQVJOSU5HOiBXaW5kb3cgdG9vIHNtYWxsICh7d2luZG93X3dpZHRofXh7d2luZG93X2hlaWdodH0pLCBmYWxsaW5nIGJhY2sgdG8gbW9uaXRvciBtb2RlIikNCiAgICAgICAgICAgICAgICAgICAgdXNlX3dpbmRvd2VkX21vZGUgPSBGYWxzZQ0KICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgICAgICAjIElmIGFueXRoaW5nIGZhaWxzIGluIHdpbmRvd2VkIGRldGVjdGlvbiwgZmFsbGJhY2sgdG8gbW9uaXRvciBtb2RlIChzYWZlKQ0KICAgICAgICAgICAgbG9nKGYiV0FSTklORzogRXJyb3IgaW4gd2luZG93ZWQgbW9kZSBkZXRlY3Rpb246IHtlfSwgZmFsbGluZyBiYWNrIHRvIG1vbml0b3IgbW9kZSIpDQogICAgICAgICAgICBpbXBvcnQgdHJhY2ViYWNrDQogICAgICAgICAgICBsb2codHJhY2ViYWNrLmZvcm1hdF9leGMoKSkNCiAgICAgICAgICAgIHVzZV93aW5kb3dlZF9tb2RlID0gRmFsc2UNCiAgICBlbHNlOg0KICAgICAgICAjIE9ubHkgbG9nIG9uIGZpcnN0IHVzZSAocmVkdWNlIHNwYW0pIC0gd2luZG93IGRldGVjdGlvbiBoYXBwZW5zIGluIG1haW4gbG9vcA0KICAgICAgICBwYXNzDQogICAgDQogICAgIyBDaGVjayBpZiByZWdpb24gdXNlcyBwZXJjZW50YWdlLWJhc2VkIGNvb3JkaW5hdGVzICgwLjAtMS4wKSBvciBhYnNvbHV0ZSBwaXhlbHMNCiAgICB1c2VfcGVyY2VudGFnZXMgPSBGYWxzZQ0KICAgIGlmICJ1c2VfcGVyY2VudGFnZXMiIGluIHJlZ2lvbjoNCiAgICAgICAgdXNlX3BlcmNlbnRhZ2VzID0gYm9vbChyZWdpb25bInVzZV9wZXJjZW50YWdlcyJdKQ0KICAgIGVsc2U6DQogICAgICAgICMgQXV0by1kZXRlY3Q6IGlmIGxlZnQvdG9wL3dpZHRoL2hlaWdodCBhcmUgYWxsIDw9IDEuMCwgYXNzdW1lIHBlcmNlbnRhZ2VzDQogICAgICAgICMgT3RoZXJ3aXNlLCBpZiB0aGV5J3JlIHJlYXNvbmFibGUgcGl4ZWwgdmFsdWVzICg+IDEwKSwgdXNlIGFic29sdXRlDQogICAgICAgIGxlZnRfdmFsID0gcmVnaW9uLmdldCgibGVmdCIsIDApDQogICAgICAgIHRvcF92YWwgPSByZWdpb24uZ2V0KCJ0b3AiLCAwKQ0KICAgICAgICB3aWR0aF92YWwgPSByZWdpb24uZ2V0KCJ3aWR0aCIsIDApDQogICAgICAgIGhlaWdodF92YWwgPSByZWdpb24uZ2V0KCJoZWlnaHQiLCAwKQ0KICAgICAgICANCiAgICAgICAgIyBJZiBhbGwgdmFsdWVzIGFyZSBiZXR3ZWVuIDAgYW5kIDEsIHRoZXkncmUgcGVyY2VudGFnZXMNCiAgICAgICAgIyBCdXQgZXhjbHVkZSAwLjAgdmFsdWVzIGFzIHRoZXkgY291bGQgYmUgdmFsaWQgcGl4ZWwgY29vcmRpbmF0ZXMNCiAgICAgICAgaWYgKDAgPCBsZWZ0X3ZhbCA8PSAxIGFuZCAwIDwgdG9wX3ZhbCA8PSAxIGFuZCANCiAgICAgICAgICAgIDAgPCB3aWR0aF92YWwgPD0gMSBhbmQgMCA8IGhlaWdodF92YWwgPD0gMSk6DQogICAgICAgICAgICB1c2VfcGVyY2VudGFnZXMgPSBUcnVlDQogICAgDQogICAgIyBDYWxjdWxhdGUgcmVnaW9uIGNvb3JkaW5hdGVzDQogICAgaWYgdXNlX3dpbmRvd2VkX21vZGU6DQogICAgICAgICMgV0lORE9XRUQgTU9ERTogQ2FsY3VsYXRlIHJlZ2lvbiByZWxhdGl2ZSB0byB3aW5kb3cgcG9zaXRpb24gYW5kIHNpemUNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgd2luZG93X2xlZnQgPSB3aW5kb3dfcmVjdC5nZXQoJ2xlZnQnLCAwKQ0KICAgICAgICAgICAgd2luZG93X3RvcCA9IHdpbmRvd19yZWN0LmdldCgndG9wJywgMCkNCiAgICAgICAgICAgIHdpbmRvd193aWR0aCA9IHdpbmRvd19yZWN0LmdldCgnd2lkdGgnLCBtb25fd2lkdGgpDQogICAgICAgICAgICB3aW5kb3dfaGVpZ2h0ID0gd2luZG93X3JlY3QuZ2V0KCdoZWlnaHQnLCBtb25faGVpZ2h0KQ0KICAgICAgICAgICAgDQogICAgICAgICAgICBpZiB1c2VfcGVyY2VudGFnZXM6DQogICAgICAgICAgICAgICAgIyBQZXJjZW50YWdlcyByZWxhdGl2ZSB0byB3aW5kb3cgc2l6ZQ0KICAgICAgICAgICAgICAgIHJlZ2lvbl9sZWZ0ID0gaW50KHdpbmRvd19sZWZ0ICsgcmVnaW9uWyJsZWZ0Il0gKiB3aW5kb3dfd2lkdGgpDQogICAgICAgICAgICAgICAgcmVnaW9uX3RvcCA9IGludCh3aW5kb3dfdG9wICsgcmVnaW9uWyJ0b3AiXSAqIHdpbmRvd19oZWlnaHQpDQogICAgICAgICAgICAgICAgcmVnaW9uX3dpZHRoID0gaW50KHJlZ2lvblsid2lkdGgiXSAqIHdpbmRvd193aWR0aCkNCiAgICAgICAgICAgICAgICByZWdpb25faGVpZ2h0ID0gaW50KHJlZ2lvblsiaGVpZ2h0Il0gKiB3aW5kb3dfaGVpZ2h0KQ0KICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAjIEFic29sdXRlIHBpeGVsIGNvb3JkaW5hdGVzIC0gbmVlZCB0byBzY2FsZSBmcm9tIHJlZmVyZW5jZSByZXNvbHV0aW9uDQogICAgICAgICAgICAgICAgIyBEZWZhdWx0IHJlZmVyZW5jZSByZXNvbHV0aW9uIGlzIDE5MjB4MTA4MCAoY29tbW9uIGZ1bGxzY3JlZW4gcmVzb2x1dGlvbikNCiAgICAgICAgICAgICAgICBiYXNlX3dpZHRoID0gcmVnaW9uLmdldCgiYmFzZV9yZXNvbHV0aW9uX3dpZHRoIiwgMTkyMCkNCiAgICAgICAgICAgICAgICBiYXNlX2hlaWdodCA9IHJlZ2lvbi5nZXQoImJhc2VfcmVzb2x1dGlvbl9oZWlnaHQiLCAxMDgwKQ0KICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgICMgU2NhbGUgcmVnaW9uIHByb3BvcnRpb25hbGx5IGZyb20gYmFzZSByZXNvbHV0aW9uIHRvIHdpbmRvdyBzaXplDQogICAgICAgICAgICAgICAgc2NhbGVfeCA9IHdpbmRvd193aWR0aCAvIGJhc2Vfd2lkdGgNCiAgICAgICAgICAgICAgICBzY2FsZV95ID0gd2luZG93X2hlaWdodCAvIGJhc2VfaGVpZ2h0DQogICAgICAgICAgICAgICAgcmVnaW9uX2xlZnQgPSBpbnQod2luZG93X2xlZnQgKyByZWdpb25bImxlZnQiXSAqIHNjYWxlX3gpDQogICAgICAgICAgICAgICAgcmVnaW9uX3RvcCA9IGludCh3aW5kb3dfdG9wICsgcmVnaW9uWyJ0b3AiXSAqIHNjYWxlX3kpDQogICAgICAgICAgICAgICAgcmVnaW9uX3dpZHRoID0gaW50KHJlZ2lvblsid2lkdGgiXSAqIHNjYWxlX3gpDQogICAgICAgICAgICAgICAgcmVnaW9uX2hlaWdodCA9IGludChyZWdpb25bImhlaWdodCJdICogc2NhbGVfeSkNCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAjIE9ubHkgbG9nIHNjYWxpbmcgb24gZmlyc3QgdXNlIG9yIHdoZW4gd2luZG93IHNpemUgY2hhbmdlcyAocmVkdWNlIHNwYW0pDQogICAgICAgICAgICAgICAgIyBEZXRhaWxlZCBsb2dnaW5nIGhhcHBlbnMgaW4gbWFpbiBsb29wIHdoZW4gd2luZG93IGlzIGZpcnN0IGRldGVjdGVkDQogICAgICAgICAgICANCiAgICAgICAgICAgICMgQ2xhbXAgcmVnaW9uIHRvIHdpbmRvdyBib3VuZHMgKHByZXZlbnQgY2FwdHVyaW5nIG91dHNpZGUgd2luZG93KQ0KICAgICAgICAgICAgcmVnaW9uX2xlZnQgPSBtYXgod2luZG93X2xlZnQsIHJlZ2lvbl9sZWZ0KQ0KICAgICAgICAgICAgcmVnaW9uX3RvcCA9IG1heCh3aW5kb3dfdG9wLCByZWdpb25fdG9wKQ0KICAgICAgICAgICAgcmVnaW9uX3JpZ2h0ID0gbWluKHdpbmRvd19sZWZ0ICsgd2luZG93X3dpZHRoLCByZWdpb25fbGVmdCArIHJlZ2lvbl93aWR0aCkNCiAgICAgICAgICAgIHJlZ2lvbl9ib3R0b20gPSBtaW4od2luZG93X3RvcCArIHdpbmRvd19oZWlnaHQsIHJlZ2lvbl90b3AgKyByZWdpb25faGVpZ2h0KQ0KICAgICAgICAgICAgcmVnaW9uX3dpZHRoID0gbWF4KDAsIHJlZ2lvbl9yaWdodCAtIHJlZ2lvbl9sZWZ0KQ0KICAgICAgICAgICAgcmVnaW9uX2hlaWdodCA9IG1heCgwLCByZWdpb25fYm90dG9tIC0gcmVnaW9uX3RvcCkNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBDbGFtcCByZWdpb24gdG8gbW9uaXRvciBib3VuZHMgKHByZXZlbnQgY2FwdHVyaW5nIG91dHNpZGUgdmlzaWJsZSBhcmVhKQ0KICAgICAgICAgICAgcmVnaW9uX2xlZnQgPSBtYXgobW9uWyJsZWZ0Il0sIHJlZ2lvbl9sZWZ0KQ0KICAgICAgICAgICAgcmVnaW9uX3RvcCA9IG1heChtb25bInRvcCJdLCByZWdpb25fdG9wKQ0KICAgICAgICAgICAgcmVnaW9uX3JpZ2h0ID0gbWluKG1vblsibGVmdCJdICsgbW9uX3dpZHRoLCByZWdpb25fbGVmdCArIHJlZ2lvbl93aWR0aCkNCiAgICAgICAgICAgIHJlZ2lvbl9ib3R0b20gPSBtaW4obW9uWyJ0b3AiXSArIG1vbl9oZWlnaHQsIHJlZ2lvbl90b3AgKyByZWdpb25faGVpZ2h0KQ0KICAgICAgICAgICAgcmVnaW9uX3dpZHRoID0gbWF4KDAsIHJlZ2lvbl9yaWdodCAtIHJlZ2lvbl9sZWZ0KQ0KICAgICAgICAgICAgcmVnaW9uX2hlaWdodCA9IG1heCgwLCByZWdpb25fYm90dG9tIC0gcmVnaW9uX3RvcCkNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBJZiByZWdpb24gaXMgaW52YWxpZCBhZnRlciBjbGFtcGluZywgZmFsbGJhY2sgdG8gbW9uaXRvciBtb2RlDQogICAgICAgICAgICBpZiByZWdpb25fd2lkdGggPD0gMCBvciByZWdpb25faGVpZ2h0IDw9IDA6DQogICAgICAgICAgICAgICAgbG9nKGYiV0FSTklORzogV2luZG93ZWQgbW9kZSByZWdpb24gaW52YWxpZCBhZnRlciBjbGFtcGluZyAod2lkdGg9e3JlZ2lvbl93aWR0aH0sIGhlaWdodD17cmVnaW9uX2hlaWdodH0pLCBmYWxsaW5nIGJhY2sgdG8gbW9uaXRvciBtb2RlIikNCiAgICAgICAgICAgICAgICB1c2Vfd2luZG93ZWRfbW9kZSA9IEZhbHNlDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGFic19yZWdpb24gPSB7DQogICAgICAgICAgICAgICAgICAgICJsZWZ0IjogcmVnaW9uX2xlZnQsDQogICAgICAgICAgICAgICAgICAgICJ0b3AiOiByZWdpb25fdG9wLA0KICAgICAgICAgICAgICAgICAgICAid2lkdGgiOiByZWdpb25fd2lkdGgsDQogICAgICAgICAgICAgICAgICAgICJoZWlnaHQiOiByZWdpb25faGVpZ2h0LA0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAjIE9ubHkgbG9nIG9uIGZpcnN0IHVzZSBvciB3aGVuIHBvc2l0aW9uIGNoYW5nZXMgc2lnbmlmaWNhbnRseSAocmVkdWNlIHNwYW0pDQogICAgICAgICAgICAgICAgIyBEZXRhaWxlZCBsb2dnaW5nIGhhcHBlbnMgaW4gbWFpbiBsb29wIHdoZW4gd2luZG93IGlzIGZpcnN0IGRldGVjdGVkDQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgICMgSWYgYW55dGhpbmcgZmFpbHMgaW4gd2luZG93ZWQgY2FsY3VsYXRpb24sIGZhbGxiYWNrIHRvIG1vbml0b3IgbW9kZQ0KICAgICAgICAgICAgbG9nKGYiV0FSTklORzogRXJyb3IgY2FsY3VsYXRpbmcgd2luZG93ZWQgcmVnaW9uOiB7ZX0sIGZhbGxpbmcgYmFjayB0byBtb25pdG9yIG1vZGUiKQ0KICAgICAgICAgICAgdXNlX3dpbmRvd2VkX21vZGUgPSBGYWxzZQ0KICAgIA0KICAgICMgTU9OSVRPUiBNT0RFOiBDYWxjdWxhdGUgcmVnaW9uIHJlbGF0aXZlIHRvIG1vbml0b3IgKG9yaWdpbmFsIGJlaGF2aW9yKQ0KICAgIGlmIG5vdCB1c2Vfd2luZG93ZWRfbW9kZToNCiAgICAgICAgIyBPbmx5IGxvZyBvbiBmaXJzdCB1c2UgKHJlZHVjZSBzcGFtKSAtIGxvZ2dpbmcgaGFwcGVucyBpbiBtYWluIGxvb3ANCiAgICAgICAgaWYgdXNlX3BlcmNlbnRhZ2VzOg0KICAgICAgICAgICAgIyBDb252ZXJ0IHBlcmNlbnRhZ2UtYmFzZWQgY29vcmRpbmF0ZXMgdG8gYWJzb2x1dGUgcGl4ZWxzDQogICAgICAgICAgICAjIFBlcmNlbnRhZ2VzIGFyZSByZWxhdGl2ZSB0byBtb25pdG9yIHJlc29sdXRpb24gLSB3b3JrcyBvbiBBTlkgcmVzb2x1dGlvbiBpbmNsdWRpbmcgdWx0cmF3aWRlIQ0KICAgICAgICAgICAgYWJzX3JlZ2lvbiA9IHsNCiAgICAgICAgICAgICAgICAibGVmdCI6IGludChtb25bImxlZnQiXSArIHJlZ2lvblsibGVmdCJdICogbW9uX3dpZHRoKSwNCiAgICAgICAgICAgICAgICAidG9wIjogaW50KG1vblsidG9wIl0gKyByZWdpb25bInRvcCJdICogbW9uX2hlaWdodCksDQogICAgICAgICAgICAgICAgIndpZHRoIjogaW50KHJlZ2lvblsid2lkdGgiXSAqIG1vbl93aWR0aCksDQogICAgICAgICAgICAgICAgImhlaWdodCI6IGludChyZWdpb25bImhlaWdodCJdICogbW9uX2hlaWdodCksDQogICAgICAgICAgICB9DQogICAgICAgICAgICAjIE9ubHkgbG9nIG9uIGZpcnN0IHVzZSBvciB3aGVuIG1vbml0b3IgcmVzb2x1dGlvbiBjaGFuZ2VzICh0byBhdm9pZCBzcGFtKQ0KICAgICAgICAgICAgIyBUaGlzIHdpbGwgYmUgbG9nZ2VkIGVsc2V3aGVyZSBpZiBuZWVkZWQgZm9yIGRlYnVnZ2luZw0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgIyBVc2UgYWJzb2x1dGUgcGl4ZWwgY29vcmRpbmF0ZXMgKGxlZ2FjeSBtb2RlKQ0KICAgICAgICAgICAgIyBTY2FsZSBiYXNlZCBvbiBhIHJlZmVyZW5jZSByZXNvbHV0aW9uICgxOTIweDEwODApIGlmIGJhc2VfcmVzb2x1dGlvbiBpcyBwcm92aWRlZA0KICAgICAgICAgICAgYmFzZV93aWR0aCA9IHJlZ2lvbi5nZXQoImJhc2VfcmVzb2x1dGlvbl93aWR0aCIsIE5vbmUpDQogICAgICAgICAgICBiYXNlX2hlaWdodCA9IHJlZ2lvbi5nZXQoImJhc2VfcmVzb2x1dGlvbl9oZWlnaHQiLCBOb25lKQ0KICAgICAgICAgICAgDQogICAgICAgICAgICBpZiBiYXNlX3dpZHRoIGFuZCBiYXNlX2hlaWdodDoNCiAgICAgICAgICAgICAgICAjIFNjYWxlIHJlZ2lvbiBwcm9wb3J0aW9uYWxseSBmcm9tIGJhc2UgcmVzb2x1dGlvbiB0byBhY3R1YWwgbW9uaXRvciByZXNvbHV0aW9uDQogICAgICAgICAgICAgICAgc2NhbGVfeCA9IG1vbl93aWR0aCAvIGJhc2Vfd2lkdGgNCiAgICAgICAgICAgICAgICBzY2FsZV95ID0gbW9uX2hlaWdodCAvIGJhc2VfaGVpZ2h0DQogICAgICAgICAgICAgICAgYWJzX3JlZ2lvbiA9IHsNCiAgICAgICAgICAgICAgICAgICAgImxlZnQiOiBpbnQobW9uWyJsZWZ0Il0gKyByZWdpb25bImxlZnQiXSAqIHNjYWxlX3gpLA0KICAgICAgICAgICAgICAgICAgICAidG9wIjogaW50KG1vblsidG9wIl0gKyByZWdpb25bInRvcCJdICogc2NhbGVfeSksDQogICAgICAgICAgICAgICAgICAgICJ3aWR0aCI6IGludChyZWdpb25bIndpZHRoIl0gKiBzY2FsZV94KSwNCiAgICAgICAgICAgICAgICAgICAgImhlaWdodCI6IGludChyZWdpb25bImhlaWdodCJdICogc2NhbGVfeSksDQogICAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICAgIGxvZyhmIlNjYWxlZCByZWdpb24gZnJvbSB7YmFzZV93aWR0aH14e2Jhc2VfaGVpZ2h0fSB0byB7bW9uX3dpZHRofXh7bW9uX2hlaWdodH06IHtyZWdpb259IC0+IHthYnNfcmVnaW9ufSIpDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICMgTm8gc2NhbGluZyAtIHVzZSBhYnNvbHV0ZSBjb29yZGluYXRlcyBhcy1pcyAobGVnYWN5IGJlaGF2aW9yKQ0KICAgICAgICAgICAgICAgIGFic19yZWdpb24gPSB7DQogICAgICAgICAgICAgICAgICAgICJsZWZ0IjogbW9uWyJsZWZ0Il0gKyByZWdpb25bImxlZnQiXSwNCiAgICAgICAgICAgICAgICAgICAgInRvcCI6IG1vblsidG9wIl0gKyByZWdpb25bInRvcCJdLA0KICAgICAgICAgICAgICAgICAgICAid2lkdGgiOiByZWdpb25bIndpZHRoIl0sDQogICAgICAgICAgICAgICAgICAgICJoZWlnaHQiOiByZWdpb25bImhlaWdodCJdLA0KICAgICAgICAgICAgICAgIH0NCiAgICANCiAgICAjIENhcHR1cmUgYXQgZnVsbCBxdWFsaXR5IChtc3MgY2FwdHVyZXMgYXQgbmF0aXZlIHJlc29sdXRpb24pDQogICAgZ3JhYiA9IHNjdC5ncmFiKGFic19yZWdpb24pDQogICAgaW1nID0gSW1hZ2UuZnJvbWJ5dGVzKCJSR0IiLCBncmFiLnNpemUsIGdyYWIucmdiKQ0KICAgIA0KICAgICMgSWYgdGhlIGNhcHR1cmVkIHJlZ2lvbiBpcyB2ZXJ5IHNtYWxsLCB1cHNjYWxlIGl0IGltbWVkaWF0ZWx5IHRvIGltcHJvdmUgcXVhbGl0eQ0KICAgICMgVGhpcyBoZWxwcyB3aXRoIHBpeGVsYXRlZCB0ZXh0IGZyb20gc21hbGwgY2FwdHVyZSByZWdpb25zDQogICAgaWYgaW1nLnNpemVbMF0gPCAyMDAgb3IgaW1nLnNpemVbMV0gPCAxMDA6DQogICAgICAgICMgU21hbGwgcmVnaW9uIC0gdXBzY2FsZSB1c2luZyBoaWdoLXF1YWxpdHkgcmVzYW1wbGluZw0KICAgICAgICBuZXdfd2lkdGggPSBpbWcuc2l6ZVswXSAqIDINCiAgICAgICAgbmV3X2hlaWdodCA9IGltZy5zaXplWzFdICogMg0KICAgICAgICBpbWcgPSBpbWcucmVzaXplKChuZXdfd2lkdGgsIG5ld19oZWlnaHQpLCBJbWFnZS5SZXNhbXBsaW5nLkxBTkNaT1MpDQogICAgDQogICAgcmV0dXJuIGltZw0KDQoNCmRlZiBwcmVwcm9jZXNzX2Zvcl9vY3IoaW1nX3JnYjogSW1hZ2UuSW1hZ2UpIC0+IFR1cGxlW0ltYWdlLkltYWdlLCBEaWN0XToNCiAgICAiIiINCiAgICBQcmVwcm9jZXNzIGltYWdlIGZvciBPQ1Igd2l0aCBtdWx0aXBsZSBmYWxsYmFjayBzdHJhdGVnaWVzLg0KICAgIEltcHJvdmVkIHVwc2NhbGluZyBhbmQgc2hhcnBlbmluZyBmb3IgYmV0dGVyIE9DUiBhY2N1cmFjeSBhbmQgcmVkdWNlZCBwaXhlbGF0aW9uLg0KICAgICIiIg0KICAgICMgQ29udmVydCBQSUwgdG8gbnVtcHkgYXJyYXkNCiAgICByZ2IgPSBucC5hcnJheShpbWdfcmdiKQ0KICAgIA0KICAgICMgSWYgaW1hZ2UgaXMgdmVyeSBzbWFsbCwgdXBzY2FsZSBpdCBmaXJzdCBiZWZvcmUgcHJvY2Vzc2luZw0KICAgIGlmIHJnYi5zaGFwZVswXSA8IDE1MCBvciByZ2Iuc2hhcGVbMV0gPCAzMDA6DQogICAgICAgICMgVmVyeSBzbWFsbCBpbWFnZSAtIHVwc2NhbGUgdXNpbmcgaGlnaC1xdWFsaXR5IG1ldGhvZA0KICAgICAgICBzY2FsZV9mYWN0b3IgPSBtYXgoMzAwIC8gcmdiLnNoYXBlWzFdLCAxNTAgLyByZ2Iuc2hhcGVbMF0pDQogICAgICAgIG5ld193aWR0aCA9IGludChyZ2Iuc2hhcGVbMV0gKiBzY2FsZV9mYWN0b3IpDQogICAgICAgIG5ld19oZWlnaHQgPSBpbnQocmdiLnNoYXBlWzBdICogc2NhbGVfZmFjdG9yKQ0KICAgICAgICAjIFVzZSBQSUwncyBMQU5DWk9TIGZvciBiZXR0ZXIgcXVhbGl0eSB1cHNjYWxpbmcNCiAgICAgICAgaW1nX3JnYiA9IGltZ19yZ2IucmVzaXplKChuZXdfd2lkdGgsIG5ld19oZWlnaHQpLCBJbWFnZS5SZXNhbXBsaW5nLkxBTkNaT1MpDQogICAgICAgIHJnYiA9IG5wLmFycmF5KGltZ19yZ2IpDQogICAgDQogICAgYmdyID0gY3YyLmN2dENvbG9yKHJnYiwgY3YyLkNPTE9SX1JHQjJCR1IpDQogICAgDQogICAgZGVmIHVwc2NhbGUoaW1nX2N2KToNCiAgICAgICAgIiIiVXBzY2FsZSBpbWFnZSAzeCBmb3IgYmV0dGVyIE9DUiBxdWFsaXR5IGFuZCByZWR1Y2VkIHBpeGVsYXRpb24uIiIiDQogICAgICAgICMgVXNlIExBTkNaT1MgaW50ZXJwb2xhdGlvbiBmb3IgYmV0dGVyIHF1YWxpdHkgKHNsb3dlciBidXQgbXVjaCBiZXR0ZXIgZm9yIHRleHQpDQogICAgICAgICMgM3ggdXBzY2FsZSBnaXZlcyBiZXR0ZXIgcmVzdWx0cyB0aGFuIDJ4IGZvciBwaXhlbGF0ZWQgdGV4dA0KICAgICAgICByZXR1cm4gY3YyLnJlc2l6ZShpbWdfY3YsIE5vbmUsIGZ4PTMuMCwgZnk9My4wLCBpbnRlcnBvbGF0aW9uPWN2Mi5JTlRFUl9MQU5DWk9TNCkNCiAgICANCiAgICAjIFN0cmF0ZWd5IDE6IFRyeSBIU1YgcmVkIG1hc2sgKGZvciAiWU9VIERJRUQiIHJlZCB0ZXh0KQ0KICAgIGhzdiA9IGN2Mi5jdnRDb2xvcihiZ3IsIGN2Mi5DT0xPUl9CR1IySFNWKQ0KICAgIA0KICAgICMgV2lkZSByZWQgdGhyZXNob2xkcyAoYm90aCBsb3cgYW5kIGhpZ2ggaHVlIHJhbmdlcykNCiAgICBsb3dlcjEgPSBucC5hcnJheShbMCwgMzAsIDMwXSwgZHR5cGU9bnAudWludDgpDQogICAgdXBwZXIxID0gbnAuYXJyYXkoWzE1LCAyNTUsIDI1NV0sIGR0eXBlPW5wLnVpbnQ4KQ0KICAgIGxvd2VyMiA9IG5wLmFycmF5KFsxNjUsIDMwLCAzMF0sIGR0eXBlPW5wLnVpbnQ4KQ0KICAgIHVwcGVyMiA9IG5wLmFycmF5KFsxODAsIDI1NSwgMjU1XSwgZHR5cGU9bnAudWludDgpDQogICAgDQogICAgbWFzazEgPSBjdjIuaW5SYW5nZShoc3YsIGxvd2VyMSwgdXBwZXIxKQ0KICAgIG1hc2syID0gY3YyLmluUmFuZ2UoaHN2LCBsb3dlcjIsIHVwcGVyMikNCiAgICByZWRfbWFzayA9IGN2Mi5iaXR3aXNlX29yKG1hc2sxLCBtYXNrMikNCiAgICANCiAgICAjIFN0cmF0ZWd5IDFiOiBBbHNvIGRldGVjdCB3aGl0ZS9icmlnaHQgdGV4dCAoZm9yIFNla2lybyB3aGl0ZSBkZWF0aCBtZXNzYWdlKQ0KICAgICMgV2hpdGUvYnJpZ2h0IGNvbG9ycyBoYXZlIGhpZ2ggdmFsdWUgKGJyaWdodG5lc3MpIGFuZCBsb3cgc2F0dXJhdGlvbg0KICAgIHdoaXRlX2xvd2VyID0gbnAuYXJyYXkoWzAsIDAsIDIwMF0sIGR0eXBlPW5wLnVpbnQ4KSAgIyBMb3cgc2F0dXJhdGlvbiwgaGlnaCBicmlnaHRuZXNzDQogICAgd2hpdGVfdXBwZXIgPSBucC5hcnJheShbMTgwLCAzMCwgMjU1XSwgZHR5cGU9bnAudWludDgpDQogICAgd2hpdGVfbWFzayA9IGN2Mi5pblJhbmdlKGhzdiwgd2hpdGVfbG93ZXIsIHdoaXRlX3VwcGVyKQ0KICAgIA0KICAgICMgQ29tYmluZSByZWQgYW5kIHdoaXRlIG1hc2tzDQogICAgbWFzayA9IGN2Mi5iaXR3aXNlX29yKHJlZF9tYXNrLCB3aGl0ZV9tYXNrKQ0KICAgIA0KICAgICMgQ2xlYW4gbm9pc2Ugd2l0aCBiZXR0ZXIgbW9ycGhvbG9neSBvcGVyYXRpb25zDQogICAgIyBVc2Ugc21hbGxlciBrZXJuZWwgZm9yIGxlc3MgYWdncmVzc2l2ZSBjbGVhbmluZyAocHJlc2VydmVzIHRleHQgYmV0dGVyKQ0KICAgIGtlcm5lbCA9IG5wLm9uZXMoKDIsIDIpLCBucC51aW50OCkNCiAgICBtYXNrID0gY3YyLm1vcnBob2xvZ3lFeChtYXNrLCBjdjIuTU9SUEhfT1BFTiwga2VybmVsLCBpdGVyYXRpb25zPTEpDQogICAgbWFzayA9IGN2Mi5tb3JwaG9sb2d5RXgobWFzaywgY3YyLk1PUlBIX0NMT1NFLCBrZXJuZWwsIGl0ZXJhdGlvbnM9MSkNCiAgICAjIEdlbnRsZSBkaWxhdGlvbiB0byBjb25uZWN0IHRleHQgY2hhcmFjdGVycw0KICAgIG1hc2sgPSBjdjIuZGlsYXRlKG1hc2ssIGtlcm5lbCwgaXRlcmF0aW9ucz0xKQ0KICAgIA0KICAgIHdoaXRlID0gaW50KGN2Mi5jb3VudE5vblplcm8obWFzaykpDQogICAgdG90YWwgPSBpbnQobWFzay5zaGFwZVswXSAqIG1hc2suc2hhcGVbMV0pDQogICAgY292ZXJhZ2UgPSB3aGl0ZSAvIG1heCgxLCB0b3RhbCkNCiAgICANCiAgICBpbmZvID0geyJtb2RlIjogIkhTVl9SRURfV0hJVEUiLCAiY292ZXJhZ2UiOiBjb3ZlcmFnZX0NCiAgICANCiAgICAjIFVzZSByZWQvd2hpdGUgbWFzayBpZiBjb3ZlcmFnZSBpcyByZWFzb25hYmxlIChhdCBsZWFzdCAwLjMlIG9mIGltYWdlIC0gbG93ZXJlZCB0aHJlc2hvbGQpDQogICAgaWYgY292ZXJhZ2UgPj0gMC4wMDM6DQogICAgICAgICMgSW52ZXJ0IG1hc2s6IHdoaXRlIHRleHQgb24gYmxhY2sgYmFja2dyb3VuZCAtPiBibGFjayB0ZXh0IG9uIHdoaXRlDQogICAgICAgIGludiA9IGN2Mi5iaXR3aXNlX25vdChtYXNrKQ0KICAgICAgICAjIEFwcGx5IHNsaWdodCBzaGFycGVuaW5nIHRvIGltcHJvdmUgdGV4dCBjbGFyaXR5DQogICAgICAgIGtlcm5lbF9zaGFycGVuID0gbnAuYXJyYXkoW1stMSwgLTEsIC0xXSwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWy0xLCAgOSwgLTFdLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbLTEsIC0xLCAtMV1dKQ0KICAgICAgICBpbnYgPSBjdjIuZmlsdGVyMkQoaW52LCAtMSwga2VybmVsX3NoYXJwZW4pDQogICAgICAgIG91dCA9IHVwc2NhbGUoaW52KQ0KICAgICAgICByZXR1cm4gSW1hZ2UuZnJvbWFycmF5KG91dCksIGluZm8NCiAgICANCiAgICAjIFN0cmF0ZWd5IDI6IEdyYXlzY2FsZSB3aXRoIGFkYXB0aXZlIHRocmVzaG9sZCAod29ya3MgZm9yIGFueSB0ZXh0IGNvbG9yKQ0KICAgICMgVGhpcyBmYWxsYmFjayBlbnN1cmVzIHdlIE5FVkVSIGdldCBhIGJsYWNrIGltYWdlIC0gYWRhcHRpdmUgdGhyZXNob2xkIGFsd2F5cyBwcm9kdWNlcyBvdXRwdXQNCiAgICBncmF5ID0gY3YyLmN2dENvbG9yKGJnciwgY3YyLkNPTE9SX0JHUjJHUkFZKQ0KICAgICMgVXNlIGxlc3MgYmx1ciB0byBwcmVzZXJ2ZSB0ZXh0IGRldGFpbHMNCiAgICBncmF5X2JsdXIgPSBjdjIuR2F1c3NpYW5CbHVyKGdyYXksICgzLCAzKSwgMCkNCiAgICAjIEFwcGx5IHVuc2hhcnAgbWFzayBmb3IgYmV0dGVyIHRleHQgY2xhcml0eQ0KICAgIGdhdXNzaWFuID0gY3YyLkdhdXNzaWFuQmx1cihncmF5X2JsdXIsICgwLCAwKSwgMi4wKQ0KICAgIHVuc2hhcnAgPSBjdjIuYWRkV2VpZ2h0ZWQoZ3JheV9ibHVyLCAxLjUsIGdhdXNzaWFuLCAtMC41LCAwKQ0KICAgIA0KICAgIHRocl9hZGFwdCA9IGN2Mi5hZGFwdGl2ZVRocmVzaG9sZCgNCiAgICAgICAgdW5zaGFycCwgMjU1LA0KICAgICAgICBjdjIuQURBUFRJVkVfVEhSRVNIX0dBVVNTSUFOX0MsDQogICAgICAgIGN2Mi5USFJFU0hfQklOQVJZLA0KICAgICAgICAzMSwgNQ0KICAgICkNCiAgICAjIEludmVydDogbWFrZSB0ZXh0IGRhcmsgb24gbGlnaHQgYmFja2dyb3VuZCAoVGVzc2VyYWN0IHByZWZlcnMgZGFyayB0ZXh0IG9uIGxpZ2h0KQ0KICAgIHRocl9hZGFwdF9pbnYgPSBjdjIuYml0d2lzZV9ub3QodGhyX2FkYXB0KQ0KICAgICMgQXBwbHkgc2xpZ2h0IHNoYXJwZW5pbmcgdG8gaW1wcm92ZSB0ZXh0IGNsYXJpdHkNCiAgICBrZXJuZWxfc2hhcnBlbiA9IG5wLmFycmF5KFtbLTEsIC0xLCAtMV0sDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWy0xLCAgOSwgLTFdLA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFstMSwgLTEsIC0xXV0pDQogICAgdGhyX2FkYXB0X2ludiA9IGN2Mi5maWx0ZXIyRCh0aHJfYWRhcHRfaW52LCAtMSwga2VybmVsX3NoYXJwZW4pDQogICAgb3V0ID0gdXBzY2FsZSh0aHJfYWRhcHRfaW52KQ0KICAgIGluZm9bIm1vZGUiXSA9ICJBREFQVElWRV9USFJFU0hPTEQiDQogICAgaW5mb1siY292ZXJhZ2UiXSA9IDAuMCAgIyBTZXQgY292ZXJhZ2UgZm9yIGNvbnNpc3RlbmN5DQogICAgcmV0dXJuIEltYWdlLmZyb21hcnJheShvdXQpLCBpbmZvDQoNCg0KZGVmIG9jcl90ZXh0KGltZ19mb3Jfb2NyOiBJbWFnZS5JbWFnZSwgdGVzc2VyYWN0X2NvbmZpZzogc3RyLCB0ZXNzZXJhY3RfbGFuZzogc3RyID0gImVuZyIpIC0+IHN0cjoNCiAgICAiIiJFeHRyYWN0IHRleHQgZnJvbSBpbWFnZSB1c2luZyBPQ1IuIFN1cHBvcnRzIG11bHRpcGxlIGxhbmd1YWdlcyBpbmNsdWRpbmcgSmFwYW5lc2UuIiIiDQogICAgdHJ5Og0KICAgICAgICB0ZXh0ID0gcHl0ZXNzZXJhY3QuaW1hZ2VfdG9fc3RyaW5nKGltZ19mb3Jfb2NyLCBsYW5nPXRlc3NlcmFjdF9sYW5nLCBjb25maWc9dGVzc2VyYWN0X2NvbmZpZykNCiAgICAgICAgIyBGb3IgRW5nbGlzaC1vbmx5LCByZW1vdmUgbm9uLWFscGhhYmV0aWMgYW5kIHVwcGVyY2FzZQ0KICAgICAgICAjIEZvciBKYXBhbmVzZS9tdWx0aS1sYW5ndWFnZSwga2VlcCBhbGwgY2hhcmFjdGVycyAoaW5jbHVkaW5nIEphcGFuZXNlKSBidXQgcmVtb3ZlIHNwYWNlcw0KICAgICAgICBpZiB0ZXNzZXJhY3RfbGFuZyA9PSAiZW5nIiBvciAodGVzc2VyYWN0X2xhbmcuc3RhcnRzd2l0aCgiZW5nIikgYW5kICIrIiBub3QgaW4gdGVzc2VyYWN0X2xhbmcpOg0KICAgICAgICAgICAgY2xlYW4gPSAiIi5qb2luKGMgZm9yIGMgaW4gdGV4dC51cHBlcigpIGlmIGMuaXNhbHBoYSgpKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgIyBGb3IgSmFwYW5lc2UvbXVsdGktbGFuZ3VhZ2U6IGtlZXAgYWxsIGNoYXJhY3RlcnMgaW5jbHVkaW5nIEphcGFuZXNlLCBDaGluZXNlLCBldGMuDQogICAgICAgICAgICAjIFJlbW92ZSBzcGFjZXMgYW5kIG5ld2xpbmVzLCBidXQga2VlcCBhbGwgb3RoZXIgY2hhcmFjdGVycw0KICAgICAgICAgICAgY2xlYW4gPSAiIi5qb2luKGMgZm9yIGMgaW4gdGV4dCBpZiBub3QgYy5pc3NwYWNlKCkpDQogICAgICAgIHJldHVybiBjbGVhbg0KICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgbG9nKGYiT0NSIGVycm9yOiB7ZX0iKQ0KICAgICAgICByZXR1cm4gIiINCg0KDQpkZWYgY29udGFpbnNfa2V5d29yZChjbGVhbl90ZXh0OiBzdHIsIGtleXdvcmRzOiBMaXN0W3N0cl0pIC0+IGJvb2w6DQogICAgIiIiQ2hlY2sgaWYgY2xlYW5lZCB0ZXh0IGNvbnRhaW5zIGFueSBrZXl3b3JkLiIiIg0KICAgICMgRXhjbHVkZSBmYWxzZSBwb3NpdGl2ZXM6IGVuZW15IGZlbGxlZCwgdGFyZ2V0IGRlc3Ryb3llZCwgZXRjLg0KICAgIGV4Y2x1ZGVfa2V5d29yZHMgPSBbIkVORU1ZRkVMTEVEIiwgIkVORU1ZRkVMTEUiLCAiVEFSR0VUREVTVFJPWUVEIiwgIlRBUkdFVERFU1RST1lFIl0NCiAgICBmb3IgZXhjbHVkZSBpbiBleGNsdWRlX2tleXdvcmRzOg0KICAgICAgICBpZiBleGNsdWRlIGluIGNsZWFuX3RleHQ6DQogICAgICAgICAgICByZXR1cm4gRmFsc2UNCiAgICANCiAgICByZXR1cm4gYW55KGsgaW4gY2xlYW5fdGV4dCBmb3IgayBpbiBrZXl3b3JkcykNCg0KDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCiMgTUFJTiBMT09QDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCmRlZiBtYWluX2xvb3AoKToNCiAgICBvcy5tYWtlZGlycyhCQVNFX0RJUiwgZXhpc3Rfb2s9VHJ1ZSkNCiAgICBlbmFibGVfZHBpX2F3YXJlbmVzcygpDQogICAgbW92ZV9jb25zb2xlX3RvX3RvcF9yaWdodCgpICAjIE1vdmUgY29uc29sZSB3aW5kb3cgb3V0IG9mIGNhcHR1cmUgYXJlYQ0KICAgIA0KICAgICMgQ2hlY2sgaWYgVGVzc2VyYWN0IGlzIGF2YWlsYWJsZSAoZWl0aGVyIGFzIGZpbGUgcGF0aCBvciBjb21tYW5kKQ0KICAgIHRlc3NlcmFjdF9hdmFpbGFibGUgPSBGYWxzZQ0KICAgIGlmIFRFU1NFUkFDVF9FWEUgPT0gJ3Rlc3NlcmFjdCc6DQogICAgICAgICMgQ2hlY2sgaWYgY29tbWFuZCBpcyBhdmFpbGFibGUNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5ydW4oWyd0ZXNzZXJhY3QnLCAnLS12ZXJzaW9uJ10sIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVfb3V0cHV0PVRydWUsIHRleHQ9VHJ1ZSwgdGltZW91dD0yKQ0KICAgICAgICAgICAgdGVzc2VyYWN0X2F2YWlsYWJsZSA9IChyZXN1bHQucmV0dXJuY29kZSA9PSAwKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICB0ZXNzZXJhY3RfYXZhaWxhYmxlID0gRmFsc2UNCiAgICBlbHNlOg0KICAgICAgICB0ZXNzZXJhY3RfYXZhaWxhYmxlID0gb3MucGF0aC5leGlzdHMoVEVTU0VSQUNUX0VYRSkNCiAgICANCiAgICBpZiBub3QgdGVzc2VyYWN0X2F2YWlsYWJsZToNCiAgICAgICAgbG9nKGYiRVJST1I6IFRlc3NlcmFjdCBub3QgZm91bmQgYXQ6IHtURVNTRVJBQ1RfRVhFfSIpDQogICAgICAgIGxvZygiUGxlYXNlIGluc3RhbGwgVGVzc2VyYWN0IE9DUiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vVUItTWFubmhlaW0vdGVzc2VyYWN0L3dpa2kiKQ0KICAgICAgICBsb2coIk9yIGVuc3VyZSBUZXNzZXJhY3QgaXMgaW4geW91ciBQQVRILiIpDQogICAgICAgIGxvZygiRGFlbW9uIHdpbGwgZXhpdCAtIFRlc3NlcmFjdCBpcyByZXF1aXJlZC4iKQ0KICAgICAgICAjIERvbid0IGNyZWF0ZSByZWFkeSBmaWxlIC0gZGFlbW9uIGlzIG5vdCByZWFkeQ0KICAgICAgICByZXR1cm4NCiAgICANCiAgICBjb25maWcgPSBsb2FkX2NvbmZpZygpDQogICAgc2V0dGluZ3MgPSBjb25maWdbInNldHRpbmdzIl0NCiAgICBnYW1lcyA9IGNvbmZpZ1siZ2FtZXMiXQ0KICAgIA0KICAgIGlmIG5vdCBnYW1lczoNCiAgICAgICAgbG9nKCJFUlJPUjogTm8gZ2FtZXMgY29uZmlndXJlZCEiKQ0KICAgICAgICBsb2coIkRhZW1vbiB3aWxsIGV4aXQgLSBnYW1lcyBjb25maWd1cmF0aW9uIGlzIHJlcXVpcmVkLiIpDQogICAgICAgICMgRG9uJ3QgY3JlYXRlIHJlYWR5IGZpbGUgLSBkYWVtb24gaXMgbm90IHJlYWR5DQogICAgICAgIHJldHVybg0KICAgIA0KICAgICMgQ3JlYXRlIHJlYWR5IGZpbGUgRUFSTFkgLSByaWdodCBhZnRlciBjcml0aWNhbCBjaGVja3MgcGFzcw0KICAgICMgVGhpcyBlbnN1cmVzIEdVSSBrbm93cyBkYWVtb24gaXMgcmVhZHkgZXZlbiBpZiBzb21ldGhpbmcgbGF0ZXIgaGFuZ3MNCiAgICAjIERPIFRISVMgQkVGT1JFIEFOWSBMT0dHSU5HIHRvIGF2b2lkIGVuY29kaW5nIGlzc3Vlcw0KICAgIHJlYWR5X2ZpbGVfY3JlYXRlZCA9IEZhbHNlDQogICAgdHJ5Og0KICAgICAgICAjIEVuc3VyZSBkaXJlY3RvcnkgZXhpc3RzDQogICAgICAgIG9zLm1ha2VkaXJzKEJBU0VfRElSLCBleGlzdF9vaz1UcnVlKQ0KICAgICAgICAjIENyZWF0ZSByZWFkeSBmaWxlDQogICAgICAgIHJlYWR5X2ZpbGVfcGF0aCA9IG9zLnBhdGguYWJzcGF0aChSRUFEWV9GSUxFKSAgIyBVc2UgYWJzb2x1dGUgcGF0aA0KICAgICAgICB3aXRoIG9wZW4ocmVhZHlfZmlsZV9wYXRoLCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBmLndyaXRlKHN0cihvcy5nZXRwaWQoKSkpDQogICAgICAgICAgICBmLmZsdXNoKCkgICMgRm9yY2Ugd3JpdGUgdG8gZGlzaw0KICAgICAgICAjIEZvcmNlIE9TIHRvIHN5bmMgZmlsZSB0byBkaXNrDQogICAgICAgIGltcG9ydCBzeXMNCiAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpDQogICAgICAgIHN5cy5zdGRlcnIuZmx1c2goKQ0KICAgICAgICAjIFZlcmlmeSBpdCB3YXMgY3JlYXRlZA0KICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhyZWFkeV9maWxlX3BhdGgpOg0KICAgICAgICAgICAgcmVhZHlfZmlsZV9jcmVhdGVkID0gVHJ1ZQ0KICAgICAgICAgICAgIyBOb3cgc2FmZSB0byBsb2cgKGZpbGUgaXMgYWxyZWFkeSBjcmVhdGVkKQ0KICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgIGxvZygiUmVhZHkgZmlsZSBjcmVhdGVkIEVBUkxZIC0gY3JpdGljYWwgY2hlY2tzIHBhc3NlZC4iKQ0KICAgICAgICAgICAgZXhjZXB0Og0KICAgICAgICAgICAgICAgIHBhc3MgICMgSWYgbG9nZ2luZyBmYWlscywgdGhhdCdzIE9LIC0gZmlsZSBpcyBjcmVhdGVkDQogICAgICAgICAgICBwcmludChmIlJlYWR5IGZpbGUgY3JlYXRlZDoge3JlYWR5X2ZpbGVfcGF0aH0iKQ0KICAgICAgICAgICAgcHJpbnQoZiJSZWFkeSBmaWxlIGFic29sdXRlIHBhdGg6IHtvcy5wYXRoLmFic3BhdGgocmVhZHlfZmlsZV9wYXRoKX0iKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgcHJpbnQoZiJXQVJOSU5HOiBSZWFkeSBmaWxlIHdyaXRlIHN1Y2NlZWRlZCBidXQgZmlsZSBkb2Vzbid0IGV4aXN0ISIpDQogICAgICAgICAgICBwcmludChmIkF0dGVtcHRlZCBwYXRoOiB7cmVhZHlfZmlsZV9wYXRofSIpDQogICAgICAgICAgICBwcmludChmIkJBU0VfRElSOiB7QkFTRV9ESVJ9IikNCiAgICAgICAgICAgIHByaW50KGYiQkFTRV9ESVIgZXhpc3RzOiB7b3MucGF0aC5leGlzdHMoQkFTRV9ESVIpfSIpDQogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICBlcnJvcl9tc2cgPSBmIkNSSVRJQ0FMOiBDb3VsZCBub3QgY3JlYXRlIHJlYWR5IGZpbGU6IHtlfSINCiAgICAgICAgIyBUcnkgdG8gbG9nLCBidXQgZG9uJ3QgZmFpbCBpZiBsb2dnaW5nIGZhaWxzDQogICAgICAgIHRyeToNCiAgICAgICAgICAgIGxvZyhlcnJvcl9tc2cpDQogICAgICAgIGV4Y2VwdDoNCiAgICAgICAgICAgIHBhc3MNCiAgICAgICAgcHJpbnQoZXJyb3JfbXNnKQ0KICAgICAgICAjIFdyaXRlIHRvIHN0YXJ0dXAgZXJyb3IgZmlsZQ0KICAgICAgICB0cnk6DQogICAgICAgICAgICBTVEFSVFVQX0VSUk9SX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkYWVtb25fc3RhcnR1cF9lcnJvci50eHQiKQ0KICAgICAgICAgICAgd2l0aCBvcGVuKFNUQVJUVVBfRVJST1JfRklMRSwgInciLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOg0KICAgICAgICAgICAgICAgIGYud3JpdGUoZiJGYWlsZWQgdG8gY3JlYXRlIHJlYWR5IGZpbGU6IHtlfVxuIikNCiAgICAgICAgICAgICAgICBmLndyaXRlKGYiQkFTRV9ESVI6IHtCQVNFX0RJUn1cbiIpDQogICAgICAgICAgICAgICAgZi53cml0ZShmIlJFQURZX0ZJTEU6IHtSRUFEWV9GSUxFfVxuIikNCiAgICAgICAgICAgICAgICBmLndyaXRlKGYiQkFTRV9ESVIgZXhpc3RzOiB7b3MucGF0aC5leGlzdHMoQkFTRV9ESVIpfVxuIikNCiAgICAgICAgICAgICAgICBmLndyaXRlKGYiQkFTRV9ESVIgd3JpdGFibGU6IHtvcy5hY2Nlc3MoQkFTRV9ESVIsIG9zLldfT0spfVxuIikNCiAgICAgICAgZXhjZXB0Og0KICAgICAgICAgICAgcGFzcw0KICAgICAgICAjIERvbid0IGNvbnRpbnVlIC0gcmVhZHkgZmlsZSBpcyBjcml0aWNhbA0KICAgICAgICByZXR1cm4NCiAgICANCiAgICBpZiBub3QgcmVhZHlfZmlsZV9jcmVhdGVkOg0KICAgICAgICBwcmludCgiRVJST1I6IFJlYWR5IGZpbGUgd2FzIG5vdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseSEiKQ0KICAgICAgICByZXR1cm4NCiAgICANCiAgICBzdGF0ZSA9IGxvYWRfc3RhdGUoKQ0KICAgIA0KICAgICMgVHJ5IGF1dG8tZGV0ZWN0aW9uIGZpcnN0DQogICAgZGV0ZWN0ZWRfZ2FtZSA9IGRldGVjdF9nYW1lKGdhbWVzKQ0KICAgIGlmIGRldGVjdGVkX2dhbWUgYW5kIGRldGVjdGVkX2dhbWUgaW4gZ2FtZXM6DQogICAgICAgIGN1cnJlbnRfZ2FtZV9uYW1lID0gZGV0ZWN0ZWRfZ2FtZQ0KICAgICAgICBsb2coZiJBdXRvLWRldGVjdGVkIGdhbWU6IHtjdXJyZW50X2dhbWVfbmFtZX0iKQ0KICAgIGVsc2U6DQogICAgICAgICMgRmFsbCBiYWNrIHRvIHNhdmVkIGdhbWUgb3IgZmlyc3QgZ2FtZQ0KICAgICAgICBjdXJyZW50X2dhbWVfbmFtZSA9IHN0YXRlLmdldCgiY3VycmVudF9nYW1lIikgb3IgY29uZmlnLmdldCgiY3VycmVudF9nYW1lIikgb3IgbGlzdChnYW1lcy5rZXlzKCkpWzBdDQogICAgICAgIGlmIGRldGVjdGVkX2dhbWUgaXMgTm9uZToNCiAgICAgICAgICAgIGxvZyhmIk5vIGdhbWUgZGV0ZWN0ZWQgcnVubmluZy4gVXNpbmcgc2F2ZWQgZ2FtZToge2N1cnJlbnRfZ2FtZV9uYW1lfSIpDQogICAgDQogICAgaWYgY3VycmVudF9nYW1lX25hbWUgbm90IGluIGdhbWVzOg0KICAgICAgICBjdXJyZW50X2dhbWVfbmFtZSA9IGxpc3QoZ2FtZXMua2V5cygpKVswXQ0KICAgIA0KICAgIGdhbWVfY29uZmlnID0gZ2FtZXNbY3VycmVudF9nYW1lX25hbWVdDQogICAgc3RhdGVbImN1cnJlbnRfZ2FtZSJdID0gY3VycmVudF9nYW1lX25hbWUNCiAgICANCiAgICAjIEdldCB0aGUgY3VycmVudCBnYW1lJ3MgZGVhdGggY291bnQgKG5vdCB0b3RhbCkNCiAgICBnYW1lX2RlYXRocyA9IHN0YXRlLmdldCgiZ2FtZV9kZWF0aHMiLCB7fSkuZ2V0KGN1cnJlbnRfZ2FtZV9uYW1lLCAwKQ0KICAgICMgV3JpdGUgaW5pdGlhbCB0ZXh0IGZpbGUgc28gT0JTIGhhcyBjdXJyZW50IGdhbWUncyBjb3VudCBvbiBzdGFydHVwDQogICAgd3JpdGVfdGV4dChnYW1lX2RlYXRocywgY3VycmVudF9nYW1lX25hbWUpDQogICAgIyBXcml0ZSBpbml0aWFsIGNoYXQgaW5mbyBmaWxlDQogICAgd3JpdGVfY2hhdF9pbmZvKGN1cnJlbnRfZ2FtZV9uYW1lLCBnYW1lX2RlYXRocykNCiAgICAjIFdyaXRlIGluaXRpYWwgdG90YWwgZGVhdGhzIGZpbGUNCiAgICB3cml0ZV90b3RhbF9kZWF0aHMoc3RhdGUuZ2V0KCJ0b3RhbF9kZWF0aHMiLCAwKSkNCiAgICANCiAgICBsb2coIj0iICogNjApDQogICAgbG9nKCJNdWx0aS1HYW1lIERlYXRoIENvdW50ZXIgRGFlbW9uIFN0YXJ0ZWQiKQ0KICAgIGxvZyhmIkN1cnJlbnQgR2FtZToge2N1cnJlbnRfZ2FtZV9uYW1lfSIpDQogICAgbG9nKGYiTW9uaXRvcjoge2dhbWVfY29uZmlnLmdldCgnbW9uaXRvcl9pbmRleCcsIHNldHRpbmdzWydtb25pdG9yX2luZGV4J10pfSIpDQogICAgbG9nKGYiUmVnaW9uOiB7Z2FtZV9jb25maWcuZ2V0KCdyZWdpb24nLCB7fSl9IikNCiAgICBsb2coZiJLZXl3b3Jkczoge2dhbWVfY29uZmlnLmdldCgna2V5d29yZHMnLCBbXSl9IikNCiAgICBsb2coZiJDdXJyZW50IERlYXRocyAtIFRvdGFsOiB7c3RhdGVbJ3RvdGFsX2RlYXRocyddfSwge2N1cnJlbnRfZ2FtZV9uYW1lfToge3N0YXRlWydnYW1lX2RlYXRocyddLmdldChjdXJyZW50X2dhbWVfbmFtZSwgMCl9IikNCiAgICBsb2coIj0iICogNjApDQogICAgDQogICAgIyBSZWFkeSBmaWxlIGFscmVhZHkgY3JlYXRlZCBhYm92ZSAtIGp1c3QgdmVyaWZ5IGl0IGV4aXN0cw0KICAgIGlmIG9zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpOg0KICAgICAgICBsb2coZiJSRUFEWV9GSUxFIHZlcmlmaWVkOiB7UkVBRFlfRklMRX0iKQ0KICAgIGVsc2U6DQogICAgICAgIGxvZyhmIldBUk5JTkc6IFJFQURZX0ZJTEUgbWlzc2luZywgcmVjcmVhdGluZy4uLiIpDQogICAgICAgIHRyeToNCiAgICAgICAgICAgIHdpdGggb3BlbihSRUFEWV9GSUxFLCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICAgICAgZi53cml0ZShzdHIob3MuZ2V0cGlkKCkpKQ0KICAgICAgICAgICAgbG9nKGYiUkVBRFlfRklMRSByZWNyZWF0ZWQ6IHtSRUFEWV9GSUxFfSIpDQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgIGxvZyhmIkVSUk9SOiBDb3VsZCBub3QgcmVjcmVhdGUgcmVhZHkgZmlsZToge2V9IikNCiAgICANCiAgICAjIE5vdyBlbnRlciBtc3MgY29udGV4dCAtIGlmIHRoaXMgaGFuZ3MsIHJlYWR5IGZpbGUgYWxyZWFkeSBleGlzdHMNCiAgICB3aXRoIG1zcygpIGFzIHNjdDoNCiAgICAgICAgbnVtX21vbml0b3JzID0gbGVuKHNjdC5tb25pdG9ycykNCiAgICAgICAgbG9nKGYiQXZhaWxhYmxlIG1vbml0b3JzOiB7bnVtX21vbml0b3JzfSIpDQogICAgICAgIGZvciBpLCBtb24gaW4gZW51bWVyYXRlKHNjdC5tb25pdG9ycyk6DQogICAgICAgICAgICBsb2coZiIgIE1vbml0b3Ige2l9OiB7bW9uWyd3aWR0aCddfXh7bW9uWydoZWlnaHQnXX0gYXQgKHttb25bJ2xlZnQnXX0sIHttb25bJ3RvcCddfSkiKQ0KICAgICAgICANCiAgICAgICAgIyBHZXQgY29uZmlndXJlZCBtb25pdG9yIGluZGV4IGFuZCB2YWxpZGF0ZSBpdA0KICAgICAgICBtb25pdG9yX2luZGV4ID0gZ2FtZV9jb25maWcuZ2V0KCJtb25pdG9yX2luZGV4Iiwgc2V0dGluZ3NbIm1vbml0b3JfaW5kZXgiXSkNCiAgICAgICAgDQogICAgICAgICMgVmFsaWRhdGUgbW9uaXRvciBpbmRleCAtIG1zcyB1c2VzIDAtaW5kZXhlZCB3aGVyZSAwIGlzICJhbGwgbW9uaXRvcnMiDQogICAgICAgICMgVmFsaWQgaW5kaWNlcyBhcmUgMCAoYWxsKSBhbmQgMSB0byAobnVtX21vbml0b3JzLTEpIGZvciBpbmRpdmlkdWFsIG1vbml0b3JzDQogICAgICAgIG1heF92YWxpZF9pbmRleCA9IG51bV9tb25pdG9ycyAtIDENCiAgICAgICAgaWYgbW9uaXRvcl9pbmRleCA8IDAgb3IgbW9uaXRvcl9pbmRleCA+IG1heF92YWxpZF9pbmRleDoNCiAgICAgICAgICAgIGxvZyhmIldBUk5JTkc6IENvbmZpZ3VyZWQgbW9uaXRvcl9pbmRleCB7bW9uaXRvcl9pbmRleH0gaXMgaW52YWxpZCAodmFsaWQgcmFuZ2U6IDAte21heF92YWxpZF9pbmRleH0pLiBVc2luZyBtb25pdG9yIDEuIikNCiAgICAgICAgICAgIG1vbml0b3JfaW5kZXggPSAxICAjIERlZmF1bHQgdG8gbW9uaXRvciAxIChwcmltYXJ5IGRpc3BsYXkpDQogICAgICAgICAgICAjIFVwZGF0ZSB0aGUgY29uZmlnIHRvIHNhdmUgdGhlIGNvcnJlY3RlZCB2YWx1ZQ0KICAgICAgICAgICAgZ2FtZV9jb25maWdbIm1vbml0b3JfaW5kZXgiXSA9IG1vbml0b3JfaW5kZXgNCiAgICAgICAgICAgIGNvbmZpZ1siZ2FtZXMiXVtjdXJyZW50X2dhbWVfbmFtZV0gPSBnYW1lX2NvbmZpZw0KICAgICAgICAgICAgc2F2ZV9jb25maWcoY29uZmlnKQ0KICAgICAgICANCiAgICAgICAgcmVnaW9uID0gZ2FtZV9jb25maWcuZ2V0KCJyZWdpb24iLCB7fSkNCiAgICAgICAga2V5d29yZHMgPSBnYW1lX2NvbmZpZy5nZXQoImtleXdvcmRzIiwgWyJZT1VESUVEIl0pDQogICAgICAgIHRlc3NlcmFjdF9jb25maWcgPSBnYW1lX2NvbmZpZy5nZXQoInRlc3NlcmFjdF9jb25maWciLCAiLS1vZW0gMyAtLXBzbSA3IikNCiAgICAgICAgdGVzc2VyYWN0X2xhbmcgPSBnYW1lX2NvbmZpZy5nZXQoInRlc3NlcmFjdF9sYW5nIiwgImVuZyIpDQogICAgICAgIA0KICAgICAgICAjIEF1dG8tZGV0ZWN0aW9uIGNoZWNrIGludGVydmFsIChjaGVjayBldmVyeSAzMCB0aWNrcyA9IH45IHNlY29uZHMgYXQgMC4zcyB0aWNrKQ0KICAgICAgICBhdXRvX2RldGVjdF9pbnRlcnZhbCA9IDMwDQogICAgICAgICMgV2luZG93IHBvc2l0aW9uIHVwZGF0ZSBpbnRlcnZhbCAoY2hlY2sgZXZlcnkgMTAgdGlja3MgPSB+MyBzZWNvbmRzIGZvciByZXNwb25zaXZlIG1vdmVtZW50KQ0KICAgICAgICAjIE1vcmUgZnJlcXVlbnQgdGhhbiBtb25pdG9yIGRldGVjdGlvbiwgYnV0IG5vdCBldmVyeSB0aWNrIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGlzc3Vlcw0KICAgICAgICB3aW5kb3dfdXBkYXRlX2ludGVydmFsID0gMTANCiAgICAgICAgbGFzdF9hdXRvX2RldGVjdF90aWNrID0gMA0KICAgICAgICBsYXN0X21vbml0b3JfZGV0ZWN0X3RpY2sgPSAwDQogICAgICAgIGxhc3Rfd2luZG93X3VwZGF0ZV90aWNrID0gMA0KICAgICAgICBjYWNoZWRfbW9uaXRvcl9pbmRleCA9IG1vbml0b3JfaW5kZXggICMgQ2FjaGUgdGhlIGRldGVjdGVkIG1vbml0b3INCiAgICAgICAgY2FjaGVkX3dpbmRvd19yZWN0ID0gTm9uZSAgIyBDYWNoZSB0aGUgZGV0ZWN0ZWQgd2luZG93IHJlY3QgZm9yIHdpbmRvd2VkIG1vZGUgc3VwcG9ydA0KICAgICAgICANCiAgICAgICAgIyBGbGFnIHRvIHRyYWNrIGlmIGRhZW1vbiBoYXMgZnVsbHkgc3RhcnRlZCAob25seSBydW4gbW9uaXRvciBkZXRlY3Rpb24gYWZ0ZXIgdGhpcykNCiAgICAgICAgZGFlbW9uX3N0YXJ0ZWQgPSBGYWxzZQ0KICAgICAgICBzdGFydHVwX3RpY2tzID0gMTAgICMgV2FpdCAxMCB0aWNrcyAofjMgc2Vjb25kcykgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVmb3JlIHN0YXJ0aW5nIG1vbml0b3IgZGV0ZWN0aW9uDQogICAgICAgIA0KICAgICAgICB3aGlsZSBUcnVlOg0KICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoU1RPUF9GSUxFKToNCiAgICAgICAgICAgICAgICBsb2coIlNUT1AgZmlsZSBkZXRlY3RlZC4gRXhpdGluZyBjbGVhbmx5LiIpDQogICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgc3RhdGVbInRpY2siXSArPSAxDQogICAgICAgICAgICBub3cgPSB0aW1lLnRpbWUoKQ0KICAgICAgICAgICAgDQogICAgICAgICAgICAjIE1hcmsgZGFlbW9uIGFzIHN0YXJ0ZWQgYWZ0ZXIgaW5pdGlhbCBzdGFydHVwIHBlcmlvZA0KICAgICAgICAgICAgaWYgbm90IGRhZW1vbl9zdGFydGVkIGFuZCBzdGF0ZVsidGljayJdID49IHN0YXJ0dXBfdGlja3M6DQogICAgICAgICAgICAgICAgZGFlbW9uX3N0YXJ0ZWQgPSBUcnVlDQogICAgICAgICAgICAgICAgbG9nKCJNb25pdG9yIGF1dG8tZGV0ZWN0aW9uIGVuYWJsZWQuIikNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBBdXRvLWRldGVjdCBnYW1lIHBlcmlvZGljYWxseQ0KICAgICAgICAgICAgaWYgc3RhdGVbInRpY2siXSAtIGxhc3RfYXV0b19kZXRlY3RfdGljayA+PSBhdXRvX2RldGVjdF9pbnRlcnZhbDoNCiAgICAgICAgICAgICAgICBkZXRlY3RlZF9nYW1lID0gZGV0ZWN0X2dhbWUoZ2FtZXMpDQogICAgICAgICAgICAgICAgaWYgZGV0ZWN0ZWRfZ2FtZSBhbmQgZGV0ZWN0ZWRfZ2FtZSBpbiBnYW1lcyBhbmQgZGV0ZWN0ZWRfZ2FtZSAhPSBjdXJyZW50X2dhbWVfbmFtZToNCiAgICAgICAgICAgICAgICAgICAgbG9nKGYiR2FtZSBjaGFuZ2VkIGRldGVjdGVkOiB7Y3VycmVudF9nYW1lX25hbWV9IC0+IHtkZXRlY3RlZF9nYW1lfSIpDQogICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfZ2FtZV9uYW1lID0gZGV0ZWN0ZWRfZ2FtZQ0KICAgICAgICAgICAgICAgICAgICBnYW1lX2NvbmZpZyA9IGdhbWVzW2N1cnJlbnRfZ2FtZV9uYW1lXQ0KICAgICAgICAgICAgICAgICAgICBzdGF0ZVsiY3VycmVudF9nYW1lIl0gPSBjdXJyZW50X2dhbWVfbmFtZQ0KICAgICAgICAgICAgICAgICAgICAjIFVwZGF0ZSBjb25maWcgZmlsZQ0KICAgICAgICAgICAgICAgICAgICBjb25maWdbImN1cnJlbnRfZ2FtZSJdID0gY3VycmVudF9nYW1lX25hbWUNCiAgICAgICAgICAgICAgICAgICAgc2F2ZV9jb25maWcoY29uZmlnKQ0KICAgICAgICAgICAgICAgICAgICAjIEdldCB0aGUgbmV3IGdhbWUncyBkZWF0aCBjb3VudA0KICAgICAgICAgICAgICAgICAgICBnYW1lX2RlYXRocyA9IHN0YXRlLmdldCgiZ2FtZV9kZWF0aHMiLCB7fSkuZ2V0KGN1cnJlbnRfZ2FtZV9uYW1lLCAwKQ0KICAgICAgICAgICAgICAgICAgICAjIFdyaXRlIHVwZGF0ZWQgdGV4dCBmaWxlcyB3aXRoIHRoZSBuZXcgZ2FtZSdzIGNvdW50DQogICAgICAgICAgICAgICAgICAgIHdyaXRlX3RleHQoZ2FtZV9kZWF0aHMsIGN1cnJlbnRfZ2FtZV9uYW1lKQ0KICAgICAgICAgICAgICAgICAgICAjIFdyaXRlIHVwZGF0ZWQgY2hhdCBpbmZvDQogICAgICAgICAgICAgICAgICAgIHdyaXRlX2NoYXRfaW5mbyhjdXJyZW50X2dhbWVfbmFtZSwgZ2FtZV9kZWF0aHMpDQogICAgICAgICAgICAgICAgICAgICMgV3JpdGUgdXBkYXRlZCB0b3RhbCBkZWF0aHMNCiAgICAgICAgICAgICAgICAgICAgd3JpdGVfdG90YWxfZGVhdGhzKHN0YXRlLmdldCgidG90YWxfZGVhdGhzIiwgMCkpDQogICAgICAgICAgICAgICAgICAgICMgVXBkYXRlIG1vbml0b3IgYW5kIHJlZ2lvbiBzZXR0aW5ncyAtIHZhbGlkYXRlIG1vbml0b3IgaW5kZXgNCiAgICAgICAgICAgICAgICAgICAgbW9uaXRvcl9pbmRleCA9IGdhbWVfY29uZmlnLmdldCgibW9uaXRvcl9pbmRleCIsIHNldHRpbmdzWyJtb25pdG9yX2luZGV4Il0pDQogICAgICAgICAgICAgICAgICAgIG1heF92YWxpZF9pbmRleCA9IGxlbihzY3QubW9uaXRvcnMpIC0gMQ0KICAgICAgICAgICAgICAgICAgICBpZiBtb25pdG9yX2luZGV4IDwgMCBvciBtb25pdG9yX2luZGV4ID4gbWF4X3ZhbGlkX2luZGV4Og0KICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGYiV0FSTklORzogTW9uaXRvciB7bW9uaXRvcl9pbmRleH0gaW52YWxpZCBmb3Ige2N1cnJlbnRfZ2FtZV9uYW1lfSAodmFsaWQ6IDAte21heF92YWxpZF9pbmRleH0pLiBVc2luZyBtb25pdG9yIDEuIikNCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbml0b3JfaW5kZXggPSAxDQogICAgICAgICAgICAgICAgICAgICAgICBnYW1lX2NvbmZpZ1sibW9uaXRvcl9pbmRleCJdID0gbW9uaXRvcl9pbmRleA0KICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnWyJnYW1lcyJdW2N1cnJlbnRfZ2FtZV9uYW1lXSA9IGdhbWVfY29uZmlnDQogICAgICAgICAgICAgICAgICAgICAgICBzYXZlX2NvbmZpZyhjb25maWcpDQogICAgICAgICAgICAgICAgICAgIGNhY2hlZF9tb25pdG9yX2luZGV4ID0gbW9uaXRvcl9pbmRleCAgIyBSZXNldCBjYWNoZSB3aGVuIGdhbWUgY2hhbmdlcw0KICAgICAgICAgICAgICAgICAgICBjYWNoZWRfd2luZG93X3JlY3QgPSBOb25lICAjIFJlc2V0IHdpbmRvdyBjYWNoZSB3aGVuIGdhbWUgY2hhbmdlcyAod2lsbCBiZSBkZXRlY3RlZCBvbiBuZXh0IGNoZWNrKQ0KICAgICAgICAgICAgICAgICAgICByZWdpb24gPSBnYW1lX2NvbmZpZy5nZXQoInJlZ2lvbiIsIHt9KQ0KICAgICAgICAgICAgICAgICAgICBrZXl3b3JkcyA9IGdhbWVfY29uZmlnLmdldCgia2V5d29yZHMiLCBbIllPVURJRUQiXSkNCiAgICAgICAgICAgICAgICAgICAgdGVzc2VyYWN0X2NvbmZpZyA9IGdhbWVfY29uZmlnLmdldCgidGVzc2VyYWN0X2NvbmZpZyIsICItLW9lbSAzIC0tcHNtIDciKQ0KICAgICAgICAgICAgICAgICAgICBsb2coZiJTd2l0Y2hlZCB0bzoge2N1cnJlbnRfZ2FtZV9uYW1lfSB8IE1vbml0b3I6IHttb25pdG9yX2luZGV4fSB8IFJlZ2lvbjoge3JlZ2lvbn0gfCBEZWF0aHM6IHtnYW1lX2RlYXRoc30iKQ0KICAgICAgICAgICAgICAgIGxhc3RfYXV0b19kZXRlY3RfdGljayA9IHN0YXRlWyJ0aWNrIl0NCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBBdXRvLWRldGVjdCBtb25pdG9yIHBlcmlvZGljYWxseSAodGhyb3R0bGVkIHRvIHByZXZlbnQgcmFjZSBjb25kaXRpb25zKQ0KICAgICAgICAgICAgIyBPbmx5IHJ1biBhZnRlciBkYWVtb24gaGFzIGZ1bGx5IHN0YXJ0ZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIGR1cmluZyBpbml0aWFsaXphdGlvbg0KICAgICAgICAgICAgaWYgZGFlbW9uX3N0YXJ0ZWQgYW5kIHN0YXRlWyJ0aWNrIl0gLSBsYXN0X21vbml0b3JfZGV0ZWN0X3RpY2sgPj0gYXV0b19kZXRlY3RfaW50ZXJ2YWw6DQogICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICBnYW1lX3Byb2Nlc3MgPSBnZXRfZ2FtZV9wcm9jZXNzKGdhbWVfY29uZmlnKQ0KICAgICAgICAgICAgICAgICAgICBpZiBnYW1lX3Byb2Nlc3M6DQogICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dfcmVjdCA9IGdldF93aW5kb3dfcmVjdChnYW1lX3Byb2Nlc3MpDQogICAgICAgICAgICAgICAgICAgICAgICBpZiB3aW5kb3dfcmVjdDoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIERldGVjdCB3aGljaCBtb25pdG9yIGNvbnRhaW5zIHRoZSB3aW5kb3cgKG9ubHkgdXBkYXRlIG1vbml0b3IsIG5vdCB3aW5kb3cgcG9zaXRpb24pDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRfbW9uaXRvciA9IGZpbmRfbW9uaXRvcl9mb3Jfd2luZG93KHdpbmRvd19yZWN0LCBzY3QubW9uaXRvcnMpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGV0ZWN0ZWRfbW9uaXRvciBpcyBub3QgTm9uZSBhbmQgZGV0ZWN0ZWRfbW9uaXRvciAhPSBjYWNoZWRfbW9uaXRvcl9pbmRleDoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGYiQXV0by1kZXRlY3RlZCBtb25pdG9yIHtkZXRlY3RlZF9tb25pdG9yfSBmb3IgZ2FtZSB3aW5kb3cgKHdhcyB1c2luZyB7Y2FjaGVkX21vbml0b3JfaW5kZXh9KSIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZF9tb25pdG9yX2luZGV4ID0gZGV0ZWN0ZWRfbW9uaXRvcg0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIFdpbmRvdyBub3QgZm91bmQgLSBjbGVhciBjYWNoZSBhbmQgZmFsbGJhY2sgdG8gbW9uaXRvciBtb2RlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkX3dpbmRvd19yZWN0ID0gTm9uZQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZygiV2luZG93IG5vdCBmb3VuZCBmb3IgZ2FtZSBwcm9jZXNzLCB1c2luZyBtb25pdG9yIG1vZGUiKQ0KICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCJHYW1lIHByb2Nlc3Mgbm90IGZvdW5kLCB1c2luZyBtb25pdG9yIG1vZGUiKQ0KICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgICAgICAgICAgIyBGYWxsIGJhY2sgdG8gY29uZmlndXJlZCBtb25pdG9yIGlmIGF1dG8tZGV0ZWN0aW9uIGZhaWxzDQogICAgICAgICAgICAgICAgICAgICMgQ2xlYXIgd2luZG93IGNhY2hlIG9uIGVycm9yIHRvIGVuc3VyZSB3ZSB1c2UgbW9uaXRvciBtb2RlDQogICAgICAgICAgICAgICAgICAgIGNhY2hlZF93aW5kb3dfcmVjdCA9IE5vbmUNCiAgICAgICAgICAgICAgICAgICAgbG9nKGYiV2luZG93IGRldGVjdGlvbiBlcnJvciAodXNpbmcgbW9uaXRvciBtb2RlKToge2V9IikNCiAgICAgICAgICAgICAgICBsYXN0X21vbml0b3JfZGV0ZWN0X3RpY2sgPSBzdGF0ZVsidGljayJdDQogICAgICAgICAgICANCiAgICAgICAgICAgICMgVXBkYXRlIHdpbmRvdyBwb3NpdGlvbiBwZXJpb2RpY2FsbHkgd2hlbiBpbiB3aW5kb3dlZCBtb2RlIChmb3IgcmVzcG9uc2l2ZSB3aW5kb3cgbW92ZW1lbnQpDQogICAgICAgICAgICAjIENoZWNrIG1vcmUgZnJlcXVlbnRseSB0aGFuIG1vbml0b3IgZGV0ZWN0aW9uIChldmVyeSAxMCB0aWNrcyA9IH4zcykgYnV0IG5vdCBldmVyeSB0aWNrIGZvciBwZXJmb3JtYW5jZQ0KICAgICAgICAgICAgaWYgZGFlbW9uX3N0YXJ0ZWQgYW5kIHN0YXRlWyJ0aWNrIl0gLSBsYXN0X3dpbmRvd191cGRhdGVfdGljayA+PSB3aW5kb3dfdXBkYXRlX2ludGVydmFsOg0KICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgZ2FtZV9wcm9jZXNzID0gZ2V0X2dhbWVfcHJvY2VzcyhnYW1lX2NvbmZpZykNCiAgICAgICAgICAgICAgICAgICAgaWYgZ2FtZV9wcm9jZXNzOg0KICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93X3JlY3QgPSBnZXRfd2luZG93X3JlY3QoZ2FtZV9wcm9jZXNzKQ0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgd2luZG93X3JlY3Q6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBDaGVjayBpZiB0aGlzIGlzIGZpcnN0IGRldGVjdGlvbiBvciB3aW5kb3cgbW92ZWQNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBjYWNoZWRfd2luZG93X3JlY3QgaXMgTm9uZToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBGaXJzdCB0aW1lIGRldGVjdGluZyB3aW5kb3cgLSBsb2cgaXQNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGYiV2luZG93IGRldGVjdGVkOiBwb3M9KHt3aW5kb3dfcmVjdC5nZXQoJ2xlZnQnLCAwKX0sIHt3aW5kb3dfcmVjdC5nZXQoJ3RvcCcsIDApfSkgc2l6ZT17d2luZG93X3JlY3QuZ2V0KCd3aWR0aCcsIDApfXh7d2luZG93X3JlY3QuZ2V0KCdoZWlnaHQnLCAwKX0iKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRfd2luZG93X3JlY3QgPSB3aW5kb3dfcmVjdA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgd2luZG93IHBvc2l0aW9uIGNoYW5nZWQNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkX3BvcyA9IChjYWNoZWRfd2luZG93X3JlY3QuZ2V0KCdsZWZ0JywgMCksIGNhY2hlZF93aW5kb3dfcmVjdC5nZXQoJ3RvcCcsIDApKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcG9zID0gKHdpbmRvd19yZWN0LmdldCgnbGVmdCcsIDApLCB3aW5kb3dfcmVjdC5nZXQoJ3RvcCcsIDApKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBvbGRfcG9zICE9IG5ld19wb3M6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coZiJXaW5kb3cgbW92ZWQ6IHtvbGRfcG9zfSAtPiB7bmV3X3Bvc30sIHVwZGF0aW5nIGNhcHR1cmUgcmVnaW9uIikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBBbHdheXMgdXBkYXRlIGNhY2hlZCB3aW5kb3cgcmVjdCB3aXRoIGxhdGVzdCBwb3NpdGlvbg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRfd2luZG93X3JlY3QgPSB3aW5kb3dfcmVjdA0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIFdpbmRvdyBkaXNhcHBlYXJlZCAtIGNsZWFyIGNhY2hlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgY2FjaGVkX3dpbmRvd19yZWN0IGlzIG5vdCBOb25lOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coIldpbmRvdyBkaXNhcHBlYXJlZCwgZmFsbGluZyBiYWNrIHRvIG1vbml0b3IgbW9kZSIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkX3dpbmRvd19yZWN0ID0gTm9uZQ0KICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246DQogICAgICAgICAgICAgICAgICAgICMgU2lsZW50bHkgZmFpbCAtIGtlZXAgdXNpbmcgY2FjaGVkIHBvc2l0aW9uIGlmIGF2YWlsYWJsZQ0KICAgICAgICAgICAgICAgICAgICBwYXNzDQogICAgICAgICAgICAgICAgbGFzdF93aW5kb3dfdXBkYXRlX3RpY2sgPSBzdGF0ZVsidGljayJdDQogICAgICAgICAgICANCiAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAjIENhcHR1cmUgcmVnaW9uIHVzaW5nIGNhY2hlZCBtb25pdG9yIGluZGV4IGFuZCB3aW5kb3cgcmVjdCAoaWYgYXZhaWxhYmxlKQ0KICAgICAgICAgICAgICAgICMgV2luZG93IHJlY3QgaXMgcGFzc2VkIGZvciBhdXRvbWF0aWMgd2luZG93ZWQgbW9kZSBkZXRlY3Rpb24NCiAgICAgICAgICAgICAgICBpbWdfcmdiID0gZ3JhYl9yZWdpb24oc2N0LCBjYWNoZWRfbW9uaXRvcl9pbmRleCwgcmVnaW9uLCBnYW1lX2NvbmZpZywgY2FjaGVkX3dpbmRvd19yZWN0KQ0KICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgICMgU2F2ZSBkZWJ1ZyBpbWFnZXMgcGVyaW9kaWNhbGx5DQogICAgICAgICAgICAgICAgc2F2ZV9kZWJ1ZyA9IChzdGF0ZVsidGljayJdICUgc2V0dGluZ3NbImRlYnVnX2V2ZXJ5X3RpY2tzIl0gPT0gMCkNCiAgICAgICAgICAgICAgICBpZiBzYXZlX2RlYnVnOg0KICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICBpbWdfcmdiLnNhdmUoREVCVUdfUkFXKQ0KICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgICAgICAgICAgICAgICAgICBsb2coZiJERUJVRyBSQVcgU0FWRSBFUlJPUjoge2V9IikNCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAjIFByZXByb2Nlc3MgKyBPQ1INCiAgICAgICAgICAgICAgICBvY3JfaW1nLCBpbmZvID0gcHJlcHJvY2Vzc19mb3Jfb2NyKGltZ19yZ2IpDQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgaWYgc2F2ZV9kZWJ1ZzoNCiAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgb2NyX2ltZy5zYXZlKERFQlVHX09DUikNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICAgICAgICAgICAgICAgICAgbG9nKGYiREVCVUcgT0NSIFNBVkUgRVJST1I6IHtlfSIpDQogICAgICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgY2xlYW4gPSBvY3JfdGV4dChvY3JfaW1nLCB0ZXNzZXJhY3RfY29uZmlnLCB0ZXNzZXJhY3RfbGFuZykNCiAgICAgICAgICAgICAgICBkZXRlY3RlZCA9IGNvbnRhaW5zX2tleXdvcmQoY2xlYW4sIGtleXdvcmRzKQ0KICAgICAgICAgICAgICAgIHN0YXRlWyJzdHJlYWsiXSA9IChzdGF0ZVsic3RyZWFrIl0gKyAxKSBpZiBkZXRlY3RlZCBlbHNlIDANCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAjIExvZyBwZXJpb2RpY2FsbHkNCiAgICAgICAgICAgICAgICBpZiBzdGF0ZVsidGljayJdICUgMTAgPT0gMCBvciBzYXZlX2RlYnVnOg0KICAgICAgICAgICAgICAgICAgICBjb3ZlcmFnZSA9IGluZm8uZ2V0KCdjb3ZlcmFnZScsIDAuMCkNCiAgICAgICAgICAgICAgICAgICAgbG9nKGYiVGljaz17c3RhdGVbJ3RpY2snXX0gR2FtZT17Y3VycmVudF9nYW1lX25hbWV9IE1vZGU9e2luZm9bJ21vZGUnXX0gIg0KICAgICAgICAgICAgICAgICAgICAgICAgZiJDb3ZlcmFnZT17Y292ZXJhZ2U6LjRmfSBPQ1I9J3tjbGVhbn0nICINCiAgICAgICAgICAgICAgICAgICAgICAgIGYiRGV0ZWN0ZWQ9e2RldGVjdGVkfSBTdHJlYWs9e3N0YXRlWydzdHJlYWsnXX0ve3NldHRpbmdzWydjb25zZWN1dGl2ZV9oaXRzJ119IikNCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAjIENvdW50IGRlYXRoOiBzdGFibGUgZGV0ZWN0aW9uICsgY29vbGRvd24NCiAgICAgICAgICAgICAgICBjb29sZG93bl9wYXNzZWQgPSAobm93IC0gZmxvYXQoc3RhdGVbImxhc3RfZGVhdGhfdHMiXSkpID49IHNldHRpbmdzWyJjb29sZG93bl9zZWNvbmRzIl0NCiAgICAgICAgICAgICAgICBpZiBzdGF0ZVsic3RyZWFrIl0gPj0gc2V0dGluZ3NbImNvbnNlY3V0aXZlX2hpdHMiXSBhbmQgY29vbGRvd25fcGFzc2VkOg0KICAgICAgICAgICAgICAgICAgICBzdGF0ZVsidG90YWxfZGVhdGhzIl0gPSBpbnQoc3RhdGVbInRvdGFsX2RlYXRocyJdKSArIDENCiAgICAgICAgICAgICAgICAgICAgc3RhdGVbImdhbWVfZGVhdGhzIl0uc2V0ZGVmYXVsdChjdXJyZW50X2dhbWVfbmFtZSwgMCkNCiAgICAgICAgICAgICAgICAgICAgc3RhdGVbImdhbWVfZGVhdGhzIl1bY3VycmVudF9nYW1lX25hbWVdID0gaW50KHN0YXRlWyJnYW1lX2RlYXRocyJdW2N1cnJlbnRfZ2FtZV9uYW1lXSkgKyAxDQogICAgICAgICAgICAgICAgICAgIHN0YXRlWyJsYXN0X2RlYXRoX3RzIl0gPSBub3cNCiAgICAgICAgICAgICAgICAgICAgc3RhdGVbInN0cmVhayJdID0gMA0KICAgICAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAgICAgIyBTYXZlIHN0YXRlIGFuZCB3cml0ZSB0ZXh0IGZpbGUNCiAgICAgICAgICAgICAgICAgICAgc2F2ZV9zdGF0ZShzdGF0ZSkNCiAgICAgICAgICAgICAgICAgICAgIyBXcml0ZSB0aGUgY3VycmVudCBnYW1lJ3MgZGVhdGggY291bnQgKG5vdCB0b3RhbCkNCiAgICAgICAgICAgICAgICAgICAgZ2FtZV9kZWF0aHMgPSBzdGF0ZVsiZ2FtZV9kZWF0aHMiXS5nZXQoY3VycmVudF9nYW1lX25hbWUsIDApDQogICAgICAgICAgICAgICAgICAgIHdyaXRlX3RleHQoZ2FtZV9kZWF0aHMsIGN1cnJlbnRfZ2FtZV9uYW1lKQ0KICAgICAgICAgICAgICAgICAgICAjIFdyaXRlIHVwZGF0ZWQgY2hhdCBpbmZvDQogICAgICAgICAgICAgICAgICAgIHdyaXRlX2NoYXRfaW5mbyhjdXJyZW50X2dhbWVfbmFtZSwgZ2FtZV9kZWF0aHMpDQogICAgICAgICAgICAgICAgICAgICMgV3JpdGUgdXBkYXRlZCB0b3RhbCBkZWF0aHMNCiAgICAgICAgICAgICAgICAgICAgd3JpdGVfdG90YWxfZGVhdGhzKHN0YXRlWyJ0b3RhbF9kZWF0aHMiXSkNCiAgICAgICAgICAgICAgICAgICAgbG9nKGYiREVBVEggQ09VTlRFRCAtPiBUb3RhbDoge3N0YXRlWyd0b3RhbF9kZWF0aHMnXX0gfCAiDQogICAgICAgICAgICAgICAgICAgICAgICBmIntjdXJyZW50X2dhbWVfbmFtZX06IHtzdGF0ZVsnZ2FtZV9kZWF0aHMnXVtjdXJyZW50X2dhbWVfbmFtZV19IikNCiAgICAgICAgICAgICAgICANCiAgICAgICAgICAgICAgICAjIFNhdmUgc3RhdGUgcGVyaW9kaWNhbGx5IChldmVyeSAxMCB0aWNrcyB0byByZWR1Y2UgSS9PKQ0KICAgICAgICAgICAgICAgIGlmIHN0YXRlWyJ0aWNrIl0gJSAxMCA9PSAwOg0KICAgICAgICAgICAgICAgICAgICBzYXZlX3N0YXRlKHN0YXRlKQ0KICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICAgICAgICAgIGxvZyhmIkVycm9yIGluIG1haW4gbG9vcDoge2V9IikNCiAgICAgICAgICAgICAgICBsb2codHJhY2ViYWNrLmZvcm1hdF9leGMoKSkNCiAgICAgICAgICAgIA0KICAgICAgICAgICAgdGltZS5zbGVlcChzZXR0aW5nc1sidGlja19zZWNvbmRzIl0pDQoNCg0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQojIEVOVFJZUE9JTlQNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KaWYgX19uYW1lX18gPT0gIl9fbWFpbl9fIjoNCiAgICAjIENyZWF0ZSBsb2NrIGZpbGUgRklSU1QgLSBiZWZvcmUgYW55dGhpbmcgZWxzZQ0KICAgIGlmIG5vdCBhY3F1aXJlX2xvY2soKToNCiAgICAgICAgcHJpbnQoIkFub3RoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBydW5uaW5nLiBFeGl0aW5nLiIpDQogICAgICAgIHJhaXNlIFN5c3RlbUV4aXQoMCkNCiAgICANCiAgICAjIENyZWF0ZSBhIHN0YXJ0dXAgZXJyb3IgZmlsZSB0byBjYXB0dXJlIGFueSBpbW1lZGlhdGUgZXJyb3JzDQogICAgU1RBUlRVUF9FUlJPUl9GSUxFID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZGFlbW9uX3N0YXJ0dXBfZXJyb3IudHh0IikNCiAgICB0cnk6DQogICAgICAgIHdpdGggb3BlbihTVEFSVFVQX0VSUk9SX0ZJTEUsICJ3IikgYXMgZjoNCiAgICAgICAgICAgIGYud3JpdGUoIiIpICAjIENsZWFyIGFueSBvbGQgZXJyb3JzDQogICAgZXhjZXB0Og0KICAgICAgICBwYXNzDQogICAgDQogICAgIyBMb2cgc3RhcnR1cCBpbW1lZGlhdGVseSAtIHVzZSBib3RoIGxvZygpIGFuZCBwcmludCgpIGZvciB2aXNpYmlsaXR5DQogICAgc3RhcnR1cF9tc2cgPSAiPSIgKiA3MCArICJcbkRFQVRIIENPVU5URVIgREFFTU9OIFNUQVJUSU5HXG4iICsgIj0iICogNzANCiAgICBwcmludChzdGFydHVwX21zZykNCiAgICBsb2coc3RhcnR1cF9tc2cpDQogICAgbG9nKGYiUElEOiB7b3MuZ2V0cGlkKCl9IikNCiAgICBsb2coZiJCQVNFX0RJUjoge0JBU0VfRElSfSIpDQogICAgbG9nKGYiTE9DS19GSUxFOiB7TE9DS19GSUxFfSIpDQogICAgbG9nKGYiUkVBRFlfRklMRToge1JFQURZX0ZJTEV9IikNCiAgICBsb2coZiJQeXRob246IHtzeXMuZXhlY3V0YWJsZX0iKQ0KICAgIGxvZyhmIlNjcmlwdDoge19fZmlsZV9ffSIpDQogICAgDQogICAgIyBBbHNvIHByaW50IGNyaXRpY2FsIGluZm8gdG8gc3Rkb3V0ICh2aXNpYmxlIGluIGNvbnNvbGUpDQogICAgcHJpbnQoZiJQSUQ6IHtvcy5nZXRwaWQoKX0iKQ0KICAgIHByaW50KGYiQkFTRV9ESVI6IHtCQVNFX0RJUn0iKQ0KICAgIHByaW50KGYiTE9DS19GSUxFOiB7TE9DS19GSUxFfSIpDQogICAgcHJpbnQoZiJSRUFEWV9GSUxFOiB7UkVBRFlfRklMRX0iKQ0KICAgIA0KICAgIGluaXRpYWxpemF0aW9uX2NvbXBsZXRlID0gRmFsc2UNCiAgICB0cnk6DQogICAgICAgICMgU21hbGwgZGVsYXkgdG8gZW5zdXJlIGxvY2sgZmlsZSBpcyB3cml0dGVuIHRvIGRpc2sNCiAgICAgICAgdGltZS5zbGVlcCgwLjEpDQogICAgICAgIHByaW50KCJTdGFydGluZyBtYWluX2xvb3AoKS4uLiIpDQogICAgICAgIGxvZygiU3RhcnRpbmcgbWFpbl9sb29wKCkuLi4iKQ0KICAgICAgICAjIENhbGwgbWFpbl9sb29wIGFuZCB0cmFjayBpZiBpdCBjb21wbGV0ZXMgaW5pdGlhbGl6YXRpb24NCiAgICAgICAgbWFpbl9sb29wKCkNCiAgICAgICAgaW5pdGlhbGl6YXRpb25fY29tcGxldGUgPSBUcnVlDQogICAgICAgIHByaW50KCJtYWluX2xvb3AoKSBjb21wbGV0ZWQgbm9ybWFsbHkiKQ0KICAgICAgICBsb2coIm1haW5fbG9vcCgpIGNvbXBsZXRlZCBub3JtYWxseSIpDQogICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0Og0KICAgICAgICBwcmludCgiRGFlbW9uIHN0b3BwZWQgKEtleWJvYXJkSW50ZXJydXB0KS4iKQ0KICAgICAgICBsb2coIkRhZW1vbiBzdG9wcGVkIChLZXlib2FyZEludGVycnVwdCkuIikNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIGVycm9yX21zZyA9IGYiRkFUQUwgRVJST1I6IHtzdHIoZSl9XG57dHJhY2ViYWNrLmZvcm1hdF9leGMoKX0iDQogICAgICAgIHByaW50KGVycm9yX21zZykNCiAgICAgICAgbG9nKGVycm9yX21zZykNCiAgICAgICAgIyBXcml0ZSBlcnJvciB0byBzdGFydHVwIGVycm9yIGZpbGUNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgd2l0aCBvcGVuKFNUQVJUVVBfRVJST1JfRklMRSwgInciLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOg0KICAgICAgICAgICAgICAgIGYud3JpdGUoZXJyb3JfbXNnKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwYXNzDQogICAgICAgICMgSWYgd2UgZ290IGhlcmUsIGluaXRpYWxpemF0aW9uIGZhaWxlZCAtIHJlbW92ZSByZWFkeSBmaWxlIGlmIGl0IGV4aXN0cw0KICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhSRUFEWV9GSUxFKToNCiAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICBvcy5yZW1vdmUoUkVBRFlfRklMRSkNCiAgICAgICAgICAgICAgICBwcmludCgiUmVtb3ZlZCByZWFkeSBmaWxlIGR1ZSB0byBlcnJvciIpDQogICAgICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICAgICAgcGFzcw0KICAgIGZpbmFsbHk6DQogICAgICAgIHByaW50KCJSZWxlYXNpbmcgbG9jayBhbmQgc2h1dHRpbmcgZG93bi4uLiIpDQogICAgICAgIHJlbGVhc2VfbG9jaygpDQogICAgICAgIGxvZygiRGFlbW9uIHNodXRkb3duIGNvbXBsZXRlLiIpDQogICAgICAgIHByaW50KCJEYWVtb24gc2h1dGRvd24gY29tcGxldGUuIikK",
  "death_counter_gui.py": "IiIiCkRlYXRoIENvdW50ZXIgR1VJIEFwcGxpY2F0aW9uCkEgc2ltcGxlIEdVSSB0byBjb250cm9sIHRoZSBkZWF0aCBjb3VudGVyIGRhZW1vbiBhbmQgdmlldyBzdGF0cy4KClRvIGNyZWF0ZSBhbiAuZXhlOgogICAgcGlwIGluc3RhbGwgcHlpbnN0YWxsZXIKICAgIHB5aW5zdGFsbGVyIC0tb25lZmlsZSAtLXdpbmRvd2VkIC0tbmFtZSAiRGVhdGhDb3VudGVyIiBkZWF0aF9jb3VudGVyX2d1aS5weQoiIiIKCmltcG9ydCBvcwppbXBvcnQgc3lzCmltcG9ydCBqc29uCmltcG9ydCB0aW1lCmltcG9ydCBzdWJwcm9jZXNzCmltcG9ydCB0aHJlYWRpbmcKaW1wb3J0IHNodXRpbAoKIyBGaXggVGNsL1RrIHZlcnNpb24gY29uZmxpY3RzIGJ5IHVzaW5nIHN5c3RlbSBUY2wvVGsgd2hlbiBhdmFpbGFibGUKIyBUaGlzIG11c3QgYmUgZG9uZSBCRUZPUkUgaW1wb3J0aW5nIHRraW50ZXIKIyBDUklUSUNBTDogU2V0IHRoZXNlIGVudmlyb25tZW50IHZhcmlhYmxlcyBiZWZvcmUgYW55IHRraW50ZXIgaW1wb3J0CiMgT25seSBydW4gdGhpcyBpZiBOT1QgcnVubmluZyBhcyBhIFB5SW5zdGFsbGVyIGJ1bmRsZSAoZnJvemVuPUZhbHNlKQppZiBub3QgZ2V0YXR0cihzeXMsICdmcm96ZW4nLCBGYWxzZSk6CiAgICB0cnk6CiAgICAgICAgIyBHZXQgdGhlIFB5dGhvbiBleGVjdXRhYmxlIHBhdGgKICAgICAgICBweXRob25fZXhlID0gc3lzLmV4ZWN1dGFibGUKICAgICAgICBpZiBweXRob25fZXhlIGFuZCBvcy5wYXRoLmV4aXN0cyhweXRob25fZXhlKToKICAgICAgICAgICAgIyBHZXQgUHl0aG9uIGluc3RhbGxhdGlvbiBkaXJlY3RvcnkKICAgICAgICAgICAgcHl0aG9uX2RpciA9IG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgocHl0aG9uX2V4ZSkpCiAgICAgICAgICAgIHB5dGhvbl9saWIgPSBvcy5wYXRoLmpvaW4ocHl0aG9uX2RpciwgJ0xpYicpCiAgICAgICAgICAgIHRraW50ZXJfcGF0aCA9IG9zLnBhdGguam9pbihweXRob25fbGliLCAndGtpbnRlcicpCiAgICAgICAgICAgIAogICAgICAgICAgICAjIENoZWNrIGlmIHRraW50ZXIgZGlyZWN0b3J5IGV4aXN0cwogICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyh0a2ludGVyX3BhdGgpOgogICAgICAgICAgICAgICAgdGNsX3BhdGggPSBvcy5wYXRoLmpvaW4odGtpbnRlcl9wYXRoLCAndGNsJykKICAgICAgICAgICAgICAgIHRrX3BhdGggPSBvcy5wYXRoLmpvaW4odGtpbnRlcl9wYXRoLCAndGsnKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAjIFZlcmlmeSBUY2wvVGsgZGlyZWN0b3JpZXMgZXhpc3QgYW5kIGNvbnRhaW4gaW5pdCBmaWxlcwogICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHModGNsX3BhdGgpIGFuZCBvcy5wYXRoLmV4aXN0cyh0a19wYXRoKToKICAgICAgICAgICAgICAgICAgICBpbml0X3RjbCA9IG9zLnBhdGguam9pbih0Y2xfcGF0aCwgJ2luaXQudGNsJykKICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhpbml0X3RjbCk6CiAgICAgICAgICAgICAgICAgICAgICAgICMgQ1JJVElDQUw6IFNldCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gdXNlIHN5c3RlbSBUY2wvVGsKICAgICAgICAgICAgICAgICAgICAgICAgIyBVc2UgYWJzb2x1dGUgcGF0aHMgdG8gZW5zdXJlIHRoZXkncmUgdXNlZAogICAgICAgICAgICAgICAgICAgICAgICB0Y2xfYWJzID0gb3MucGF0aC5hYnNwYXRoKHRjbF9wYXRoKQogICAgICAgICAgICAgICAgICAgICAgICB0a19hYnMgPSBvcy5wYXRoLmFic3BhdGgodGtfcGF0aCkKICAgICAgICAgICAgICAgICAgICAgICAgb3MuZW52aXJvblsnVENMX0xJQlJBUlknXSA9IHRjbF9hYnMKICAgICAgICAgICAgICAgICAgICAgICAgb3MuZW52aXJvblsnVEtfTElCUkFSWSddID0gdGtfYWJzCiAgICAgICAgICAgICAgICAgICAgICAgICMgQ2xlYXIgYW55IFB5SW5zdGFsbGVyIHRlbXAgZGlyZWN0b3J5IHJlZmVyZW5jZXMKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ1RDTF9MSUJSQVJZX1BBVEgnIGluIG9zLmVudmlyb246CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWwgb3MuZW52aXJvblsnVENMX0xJQlJBUllfUEFUSCddCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICdUS19MSUJSQVJZX1BBVEgnIGluIG9zLmVudmlyb246CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWwgb3MuZW52aXJvblsnVEtfTElCUkFSWV9QQVRIJ10KICAgICAgICAgICAgICAgICAgICAgICAgIyBGb3JjZSB0a2ludGVyIHRvIHVzZSB0aGVzZSBwYXRocwogICAgICAgICAgICAgICAgICAgICAgICBvcy5lbnZpcm9uWydUQ0xfTElCUkFSWV9QQVRIJ10gPSB0Y2xfYWJzCiAgICAgICAgICAgICAgICAgICAgICAgIG9zLmVudmlyb25bJ1RLX0xJQlJBUllfUEFUSCddID0gdGtfYWJzCmV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICMgSWYgZGV0ZWN0aW9uIGZhaWxzLCB0cnkgdG8gY29udGludWUgLSBidXQgbG9nIGlmIHBvc3NpYmxlCiAgICB0cnk6CiAgICAgICAgaW1wb3J0IHRyYWNlYmFjawogICAgICAgIGVycm9yX2xvZyA9IG9zLnBhdGguam9pbihvcy5wYXRoLmRpcm5hbWUoX19maWxlX18pLCAndGNsX3RrX2RldGVjdGlvbl9lcnJvci5sb2cnKQogICAgICAgIHdpdGggb3BlbihlcnJvcl9sb2csICd3JykgYXMgZjoKICAgICAgICAgICAgZi53cml0ZShmIlRjbC9UayBkZXRlY3Rpb24gZXJyb3I6IHtlfVxuIikKICAgICAgICAgICAgZi53cml0ZSh0cmFjZWJhY2suZm9ybWF0X2V4YygpKQogICAgZXhjZXB0OgogICAgICAgIHBhc3MgICMgQ2FuJ3QgZXZlbiBsb2csIGp1c3QgY29udGludWUKCmZyb20gdGtpbnRlciBpbXBvcnQgKgpmcm9tIHRraW50ZXIgaW1wb3J0IHR0aywgbWVzc2FnZWJveAoKIyBHZXQgdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGlzIHNjcmlwdCBpcyBsb2NhdGVkICh3b3JrcyBmb3IgYm90aCAuZXhlIGFuZCAucHkpCmRlZiBnZXRfYmFzZV9kaXIoKToKICAgICIiIkdldCB0aGUgYmFzZSBkaXJlY3RvcnkgLSBzYW1lIGZvbGRlciBhcyB0aGlzIHNjcmlwdC4iIiIKICAgIGlmIGdldGF0dHIoc3lzLCAnZnJvemVuJywgRmFsc2UpOgogICAgICAgICMgUnVubmluZyBhcyBjb21waWxlZCAuZXhlIC0gdXNlIHRoZSBkaXJlY3Rvcnkgd2hlcmUgLmV4ZSBpcyBsb2NhdGVkCiAgICAgICAgcmV0dXJuIG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgoc3lzLmV4ZWN1dGFibGUpKQogICAgZWxzZToKICAgICAgICAjIFJ1bm5pbmcgYXMgc2NyaXB0IC0gdXNlIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIHNjcmlwdCBpcyBsb2NhdGVkCiAgICAgICAgcmV0dXJuIG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgoX19maWxlX18pKQoKQkFTRV9ESVIgPSBnZXRfYmFzZV9kaXIoKQpDT05GSUdfRklMRSA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImdhbWVzX2NvbmZpZy5qc29uIikKU1RBVEVfSlNPTiA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYXRoX3N0YXRlLmpzb24iKQpMT0NLX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkYWVtb24ubG9jayIpClJFQURZX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkYWVtb24ucmVhZHkiKSAgIyBTaWduYWwgZmlsZSBjcmVhdGVkIGFmdGVyIGZ1bGwgaW5pdGlhbGl6YXRpb24KU1RPUF9GSUxFID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiU1RPUCIpCkdVSV9ERUJVR19MT0cgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJndWlfZGVidWcubG9nIikgICMgRGVidWcgbG9nIGZvciBHVUkKIyBQcmltYXJ5IHNjcmlwdCBwYXRoIChuZXcgbmFtaW5nKQpTQ1JJUFRfUEFUSCA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgIm11bHRpX2dhbWVfZGVhdGhfY291bnRlci5weSIpCiMgQmFja3dhcmQgY29tcGF0aWJpbGl0eTogYWxzbyB0cnkgdGhlIG9sZCBuYW1lIGlmIG5lZWRlZAppZiBub3Qgb3MucGF0aC5leGlzdHMoU0NSSVBUX1BBVEgpOgogICAgU0NSSVBUX1BBVEggPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJtdWx0aV9nYW1lX2RlYXRoX2NvdW50ZXIucHkiKQpERUFUSF9UWFQgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkZWF0aF9jb3VudGVyLnR4dCIpCgoKY2xhc3MgRGVhdGhDb3VudGVyR1VJOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHJvb3QpOgogICAgICAgIHNlbGYucm9vdCA9IHJvb3QKICAgICAgICBzZWxmLnJvb3QudGl0bGUoIkRlYXRoIENvdW50ZXIgQ29udHJvbCIpCiAgICAgICAgc2VsZi5yb290Lmdlb21ldHJ5KCI0MDB4MzQwIikKICAgICAgICBzZWxmLnJvb3QucmVzaXphYmxlKEZhbHNlLCBGYWxzZSkKICAgICAgICAKICAgICAgICAjIFZhcmlhYmxlcwogICAgICAgIHNlbGYuZGFlbW9uX3Byb2Nlc3MgPSBOb25lCiAgICAgICAgc2VsZi5tb25pdG9yaW5nID0gRmFsc2UKICAgICAgICAKICAgICAgICAjIENyZWF0ZSBVSQogICAgICAgIHNlbGYuY3JlYXRlX3VpKCkKICAgICAgICAKICAgICAgICAjIENoZWNrIGluaXRpYWwgc3RhdGUgKGFmdGVyIFVJIGlzIGNyZWF0ZWQpCiAgICAgICAgc2VsZi51cGRhdGVfc3RhdHVzKCkKICAgICAgICAKICAgICAgICAjIFN0YXJ0IG1vbml0b3JpbmcgdGhyZWFkCiAgICAgICAgc2VsZi5zdGFydF9tb25pdG9yaW5nKCkKICAgIAogICAgZGVmIGNyZWF0ZV91aShzZWxmKToKICAgICAgICAjIE1haW4gZnJhbWUKICAgICAgICBtYWluX2ZyYW1lID0gdHRrLkZyYW1lKHNlbGYucm9vdCwgcGFkZGluZz0iMTAiKQogICAgICAgIG1haW5fZnJhbWUuZ3JpZChyb3c9MCwgY29sdW1uPTAsIHN0aWNreT0oVywgRSwgTiwgUykpCiAgICAgICAgCiAgICAgICAgIyBUaXRsZQogICAgICAgIHRpdGxlX2xhYmVsID0gdHRrLkxhYmVsKG1haW5fZnJhbWUsIHRleHQ9IkRlYXRoIENvdW50ZXIiLCBmb250PSgiQXJpYWwiLCAxNiwgImJvbGQiKSkKICAgICAgICB0aXRsZV9sYWJlbC5ncmlkKHJvdz0wLCBjb2x1bW49MCwgY29sdW1uc3Bhbj0yLCBwYWR5PSgwLCAyMCkpCiAgICAgICAgCiAgICAgICAgIyBTdGF0dXMgZnJhbWUKICAgICAgICBzdGF0dXNfZnJhbWUgPSB0dGsuTGFiZWxGcmFtZShtYWluX2ZyYW1lLCB0ZXh0PSJTdGF0dXMiLCBwYWRkaW5nPSIxMCIpCiAgICAgICAgc3RhdHVzX2ZyYW1lLmdyaWQocm93PTEsIGNvbHVtbj0wLCBjb2x1bW5zcGFuPTIsIHN0aWNreT0oVywgRSksIHBhZHk9KDAsIDEwKSkKICAgICAgICAKICAgICAgICAjIFN0YXR1cyBhbmQgdG90YWwgZGVhdGhzIGluIGEgcm93CiAgICAgICAgc3RhdHVzX3JvdyA9IHR0ay5GcmFtZShzdGF0dXNfZnJhbWUpCiAgICAgICAgc3RhdHVzX3Jvdy5ncmlkKHJvdz0wLCBjb2x1bW49MCwgc3RpY2t5PShXLCBFKSkKICAgICAgICBzdGF0dXNfZnJhbWUuY29sdW1uY29uZmlndXJlKDAsIHdlaWdodD0xKQogICAgICAgIAogICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsID0gdHRrLkxhYmVsKHN0YXR1c19yb3csIHRleHQ9IkNoZWNraW5nLi4uIiwgZm9udD0oIkFyaWFsIiwgMTApKQogICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsLmdyaWQocm93PTAsIGNvbHVtbj0wLCBzdGlja3k9VykKICAgICAgICAKICAgICAgICAjIFRvdGFsIGRlYXRocyBsYWJlbAogICAgICAgIHNlbGYudG90YWxfZGVhdGhzX2xhYmVsID0gdHRrLkxhYmVsKHN0YXR1c19yb3csIHRleHQ9IlRvdGFsIERlYXRoczogMCIsIGZvbnQ9KCJBcmlhbCIsIDEwLCAiYm9sZCIpKQogICAgICAgIHNlbGYudG90YWxfZGVhdGhzX2xhYmVsLmdyaWQocm93PTAsIGNvbHVtbj0xLCBzdGlja3k9RSwgcGFkeD0oMjAsIDApKQogICAgICAgIAogICAgICAgICMgRGVhdGggY291bnQgZGlzcGxheSAtIExhcmdlIGNsaWNrYWJsZSBidXR0b24KICAgICAgICBjb3VudF9mcmFtZSA9IHR0ay5GcmFtZShtYWluX2ZyYW1lKQogICAgICAgIGNvdW50X2ZyYW1lLmdyaWQocm93PTIsIGNvbHVtbj0wLCBjb2x1bW5zcGFuPTIsIHN0aWNreT0oVywgRSksIHBhZHk9KDAsIDEwKSkKICAgICAgICAKICAgICAgICAjIENyZWF0ZSBhIGxhcmdlIGJ1dHRvbiB0aGF0IHNob3dzIGRlYXRoIGNvdW50IGFuZCBnYW1lIG5hbWUKICAgICAgICAjIFVzZSBhIGZyYW1lIHdpdGggbGFiZWwgZm9yIGJldHRlciB0ZXh0IGNvbnRyb2wKICAgICAgICBidXR0b25fY29udGFpbmVyID0gRnJhbWUoY291bnRfZnJhbWUsIGJnPSIjZjBmMGYwIiwgcmVsaWVmPVJBSVNFRCwgYmQ9MykKICAgICAgICBidXR0b25fY29udGFpbmVyLmdyaWQocm93PTAsIGNvbHVtbj0wLCBzdGlja3k9KFcsIEUpLCBpcGFkeD0xMCwgaXBhZHk9MTApCiAgICAgICAgY291bnRfZnJhbWUuY29sdW1uY29uZmlndXJlKDAsIHdlaWdodD0xKQogICAgICAgIAogICAgICAgICMgRGVhdGggY291bnQgbGFiZWwgKGxhcmdlKQogICAgICAgIHNlbGYuZGVhdGhfY291bnRfbGFiZWwgPSBMYWJlbCgKICAgICAgICAgICAgYnV0dG9uX2NvbnRhaW5lciwKICAgICAgICAgICAgdGV4dD0iMCIsCiAgICAgICAgICAgIGZvbnQ9KCJBcmlhbCIsIDI0LCAiYm9sZCIpLAogICAgICAgICAgICBiZz0iI2YwZjBmMCIsCiAgICAgICAgICAgIGZnPSJibGFjayIKICAgICAgICApCiAgICAgICAgc2VsZi5kZWF0aF9jb3VudF9sYWJlbC5wYWNrKHBhZHk9KDEwLCA1KSkKICAgICAgICAKICAgICAgICAjIEdhbWUgbmFtZSBsYWJlbCAoc21hbGxlciwgd3JhcHMpCiAgICAgICAgc2VsZi5nYW1lX25hbWVfbGFiZWwgPSBMYWJlbCgKICAgICAgICAgICAgYnV0dG9uX2NvbnRhaW5lciwKICAgICAgICAgICAgdGV4dD0iTm8gZ2FtZSBzZWxlY3RlZCIsCiAgICAgICAgICAgIGZvbnQ9KCJBcmlhbCIsIDEwKSwKICAgICAgICAgICAgYmc9IiNmMGYwZjAiLAogICAgICAgICAgICBmZz0iYmxhY2siLAogICAgICAgICAgICB3cmFwbGVuZ3RoPTMyMCwKICAgICAgICAgICAganVzdGlmeT1DRU5URVIKICAgICAgICApCiAgICAgICAgc2VsZi5nYW1lX25hbWVfbGFiZWwucGFjayhwYWR5PSgwLCAxMCkpCiAgICAgICAgCiAgICAgICAgIyBNYWtlIHRoZSB3aG9sZSBjb250YWluZXIgY2xpY2thYmxlCiAgICAgICAgc2VsZi5kZWF0aF9jb3VudF9idXR0b24gPSBidXR0b25fY29udGFpbmVyCiAgICAgICAgIyBVc2UgQnV0dG9uUmVsZWFzZS0xIGZvciBiZXR0ZXIgY2xpY2sgZGV0ZWN0aW9uCiAgICAgICAgYnV0dG9uX2NvbnRhaW5lci5iaW5kKCI8QnV0dG9uUmVsZWFzZS0xPiIsIGxhbWJkYSBlOiBzZWxmLmN5Y2xlX2dhbWUoKSkKICAgICAgICBidXR0b25fY29udGFpbmVyLmJpbmQoIjxFbnRlcj4iLCBsYW1iZGEgZTogc2VsZi5vbl9idXR0b25fZW50ZXIoYnV0dG9uX2NvbnRhaW5lcikpCiAgICAgICAgYnV0dG9uX2NvbnRhaW5lci5iaW5kKCI8TGVhdmU+IiwgbGFtYmRhIGU6IHNlbGYub25fYnV0dG9uX2xlYXZlKGJ1dHRvbl9jb250YWluZXIpKQogICAgICAgIHNlbGYuZGVhdGhfY291bnRfbGFiZWwuYmluZCgiPEJ1dHRvblJlbGVhc2UtMT4iLCBsYW1iZGEgZTogc2VsZi5jeWNsZV9nYW1lKCkpCiAgICAgICAgc2VsZi5nYW1lX25hbWVfbGFiZWwuYmluZCgiPEJ1dHRvblJlbGVhc2UtMT4iLCBsYW1iZGEgZTogc2VsZi5jeWNsZV9nYW1lKCkpCiAgICAgICAgYnV0dG9uX2NvbnRhaW5lci5jb25maWcoY3Vyc29yPSJoYW5kMiIpCiAgICAgICAgc2VsZi5kZWF0aF9jb3VudF9sYWJlbC5jb25maWcoY3Vyc29yPSJoYW5kMiIpCiAgICAgICAgc2VsZi5nYW1lX25hbWVfbGFiZWwuY29uZmlnKGN1cnNvcj0iaGFuZDIiKQogICAgICAgIAogICAgICAgICMgQ29udHJvbCBidXR0b25zIGZyYW1lCiAgICAgICAgY29udHJvbF9mcmFtZSA9IHR0ay5MYWJlbEZyYW1lKG1haW5fZnJhbWUsIHRleHQ9IkNvbnRyb2wiLCBwYWRkaW5nPSIxMCIpCiAgICAgICAgY29udHJvbF9mcmFtZS5ncmlkKHJvdz0zLCBjb2x1bW49MCwgY29sdW1uc3Bhbj0yLCBzdGlja3k9KFcsIEUpLCBwYWR5PSgwLCAwKSkKICAgICAgICAKICAgICAgICBzZWxmLnN0YXJ0X2J1dHRvbiA9IHR0ay5CdXR0b24oY29udHJvbF9mcmFtZSwgdGV4dD0iU3RhcnQgRGFlbW9uIiwgY29tbWFuZD1zZWxmLnN0YXJ0X2RhZW1vbiwgd2lkdGg9MTgpCiAgICAgICAgc2VsZi5zdGFydF9idXR0b24uZ3JpZChyb3c9MCwgY29sdW1uPTAsIHBhZHg9KDAsIDUpKQogICAgICAgIAogICAgICAgIHNlbGYuc3RvcF9idXR0b24gPSB0dGsuQnV0dG9uKGNvbnRyb2xfZnJhbWUsIHRleHQ9IlN0b3AgRGFlbW9uIiwgY29tbWFuZD1zZWxmLnN0b3BfZGFlbW9uLCB3aWR0aD0xOCwgc3RhdGU9RElTQUJMRUQpCiAgICAgICAgc2VsZi5zdG9wX2J1dHRvbi5ncmlkKHJvdz0wLCBjb2x1bW49MSwgcGFkeD0oNSwgMCkpCiAgICAgICAgCiAgICAgICAgIyBMb2FkIGF2YWlsYWJsZSBnYW1lcwogICAgICAgIHNlbGYubG9hZF9nYW1lcygpCiAgICAKICAgIGRlZiBvbl9idXR0b25fZW50ZXIoc2VsZiwgY29udGFpbmVyKToKICAgICAgICAiIiJDaGFuZ2UgYmFja2dyb3VuZCBvbiBob3Zlci4iIiIKICAgICAgICBjb250YWluZXIuY29uZmlnKGJnPSIjZTBlMGUwIikKICAgICAgICBzZWxmLmRlYXRoX2NvdW50X2xhYmVsLmNvbmZpZyhiZz0iI2UwZTBlMCIpCiAgICAgICAgc2VsZi5nYW1lX25hbWVfbGFiZWwuY29uZmlnKGJnPSIjZTBlMGUwIikKICAgIAogICAgZGVmIG9uX2J1dHRvbl9sZWF2ZShzZWxmLCBjb250YWluZXIpOgogICAgICAgICIiIlJlc3RvcmUgYmFja2dyb3VuZCBvbiBsZWF2ZS4iIiIKICAgICAgICBjb250YWluZXIuY29uZmlnKGJnPSIjZjBmMGYwIikKICAgICAgICBzZWxmLmRlYXRoX2NvdW50X2xhYmVsLmNvbmZpZyhiZz0iI2YwZjBmMCIpCiAgICAgICAgc2VsZi5nYW1lX25hbWVfbGFiZWwuY29uZmlnKGJnPSIjZjBmMGYwIikKICAgIAogICAgZGVmIGxvYWRfZ2FtZXMoc2VsZik6CiAgICAgICAgIiIiTG9hZCBhdmFpbGFibGUgZ2FtZXMgZnJvbSBjb25maWcuIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhDT05GSUdfRklMRSk6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oQ09ORklHX0ZJTEUsICJyIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBqc29uLmxvYWQoZikKICAgICAgICAgICAgICAgIHNlbGYuYXZhaWxhYmxlX2dhbWVzID0gbGlzdChjb25maWcuZ2V0KCJnYW1lcyIsIHt9KS5rZXlzKCkpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzZWxmLmF2YWlsYWJsZV9nYW1lcyA9IFsiRWxkZW4gUmluZyIsICJEYXJrIFNvdWxzIDMiLCAiRGFyayBTb3VscyBSZW1hc3RlcmVkIiwgIlNla2lybyJdCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBzZWxmLmF2YWlsYWJsZV9nYW1lcyA9IFsiRWxkZW4gUmluZyIsICJEYXJrIFNvdWxzIDMiLCAiRGFyayBTb3VscyBSZW1hc3RlcmVkIiwgIlNla2lybyJdCiAgICAgICAgCiAgICAgICAgaWYgbm90IHNlbGYuYXZhaWxhYmxlX2dhbWVzOgogICAgICAgICAgICBzZWxmLmF2YWlsYWJsZV9nYW1lcyA9IFsiTm8gZ2FtZXMgY29uZmlndXJlZCJdCiAgICAKICAgIGRlZiBnZXRfY3VycmVudF9nYW1lKHNlbGYpOgogICAgICAgICIiIkdldCBjdXJyZW50IGdhbWUgZnJvbSBzdGF0ZSBvciBjb25maWcuIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICAjIFRyeSBzdGF0ZSBmaWxlIGZpcnN0CiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKFNUQVRFX0pTT04pOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKFNUQVRFX0pTT04sICJyIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGpzb24ubG9hZChmKQogICAgICAgICAgICAgICAgZ2FtZSA9IHN0YXRlLmdldCgiY3VycmVudF9nYW1lIikKICAgICAgICAgICAgICAgIGlmIGdhbWU6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdhbWUKICAgICAgICAgICAgCiAgICAgICAgICAgICMgRmFsbCBiYWNrIHRvIGNvbmZpZwogICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhDT05GSUdfRklMRSk6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oQ09ORklHX0ZJTEUsICJyIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBqc29uLmxvYWQoZikKICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuZ2V0KCJjdXJyZW50X2dhbWUiLCBzZWxmLmF2YWlsYWJsZV9nYW1lc1swXSBpZiBzZWxmLmF2YWlsYWJsZV9nYW1lcyBlbHNlICJVbmtub3duIikKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICByZXR1cm4gc2VsZi5hdmFpbGFibGVfZ2FtZXNbMF0gaWYgc2VsZi5hdmFpbGFibGVfZ2FtZXMgZWxzZSAiVW5rbm93biIKICAgIAogICAgZGVmIGdldF9kZWF0aF9jb3VudChzZWxmLCBnYW1lX25hbWUpOgogICAgICAgICIiIkdldCBkZWF0aCBjb3VudCBmb3IgYSBzcGVjaWZpYyBnYW1lLiIiIgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoU1RBVEVfSlNPTik6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oU1RBVEVfSlNPTiwgInIiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgIHN0YXRlID0ganNvbi5sb2FkKGYpCiAgICAgICAgICAgICAgICBnYW1lX2RlYXRocyA9IHN0YXRlLmdldCgiZ2FtZV9kZWF0aHMiLCB7fSkKICAgICAgICAgICAgICAgIHJldHVybiBnYW1lX2RlYXRocy5nZXQoZ2FtZV9uYW1lLCAwKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIHJldHVybiAwCiAgICAKICAgIGRlZiBnZXRfdG90YWxfZGVhdGhzKHNlbGYpOgogICAgICAgICIiIkdldCB0b3RhbCBkZWF0aHMgYWNyb3NzIGFsbCBnYW1lcy4iIiIKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKFNUQVRFX0pTT04pOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKFNUQVRFX0pTT04sICJyIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGpzb24ubG9hZChmKQogICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmdldCgidG90YWxfZGVhdGhzIiwgMCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICByZXR1cm4gMAogICAgCiAgICBkZWYgY3ljbGVfZ2FtZShzZWxmLCBldmVudD1Ob25lKToKICAgICAgICAiIiJDeWNsZSB0byB0aGUgbmV4dCBnYW1lIGluIHRoZSBsaXN0LiIiIgogICAgICAgIGlmIG5vdCBzZWxmLmF2YWlsYWJsZV9nYW1lcyBvciBsZW4oc2VsZi5hdmFpbGFibGVfZ2FtZXMpID09IDA6CiAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd3dhcm5pbmcoIk5vIEdhbWVzIiwgIk5vIGdhbWVzIGNvbmZpZ3VyZWQuIikKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgCiAgICAgICAgY3VycmVudF9nYW1lID0gc2VsZi5nZXRfY3VycmVudF9nYW1lKCkKICAgICAgICAKICAgICAgICAjIEZpbmQgY3VycmVudCBpbmRleAogICAgICAgIHRyeToKICAgICAgICAgICAgY3VycmVudF9pbmRleCA9IHNlbGYuYXZhaWxhYmxlX2dhbWVzLmluZGV4KGN1cnJlbnRfZ2FtZSkKICAgICAgICAgICAgbmV4dF9pbmRleCA9IChjdXJyZW50X2luZGV4ICsgMSkgJSBsZW4oc2VsZi5hdmFpbGFibGVfZ2FtZXMpCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBuZXh0X2luZGV4ID0gMAogICAgICAgIAogICAgICAgIG5ld19nYW1lID0gc2VsZi5hdmFpbGFibGVfZ2FtZXNbbmV4dF9pbmRleF0KICAgICAgICAKICAgICAgICAjIFN3aXRjaCBnYW1lIHVzaW5nIHRoZSBtYW51YWwgc3dpdGNoIHNjcmlwdAogICAgICAgIHRyeToKICAgICAgICAgICAgc3dpdGNoX3NjcmlwdCA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgInN3aXRjaF9nYW1lX21hbnVhbC5weSIpCiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKHN3aXRjaF9zY3JpcHQpOgogICAgICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5ydW4oCiAgICAgICAgICAgICAgICAgICAgW3N5cy5leGVjdXRhYmxlLCBzd2l0Y2hfc2NyaXB0LCBuZXdfZ2FtZV0sCiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICB0ZXh0PVRydWUsCiAgICAgICAgICAgICAgICAgICAgY3dkPUJBU0VfRElSCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBpZiByZXN1bHQucmV0dXJuY29kZSA9PSAwOgogICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlX3N0YXR1cygpCiAgICAgICAgICAgICAgICAgICAgIyBTaWxlbnRseSBzd2l0Y2ggLSBubyBwb3B1cAogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAjIEZhbGxiYWNrIHRvIGRpcmVjdCBzd2l0Y2ggaWYgc2NyaXB0IGZhaWxzCiAgICAgICAgICAgICAgICAgICAgc2VsZi5zd2l0Y2hfZ2FtZV9kaXJlY3QobmV3X2dhbWUpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAjIEZhbGxiYWNrOiBkaXJlY3RseSB1cGRhdGUgY29uZmlnCiAgICAgICAgICAgICAgICBzZWxmLnN3aXRjaF9nYW1lX2RpcmVjdChuZXdfZ2FtZSkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICMgRmFsbGJhY2sgdG8gZGlyZWN0IHN3aXRjaCBvbiBhbnkgZXJyb3IKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgc2VsZi5zd2l0Y2hfZ2FtZV9kaXJlY3QobmV3X2dhbWUpCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgIAogICAgZGVmIHN3aXRjaF9nYW1lX2RpcmVjdChzZWxmLCBnYW1lX25hbWUpOgogICAgICAgICIiIkRpcmVjdGx5IHN3aXRjaCBnYW1lIGJ5IHVwZGF0aW5nIGNvbmZpZyBhbmQgc3RhdGUuIiIiCiAgICAgICAgdHJ5OgogICAgICAgICAgICAjIFVwZGF0ZSBjb25maWcKICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoQ09ORklHX0ZJTEUpOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKENPTkZJR19GSUxFLCAiciIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0ganNvbi5sb2FkKGYpCiAgICAgICAgICAgICAgICBjb25maWdbImN1cnJlbnRfZ2FtZSJdID0gZ2FtZV9uYW1lCiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oQ09ORklHX0ZJTEUsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBqc29uLmR1bXAoY29uZmlnLCBmLCBpbmRlbnQ9MikKICAgICAgICAgICAgCiAgICAgICAgICAgICMgVXBkYXRlIHN0YXRlCiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKFNUQVRFX0pTT04pOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKFNUQVRFX0pTT04sICJyIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IGpzb24ubG9hZChmKQogICAgICAgICAgICAgICAgc3RhdGVbImN1cnJlbnRfZ2FtZSJdID0gZ2FtZV9uYW1lCiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oU1RBVEVfSlNPTiwgInciLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgIGpzb24uZHVtcChzdGF0ZSwgZiwgaW5kZW50PTIpCiAgICAgICAgICAgIAogICAgICAgICAgICAjIFVwZGF0ZSB0ZXh0IGZpbGUKICAgICAgICAgICAgZ2FtZV9kZWF0aHMgPSBzZWxmLmdldF9kZWF0aF9jb3VudChnYW1lX25hbWUpCiAgICAgICAgICAgIHdpdGggb3BlbihERUFUSF9UWFQsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgIGYud3JpdGUoc3RyKGdhbWVfZGVhdGhzKSkKICAgICAgICAgICAgCiAgICAgICAgICAgIHNlbGYudXBkYXRlX3N0YXR1cygpCiAgICAgICAgICAgICMgU2lsZW50bHkgc3dpdGNoIC0gbm8gcG9wdXAKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2Vycm9yKCJFcnJvciIsIGYiRmFpbGVkIHRvIHN3aXRjaCBnYW1lOiB7ZX0iKQogICAgCiAgICBkZWYgaXNfZGFlbW9uX3J1bm5pbmcoc2VsZik6CiAgICAgICAgIiIiQ2hlY2sgaWYgZGFlbW9uIGlzIHJ1bm5pbmcgLSBjaGVjayBib3RoIGxvY2sgZmlsZSBhbmQgcHJvY2Vzcy4iIiIKICAgICAgICAjIENoZWNrIGxvY2sgZmlsZQogICAgICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhMT0NLX0ZJTEUpOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICAKICAgICAgICAjIFZlcmlmeSB0aGUgcHJvY2VzcyBpbiB0aGUgbG9jayBmaWxlIGlzIGFjdHVhbGx5IHJ1bm5pbmcKICAgICAgICB0cnk6CiAgICAgICAgICAgIHdpdGggb3BlbihMT0NLX0ZJTEUsICJyIikgYXMgZjoKICAgICAgICAgICAgICAgIHBpZF9zdHIgPSBmLnJlYWQoKS5zdHJpcCgpCiAgICAgICAgICAgIGlmIHBpZF9zdHI6CiAgICAgICAgICAgICAgICBwaWQgPSBpbnQocGlkX3N0cikKICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgcHJvY2VzcyBleGlzdHMKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBpbXBvcnQgcHN1dGlsCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBzdXRpbC5waWRfZXhpc3RzKHBpZCkKICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAjIEZhbGxiYWNrOiB1c2UgdGFza2xpc3Qgb24gV2luZG93cwogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5ydW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbInRhc2tsaXN0IiwgIi9GSSIsIGYiUElEIGVxIHtwaWR9Il0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dD0yCiAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYie3BpZH0iIGluIHJlc3VsdC5zdGRvdXQKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICMgSWYgd2UgY2FuJ3QgY2hlY2ssIGFzc3VtZSBpdCdzIHJ1bm5pbmcgaWYgbG9jayBmaWxlIGV4aXN0cwogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgIyBJZiB3ZSBjYW4ndCByZWFkIHRoZSBsb2NrIGZpbGUsIGFzc3VtZSBpdCdzIG5vdCBydW5uaW5nCiAgICAgICAgICAgIHJldHVybiBGYWxzZQogICAgICAgIAogICAgICAgIHJldHVybiBUcnVlCiAgICAKICAgIGRlZiBmaW5kX3B5dGhvbl9leGVjdXRhYmxlKHNlbGYpOgogICAgICAgICIiIkZpbmQgUHl0aG9uIGV4ZWN1dGFibGUsIGNoZWNraW5nIFBBVEggYW5kIGNvbW1vbiBpbnN0YWxsYXRpb24gbG9jYXRpb25zLgogICAgICAgIENvbXByZWhlbnNpdmUgc2VhcmNoIGZvciBnZW5lcmFsIHB1YmxpYyB1c2UuIiIiCiAgICAgICAgIyBJZiBydW5uaW5nIGFzIGEgc2NyaXB0IChub3QgZnJvemVuKSwgdXNlIHN5cy5leGVjdXRhYmxlCiAgICAgICAgaWYgbm90IGdldGF0dHIoc3lzLCAnZnJvemVuJywgRmFsc2UpOgogICAgICAgICAgICByZXR1cm4gc3lzLmV4ZWN1dGFibGUKICAgICAgICAKICAgICAgICAjIElmIHJ1bm5pbmcgYXMgUHlJbnN0YWxsZXIgZXhlLCB3ZSBuZWVkIHRvIGZpbmQgUHl0aG9uCiAgICAgICAgIyBNZXRob2QgMTogVHJ5ICdweXRob24nIGNvbW1hbmQgKGlmIGluIFBBVEgpIC0gbW9zdCByZWxpYWJsZQogICAgICAgIHRyeToKICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5ydW4oWydweXRob24nLCAnLS12ZXJzaW9uJ10sIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgdGV4dD1UcnVlLCB0aW1lb3V0PTIpCiAgICAgICAgICAgIGlmIHJlc3VsdC5yZXR1cm5jb2RlID09IDA6CiAgICAgICAgICAgICAgICByZXR1cm4gJ3B5dGhvbicKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICAjIE1ldGhvZCAyOiBUcnkgJ3B5JyBsYXVuY2hlciAoV2luZG93cyBQeXRob24gbGF1bmNoZXIpIC0gYWxzbyByZWxpYWJsZQogICAgICAgIHRyeToKICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5ydW4oWydweScsICctLXZlcnNpb24nXSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLCB0ZXh0PVRydWUsIHRpbWVvdXQ9MikKICAgICAgICAgICAgaWYgcmVzdWx0LnJldHVybmNvZGUgPT0gMDoKICAgICAgICAgICAgICAgIHJldHVybiAncHknCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBwYXNzCiAgICAgICAgCiAgICAgICAgIyBNZXRob2QgMzogU2VhcmNoIFdpbmRvd3MgUmVnaXN0cnkgZm9yIFB5dGhvbiBpbnN0YWxsYXRpb25zCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpbXBvcnQgd2lucmVnCiAgICAgICAgICAgICMgQ2hlY2sgYm90aCAzMi1iaXQgYW5kIDY0LWJpdCByZWdpc3RyeQogICAgICAgICAgICBmb3IgYXJjaCBpbiBbd2lucmVnLktFWV9XT1c2NF82NEtFWSwgd2lucmVnLktFWV9XT1c2NF8zMktFWV06CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgIyBDaGVjayBIS0VZX0xPQ0FMX01BQ0hJTkUKICAgICAgICAgICAgICAgICAgICBrZXkgPSB3aW5yZWcuT3BlbktleSh3aW5yZWcuSEtFWV9MT0NBTF9NQUNISU5FLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIiU09GVFdBUkVcUHl0aG9uXFB5dGhvbkNvcmUiLCAwLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lucmVnLktFWV9SRUFEIHwgYXJjaCkKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICMgR2V0IGFsbCBpbnN0YWxsZWQgUHl0aG9uIHZlcnNpb25zCiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwCiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIFRydWU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IHdpbnJlZy5FbnVtS2V5KGtleSwgaSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YWxsX3BhdGhfa2V5ID0gd2lucmVnLk9wZW5LZXkoa2V5LCBmInt2ZXJzaW9ufVxcSW5zdGFsbFBhdGgiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFsbF9wYXRoID0gd2lucmVnLlF1ZXJ5VmFsdWVFeChpbnN0YWxsX3BhdGhfa2V5LCAiIilbMF0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX2V4ZSA9IG9zLnBhdGguam9pbihpbnN0YWxsX3BhdGgsICJweXRob24uZXhlIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMocHl0aG9uX2V4ZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5yZWcuQ2xvc2VLZXkoaW5zdGFsbF9wYXRoX2tleSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbnJlZy5DbG9zZUtleShrZXkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHl0aG9uX2V4ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5yZWcuQ2xvc2VLZXkoaW5zdGFsbF9wYXRoX2tleSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDEKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBPU0Vycm9yOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgICAgICAgIHdpbnJlZy5DbG9zZUtleShrZXkpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5yZWcuQ2xvc2VLZXkoa2V5KQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgICAgICMgTWV0aG9kIDQ6IFNlYXJjaCBjb21tb24gaW5zdGFsbGF0aW9uIGxvY2F0aW9ucwogICAgICAgIHVzZXJwcm9maWxlID0gb3MuZ2V0ZW52KCdVU0VSUFJPRklMRScsICcnKQogICAgICAgIHByb2dyYW1maWxlcyA9IG9zLmdldGVudignUHJvZ3JhbUZpbGVzJywgcidDOlxQcm9ncmFtIEZpbGVzJykKICAgICAgICBwcm9ncmFtZmlsZXNfeDg2ID0gb3MuZ2V0ZW52KCdQcm9ncmFtRmlsZXMoeDg2KScsIHInQzpcUHJvZ3JhbSBGaWxlcyAoeDg2KScpCiAgICAgICAgCiAgICAgICAgc2VhcmNoX3BhdGhzID0gW10KICAgICAgICAKICAgICAgICAjIFVzZXIgQXBwRGF0YSBsb2NhdGlvbnMgKG1vc3QgY29tbW9uIGZvciBQeXRob24gMy44KykKICAgICAgICBpZiB1c2VycHJvZmlsZToKICAgICAgICAgICAgYXBwZGF0YV9sb2NhbCA9IG9zLnBhdGguam9pbih1c2VycHJvZmlsZSwgciJBcHBEYXRhXExvY2FsXFByb2dyYW1zXFB5dGhvbiIpCiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKGFwcGRhdGFfbG9jYWwpOgogICAgICAgICAgICAgICAgIyBTZWFyY2ggYWxsIFB5dGhvbiB2ZXJzaW9ucyBpbiB0aGlzIGRpcmVjdG9yeQogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGZvciBpdGVtIGluIG9zLmxpc3RkaXIoYXBwZGF0YV9sb2NhbCk6CiAgICAgICAgICAgICAgICAgICAgICAgIHB5dGhvbl9kaXIgPSBvcy5wYXRoLmpvaW4oYXBwZGF0YV9sb2NhbCwgaXRlbSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihweXRob25fZGlyKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5dGhvbl9leGUgPSBvcy5wYXRoLmpvaW4ocHl0aG9uX2RpciwgInB5dGhvbi5leGUiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMocHl0aG9uX2V4ZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoX3BhdGhzLmFwcGVuZChweXRob25fZXhlKQogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICAjIENvbW1vbiByb290LWxldmVsIFB5dGhvbiBpbnN0YWxsYXRpb25zCiAgICAgICAgZm9yIHZlcnNpb24gaW4gWyczMTInLCAnMzExJywgJzMxMCcsICczOScsICczOCddOgogICAgICAgICAgICBzZWFyY2hfcGF0aHMuZXh0ZW5kKFsKICAgICAgICAgICAgICAgIG9zLnBhdGguam9pbihyIkM6XFB5dGhvbiIgKyB2ZXJzaW9uLCAicHl0aG9uLmV4ZSIpLAogICAgICAgICAgICAgICAgb3MucGF0aC5qb2luKHByb2dyYW1maWxlcywgZiJQeXRob257dmVyc2lvbn0iLCAicHl0aG9uLmV4ZSIpLAogICAgICAgICAgICAgICAgb3MucGF0aC5qb2luKHByb2dyYW1maWxlc194ODYsIGYiUHl0aG9ue3ZlcnNpb259IiwgInB5dGhvbi5leGUiKSwKICAgICAgICAgICAgXSkKICAgICAgICAKICAgICAgICAjIENoZWNrIGFsbCBjb2xsZWN0ZWQgcGF0aHMKICAgICAgICBmb3IgcGF0aCBpbiBzZWFyY2hfcGF0aHM6CiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKHBhdGgpOgogICAgICAgICAgICAgICAgcmV0dXJuIHBhdGgKICAgICAgICAKICAgICAgICAjIE1ldGhvZCA1OiBSZWN1cnNpdmUgc2VhcmNoIGluIFByb2dyYW0gRmlsZXMgKGxhc3QgcmVzb3J0LCBzbG93ZXIpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBmb3Igcm9vdF9kaXIgaW4gW3Byb2dyYW1maWxlcywgcHJvZ3JhbWZpbGVzX3g4Nl06CiAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhyb290X2Rpcik6CiAgICAgICAgICAgICAgICAgICAgZm9yIHJvb3QsIGRpcnMsIGZpbGVzIGluIG9zLndhbGsocm9vdF9kaXIpOgogICAgICAgICAgICAgICAgICAgICAgICAjIExpbWl0IGRlcHRoIHRvIGF2b2lkIHNsb3cgc2VhcmNoZXMKICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGggPSByb290W2xlbihyb290X2Rpcik6XS5jb3VudChvcy5zZXApCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGRlcHRoID4gMjogICMgTWF4IDIgbGV2ZWxzIGRlZXAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcnNbOl0gPSBbXSAgIyBEb24ndCByZWN1cnNlIGRlZXBlcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICdweXRob24uZXhlJyBpbiBmaWxlczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5dGhvbl9leGUgPSBvcy5wYXRoLmpvaW4ocm9vdCwgJ3B5dGhvbi5leGUnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBWZXJpZnkgaXQncyBhY3R1YWxseSBQeXRob24KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzdWJwcm9jZXNzLnJ1bihbcHl0aG9uX2V4ZSwgJy0tdmVyc2lvbiddLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgdGltZW91dD0xKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHJlc3VsdC5yZXR1cm5jb2RlID09IDA6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBweXRob25fZXhlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgICAgIHJldHVybiBOb25lCiAgICAKICAgIGRlZiBpc19weXRob25fdmVyc2lvbl9jb21wYXRpYmxlKHNlbGYsIHB5dGhvbl9leGUpOgogICAgICAgICIiIkNoZWNrIGlmIFB5dGhvbiB2ZXJzaW9uIGlzIGNvbXBhdGlibGUgKDMuOC0zLjEzKS4iIiIKICAgICAgICB0cnk6CiAgICAgICAgICAgICMgVHJ5IHRvIGdldCB2ZXJzaW9uIHdpdGhvdXQgaGFuZ2luZyAtIHVzZSBhIHZlcnkgc2hvcnQgdGltZW91dAogICAgICAgICAgICByZXN1bHQgPSBzdWJwcm9jZXNzLnJ1bigKICAgICAgICAgICAgICAgIFtweXRob25fZXhlLCAnLS12ZXJzaW9uJ10sCiAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLAogICAgICAgICAgICAgICAgdGV4dD1UcnVlLAogICAgICAgICAgICAgICAgdGltZW91dD0xCiAgICAgICAgICAgICkKICAgICAgICAgICAgaWYgcmVzdWx0LnJldHVybmNvZGUgPT0gMDoKICAgICAgICAgICAgICAgIHZlcnNpb25fc3RyID0gcmVzdWx0LnN0ZG91dC5zdHJpcCgpIG9yIHJlc3VsdC5zdGRlcnIuc3RyaXAoKQogICAgICAgICAgICAgICAgIyBQYXJzZSB2ZXJzaW9uIChlLmcuLCAiUHl0aG9uIDMuMTIuMCIgLT4gKDMsIDEyKSkKICAgICAgICAgICAgICAgIGltcG9ydCByZQogICAgICAgICAgICAgICAgbWF0Y2ggPSByZS5zZWFyY2gocicoXGQrKVwuKFxkKyknLCB2ZXJzaW9uX3N0cikKICAgICAgICAgICAgICAgIGlmIG1hdGNoOgogICAgICAgICAgICAgICAgICAgIG1ham9yID0gaW50KG1hdGNoLmdyb3VwKDEpKQogICAgICAgICAgICAgICAgICAgIG1pbm9yID0gaW50KG1hdGNoLmdyb3VwKDIpKQogICAgICAgICAgICAgICAgICAgICMgQ2hlY2sgaWYgdmVyc2lvbiBpcyAzLjgtMy4xMwogICAgICAgICAgICAgICAgICAgIGlmIG1ham9yID09IDMgYW5kIDggPD0gbWlub3IgPD0gMTM6CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcnVlCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBwYXNzCiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAKICAgIGRlZiBmaW5kX3B5dGhvbl9leGVjdXRhYmxlX2RhZW1vbihzZWxmKToKICAgICAgICAiIiJGaW5kIHB5dGhvbi5leGUgc3BlY2lmaWNhbGx5IChub3QgcHl0aG9udy5leGUpIGZvciBkYWVtb24uCiAgICAgICAgT25seSByZXR1cm5zIFB5dGhvbiB2ZXJzaW9ucyAzLjgtMy4xMyAoY29tcGF0aWJsZSB3aXRoIGRlcGVuZGVuY2llcykuIiIiCiAgICAgICAgIyBUcnkgJ3B5dGhvbicgY29tbWFuZCBmaXJzdCAoc2hvdWxkIGJlIHB5dGhvbi5leGUpCiAgICAgICAgdHJ5OgogICAgICAgICAgICByZXN1bHQgPSBzdWJwcm9jZXNzLnJ1bihbJ3B5dGhvbicsICctLXZlcnNpb24nXSwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLCB0ZXh0PVRydWUsIHRpbWVvdXQ9MSkKICAgICAgICAgICAgaWYgcmVzdWx0LnJldHVybmNvZGUgPT0gMDoKICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNfcHl0aG9uX3ZlcnNpb25fY29tcGF0aWJsZSgncHl0aG9uJyk6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdweXRob24nCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBwYXNzCiAgICAgICAgCiAgICAgICAgIyBTZWFyY2ggZm9yIHB5dGhvbi5leGUgaW4gY29tbW9uIGxvY2F0aW9ucwogICAgICAgIHVzZXJwcm9maWxlID0gb3MuZ2V0ZW52KCdVU0VSUFJPRklMRScsICcnKQogICAgICAgIHByb2dyYW1maWxlcyA9IG9zLmdldGVudignUHJvZ3JhbUZpbGVzJywgcidDOlxQcm9ncmFtIEZpbGVzJykKICAgICAgICBwcm9ncmFtZmlsZXNfeDg2ID0gb3MuZ2V0ZW52KCdQcm9ncmFtRmlsZXMoeDg2KScsIHInQzpcUHJvZ3JhbSBGaWxlcyAoeDg2KScpCiAgICAgICAgCiAgICAgICAgcHl0aG9uX3ZlcnNpb25zID0gW10gICMgTGlzdCBvZiAodmVyc2lvbl90dXBsZSwgcGF0aCkgZm9yIHNvcnRpbmcKICAgICAgICAKICAgICAgICAjIFVzZXIgQXBwRGF0YSBsb2NhdGlvbnMgLSBjb2xsZWN0IGFsbCB2ZXJzaW9ucyBhbmQgY2hlY2sgY29tcGF0aWJpbGl0eQogICAgICAgIGlmIHVzZXJwcm9maWxlOgogICAgICAgICAgICBhcHBkYXRhX2xvY2FsID0gb3MucGF0aC5qb2luKHVzZXJwcm9maWxlLCByIkFwcERhdGFcTG9jYWxcUHJvZ3JhbXNcUHl0aG9uIikKICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoYXBwZGF0YV9sb2NhbCk6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgZm9yIGl0ZW0gaW4gb3MubGlzdGRpcihhcHBkYXRhX2xvY2FsKToKICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX2RpciA9IG9zLnBhdGguam9pbihhcHBkYXRhX2xvY2FsLCBpdGVtKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZGlyKHB5dGhvbl9kaXIpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX2V4ZSA9IG9zLnBhdGguam9pbihweXRob25fZGlyLCAicHl0aG9uLmV4ZSIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhweXRob25fZXhlKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIENoZWNrIGlmIHZlcnNpb24gaXMgY29tcGF0aWJsZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHNlbGYuaXNfcHl0aG9uX3ZlcnNpb25fY29tcGF0aWJsZShweXRob25fZXhlKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBFeHRyYWN0IHZlcnNpb24gbnVtYmVyIGZyb20gZGlyZWN0b3J5IG5hbWUgKGUuZy4sICJQeXRob24zMTIiIC0+ICgzLCAxMikpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb25fc3RyID0gaXRlbS5yZXBsYWNlKCJQeXRob24iLCAiIikucmVwbGFjZSgicHl0aG9uIiwgIiIpLnJlcGxhY2UoIi4iLCAiIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHZlcnNpb25fc3RyOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgSGFuZGxlIGZvcm1hdHMgbGlrZSAiMzEyIiwgIjM5IiwgIjMxMCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4odmVyc2lvbl9zdHIpID49IDI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ham9yID0gMwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4odmVyc2lvbl9zdHIpID09IDI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5vciA9IGludCh2ZXJzaW9uX3N0cikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbm9yID0gaW50KHZlcnNpb25fc3RyWzoyXSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX3ZlcnNpb25zLmFwcGVuZCgoKG1ham9yLCBtaW5vciksIHB5dGhvbl9leGUpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIElmIHdlIGNhbid0IHBhcnNlLCBjaGVjayBieSBydW5uaW5nIFB5dGhvbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX3ZlcnNpb25zLmFwcGVuZCgoKDAsIDApLCBweXRob25fZXhlKSkKICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgCiAgICAgICAgIyBDb21tb24gcm9vdC1sZXZlbCBQeXRob24gaW5zdGFsbGF0aW9ucyAoMy44LTMuMTMpCiAgICAgICAgZm9yIG1ham9yX21pbm9yIGluIFsoMywgMTMpLCAoMywgMTIpLCAoMywgMTEpLCAoMywgMTApLCAoMywgOSksICgzLCA4KV06CiAgICAgICAgICAgIHZlcnNpb25fc3RyID0gZiJ7bWFqb3JfbWlub3JbMF19e21ham9yX21pbm9yWzFdOjAyZH0iICAjIGUuZy4sICIzMTIiLCAiMzkiCiAgICAgICAgICAgIGZvciBiYXNlX3BhdGggaW4gWwogICAgICAgICAgICAgICAgb3MucGF0aC5qb2luKHJmIkM6XFB5dGhvbnt2ZXJzaW9uX3N0cn0iLCAicHl0aG9uLmV4ZSIpLAogICAgICAgICAgICAgICAgb3MucGF0aC5qb2luKHByb2dyYW1maWxlcywgZiJQeXRob257dmVyc2lvbl9zdHJ9IiwgInB5dGhvbi5leGUiKSwKICAgICAgICAgICAgICAgIG9zLnBhdGguam9pbihwcm9ncmFtZmlsZXNfeDg2LCBmIlB5dGhvbnt2ZXJzaW9uX3N0cn0iLCAicHl0aG9uLmV4ZSIpLAogICAgICAgICAgICBdOgogICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoYmFzZV9wYXRoKToKICAgICAgICAgICAgICAgICAgICBpZiBzZWxmLmlzX3B5dGhvbl92ZXJzaW9uX2NvbXBhdGlibGUoYmFzZV9wYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX3ZlcnNpb25zLmFwcGVuZCgobWFqb3JfbWlub3IsIGJhc2VfcGF0aCkpCiAgICAgICAgCiAgICAgICAgIyBTb3J0IGJ5IHZlcnNpb24gKG5ld2VzdCBmaXJzdCkgLSAoMywgMTMpID4gKDMsIDEyKSA+IC4uLiA+ICgzLCA4KQogICAgICAgIHB5dGhvbl92ZXJzaW9ucy5zb3J0KHJldmVyc2U9VHJ1ZSwga2V5PWxhbWJkYSB4OiB4WzBdKQogICAgICAgIAogICAgICAgICMgUmV0dXJuIHRoZSBuZXdlc3QgY29tcGF0aWJsZSB2ZXJzaW9uCiAgICAgICAgZm9yIChtYWpvciwgbWlub3IpLCBwYXRoIGluIHB5dGhvbl92ZXJzaW9uczoKICAgICAgICAgICAgcmV0dXJuIHBhdGgKICAgICAgICAKICAgICAgICByZXR1cm4gTm9uZQogICAgCiAgICBkZWYgc3RhcnRfZGFlbW9uKHNlbGYpOgogICAgICAgICIiIlN0YXJ0IHRoZSBkZWF0aCBjb3VudGVyIGRhZW1vbi4iIiIKICAgICAgICAjIEluaXRpYWxpemUgZGVidWcgbG9nIGF0IHRoZSB2ZXJ5IHN0YXJ0IC0gTVVTVCBiZSBmaXJzdCB0aGluZwogICAgICAgIGRlYnVnX2xvZ19jcmVhdGVkID0gRmFsc2UKICAgICAgICB0cnk6CiAgICAgICAgICAgIG9zLm1ha2VkaXJzKEJBU0VfRElSLCBleGlzdF9vaz1UcnVlKSAgIyBFbnN1cmUgZGlyZWN0b3J5IGV4aXN0cwogICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgInciLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgZi53cml0ZShmInsnPScqNzB9XG4iKQogICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogc3RhcnRfZGFlbW9uKCkgY2FsbGVkIGF0IHt0aW1lLnN0cmZ0aW1lKCclWS0lbS0lZCAlSDolTTolUycpfVxuIikKICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IEJBU0VfRElSID0ge0JBU0VfRElSfVxuIikKICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IExPQ0tfRklMRSA9IHtMT0NLX0ZJTEV9XG4iKQogICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogUkVBRFlfRklMRSA9IHtSRUFEWV9GSUxFfVxuIikKICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IEJBU0VfRElSIGV4aXN0czoge29zLnBhdGguZXhpc3RzKEJBU0VfRElSKX1cbiIpCiAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBCQVNFX0RJUiB3cml0YWJsZToge29zLmFjY2VzcyhCQVNFX0RJUiwgb3MuV19PSyl9XG4iKQogICAgICAgICAgICAgICAgZi5mbHVzaCgpICAjIEZvcmNlIHdyaXRlCiAgICAgICAgICAgIGRlYnVnX2xvZ19jcmVhdGVkID0gVHJ1ZQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgIyBJZiB3ZSBjYW4ndCB3cml0ZSBkZWJ1ZyBsb2csIHRyeSB0byBzaG93IGVycm9yIGluIG1lc3NhZ2Vib3gKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93ZXJyb3IoIkRlYnVnIExvZyBFcnJvciIsIGYiQ291bGQgbm90IGNyZWF0ZSBkZWJ1ZyBsb2c6IHtlfVxuXG5CQVNFX0RJUjoge0JBU0VfRElSfSIpCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICAjIENoZWNrIGlmIGRhZW1vbiBpcyBydW5uaW5nCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBkZWJ1Z19sb2dfY3JlYXRlZDoKICAgICAgICAgICAgICAgIHdpdGggb3BlbihHVUlfREVCVUdfTE9HLCAiYSIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgZi53cml0ZSgiR1VJOiBDYWxsaW5nIGlzX2RhZW1vbl9ydW5uaW5nKCkuLi5cbiIpCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBwYXNzCiAgICAgICAgCiAgICAgICAgZGFlbW9uX3J1bm5pbmdfY2hlY2sgPSBzZWxmLmlzX2RhZW1vbl9ydW5uaW5nKCkKICAgICAgICAKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBpc19kYWVtb25fcnVubmluZygpIHJldHVybmVkOiB7ZGFlbW9uX3J1bm5pbmdfY2hlY2t9XG4iKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgICAgIGlmIGRhZW1vbl9ydW5uaW5nX2NoZWNrOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZiBkZWJ1Z19sb2dfY3JlYXRlZDoKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCJHVUk6IERhZW1vbiBhcHBlYXJzIHRvIGJlIHJ1bm5pbmcgLSBjaGVja2luZyBwcm9jZXNzLi4uXG4iKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICMgQ2hlY2sgaWYgdGhlIHByb2Nlc3MgaXMgYWN0dWFsbHkgcnVubmluZwogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oTE9DS19GSUxFLCAiciIpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgcGlkX3N0ciA9IGYucmVhZCgpLnN0cmlwKCkKICAgICAgICAgICAgICAgIGlmIHBpZF9zdHI6CiAgICAgICAgICAgICAgICAgICAgcGlkID0gaW50KHBpZF9zdHIpCiAgICAgICAgICAgICAgICAgICAgIyBDaGVjayBpZiBwcm9jZXNzIGV4aXN0cwogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0IHBzdXRpbAogICAgICAgICAgICAgICAgICAgICAgICBpZiBwc3V0aWwucGlkX2V4aXN0cyhwaWQpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93aW5mbygiSW5mbyIsIGYiRGFlbW9uIGlzIGFscmVhZHkgcnVubmluZyAoUElEOiB7cGlkfSkuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBTdGFsZSBsb2NrIGZpbGUgLSBwcm9jZXNzIGRvZXNuJ3QgZXhpc3QKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLnJlbW92ZShMT0NLX0ZJTEUpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICAjIHBzdXRpbCBub3QgYXZhaWxhYmxlIG9yIG90aGVyIGVycm9yIC0gdHJ5IHRhc2tsaXN0CiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN1YnByb2Nlc3MucnVuKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsidGFza2xpc3QiLCAiL0ZJIiwgZiJQSUQgZXEge3BpZH0iXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0PTIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGYie3BpZH0iIGluIHJlc3VsdC5zdGRvdXQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93aW5mbygiSW5mbyIsIGYiRGFlbW9uIGlzIGFscmVhZHkgcnVubmluZyAoUElEOiB7cGlkfSkuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBTdGFsZSBsb2NrIGZpbGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUoTE9DS19GSUxFKQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIENhbid0IGNoZWNrIC0gcmVtb3ZlIGxvY2sgZmlsZSB0byBiZSBzYWZlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MucmVtb3ZlKExPQ0tfRklMRSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICMgQ2FuJ3QgcmVhZCBsb2NrIGZpbGUgLSByZW1vdmUgaXQKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUoTE9DS19GSUxFKQogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICAjIENoZWNrIGlmIHNjcmlwdCBleGlzdHMgKHRyeSBib3RoIHBvc3NpYmxlIG5hbWVzKQogICAgICAgIHNjcmlwdF9wYXRoID0gU0NSSVBUX1BBVEgKICAgICAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoc2NyaXB0X3BhdGgpOgogICAgICAgICAgICBhbHRfcGF0aCA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgIm11bHRpX2dhbWVfZGVhdGhfY291bnRlci5weSIpCiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKGFsdF9wYXRoKToKICAgICAgICAgICAgICAgIHNjcmlwdF9wYXRoID0gYWx0X3BhdGgKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2Vycm9yKCJFcnJvciIsIGYiRGVhdGggY291bnRlciBzY3JpcHQgbm90IGZvdW5kLlxuXG5Mb29raW5nIGZvcjpcbntTQ1JJUFRfUEFUSH1cbm9yXG57YWx0X3BhdGh9IikKICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgIAogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgZGVidWdfbG9nX2NyZWF0ZWQ6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoIkdVSTogRmluZGluZyBQeXRob24gZXhlY3V0YWJsZS4uLlxuIikKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBzeXMuZnJvemVuID0ge2dldGF0dHIoc3lzLCAnZnJvemVuJywgRmFsc2UpfVxuIikKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICAjIEZpbmQgUHl0aG9uIGV4ZWN1dGFibGUgKHVzZSBweXRob24uZXhlLCBub3QgcHl0aG9udy5leGUgZm9yIGRhZW1vbikKICAgICAgICBweXRob25fY21kID0gTm9uZQogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgZGVidWdfbG9nX2NyZWF0ZWQ6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoIkdVSTogQWJvdXQgdG8gY2hlY2sgc3lzLmZyb3plbi4uLlxuIikKICAgICAgICAgICAgICAgICAgICBmLmZsdXNoKCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIGdldGF0dHIoc3lzLCAnZnJvemVuJywgRmFsc2UpOgogICAgICAgICAgICAgICAgIyBSdW5uaW5nIGFzIGNvbXBpbGVkIGV4ZSAtIG5lZWQgdG8gZmluZCBQeXRob24KICAgICAgICAgICAgICAgICMgRmlyc3QgdHJ5IHRvIGZpbmQgcHl0aG9uLmV4ZSBkaXJlY3RseQogICAgICAgICAgICAgICAgcHl0aG9uX2NtZCA9IHNlbGYuZmluZF9weXRob25fZXhlY3V0YWJsZV9kYWVtb24oKQogICAgICAgICAgICAgICAgaWYgbm90IHB5dGhvbl9jbWQ6CiAgICAgICAgICAgICAgICAgICAgIyBGYWxsYmFjayB0byByZWd1bGFyIGZpbmRlcgogICAgICAgICAgICAgICAgICAgIHB5dGhvbl9jbWQgPSBzZWxmLmZpbmRfcHl0aG9uX2V4ZWN1dGFibGUoKQogICAgICAgICAgICAgICAgICAgIGlmIG5vdCBweXRob25fY21kOgogICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlYm94LnNob3dlcnJvcigiRXJyb3IiLCAiUHl0aG9uIG5vdCBmb3VuZC4gUGxlYXNlIGluc3RhbGwgUHl0aG9uIGFuZCBhZGQgaXQgdG8gUEFUSCwgb3IgcmVzdGFydCB0aGUgaW5zdGFsbGVyIGFmdGVyIGluc3RhbGxpbmcgUHl0aG9uLiIpCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAjIEVuc3VyZSB3ZSdyZSB1c2luZyBweXRob24uZXhlLCBub3QgcHl0aG9udy5leGUKICAgICAgICAgICAgICAgIGlmIHB5dGhvbl9jbWQuZW5kc3dpdGgoJ3B5dGhvbncuZXhlJykgb3IgJ3B5dGhvbncnIGluIHB5dGhvbl9jbWQubG93ZXIoKToKICAgICAgICAgICAgICAgICAgICAjIFRyeSB0byBmaW5kIHB5dGhvbi5leGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5CiAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMocHl0aG9uX2NtZCk6CiAgICAgICAgICAgICAgICAgICAgICAgIHB5dGhvbl9kaXIgPSBvcy5wYXRoLmRpcm5hbWUocHl0aG9uX2NtZCkKICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX2V4ZSA9IG9zLnBhdGguam9pbihweXRob25fZGlyLCAicHl0aG9uLmV4ZSIpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKHB5dGhvbl9leGUpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHl0aG9uX2NtZCA9IHB5dGhvbl9leGUKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgVHJ5IHJlcGxhY2luZyBweXRob253IHdpdGggcHl0aG9uIGluIHRoZSBwYXRoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweXRob25fY21kID0gcHl0aG9uX2NtZC5yZXBsYWNlKCdweXRob253LmV4ZScsICdweXRob24uZXhlJykucmVwbGFjZSgncHl0aG9udycsICdweXRob24nKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgIyBSdW5uaW5nIGFzIHNjcmlwdCAtIHVzZSBzeXMuZXhlY3V0YWJsZQogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogUnVubmluZyBhcyBzY3JpcHQsIHVzaW5nIHN5cy5leGVjdXRhYmxlXG4iKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogc3lzLmV4ZWN1dGFibGUgPSB7c3lzLmV4ZWN1dGFibGV9XG4iKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5mbHVzaCgpCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgcHl0aG9uX2NtZCA9IHN5cy5leGVjdXRhYmxlCiAgICAgICAgICAgICAgICAjIElmIGl0J3MgcHl0aG9udywgdHJ5IHRvIGZpbmQgcHl0aG9uLmV4ZQogICAgICAgICAgICAgICAgaWYgcHl0aG9uX2NtZC5lbmRzd2l0aCgncHl0aG9udy5leGUnKToKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBzeXMuZXhlY3V0YWJsZSBpcyBweXRob253LmV4ZSwgbG9va2luZyBmb3IgcHl0aG9uLmV4ZVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmZsdXNoKCkKICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBweXRob25fZGlyID0gb3MucGF0aC5kaXJuYW1lKHB5dGhvbl9jbWQpCiAgICAgICAgICAgICAgICAgICAgcHl0aG9uX2V4ZSA9IG9zLnBhdGguam9pbihweXRob25fZGlyLCAicHl0aG9uLmV4ZSIpCiAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMocHl0aG9uX2V4ZSk6CiAgICAgICAgICAgICAgICAgICAgICAgIHB5dGhvbl9jbWQgPSBweXRob25fZXhlCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3BlbihHVUlfREVCVUdfTE9HLCAiYSIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IEZvdW5kIHB5dGhvbi5leGU6IHtweXRob25fZXhlfVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5mbHVzaCgpCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBkZWJ1Z19sb2dfY3JlYXRlZDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBweXRob24uZXhlIG5vdCBmb3VuZCBpbiB7cHl0aG9uX2Rpcn1cbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYuZmx1c2goKQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGVidWdfbG9nX2NyZWF0ZWQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFVzaW5nIHN5cy5leGVjdXRhYmxlIGFzLWlzOiB7cHl0aG9uX2NtZH1cbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5mbHVzaCgpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAjIElmIHRoZXJlJ3MgYW4gZXJyb3IgZmluZGluZyBQeXRob24sIGxvZyBpdAogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZiBkZWJ1Z19sb2dfY3JlYXRlZDoKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBFUlJPUiBpbiBQeXRob24gZmluZGluZyBsb2dpYzoge2V9XG4iKQogICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnQgdHJhY2ViYWNrCiAgICAgICAgICAgICAgICAgICAgICAgIGYud3JpdGUodHJhY2ViYWNrLmZvcm1hdF9leGMoKSkKICAgICAgICAgICAgICAgICAgICAgICAgZi5mbHVzaCgpCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93ZXJyb3IoIkVycm9yIiwgZiJFcnJvciBmaW5kaW5nIFB5dGhvbiBleGVjdXRhYmxlOiB7ZX0iKQogICAgICAgICAgICByZXR1cm4KICAgICAgICAKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBGaW5hbCBQeXRob24gY29tbWFuZDoge3B5dGhvbl9jbWR9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFB5dGhvbiBleGlzdHM6IHtvcy5wYXRoLmV4aXN0cyhweXRob25fY21kKSBpZiBweXRob25fY21kIGVsc2UgRmFsc2V9XG4iKQogICAgICAgICAgICAgICAgICAgIGYuZmx1c2goKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgICAgIGlmIG5vdCBweXRob25fY21kOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZiBkZWJ1Z19sb2dfY3JlYXRlZDoKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCJHVUk6IEVSUk9SIC0gcHl0aG9uX2NtZCBpcyBOb25lIVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgZi5mbHVzaCgpCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93ZXJyb3IoIkVycm9yIiwgIkNvdWxkIG5vdCBkZXRlcm1pbmUgUHl0aG9uIGV4ZWN1dGFibGUuIikKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgCiAgICAgICAgIyBTa2lwIFB5dGhvbiB0ZXN0IC0gd2UgYWxyZWFkeSB2ZXJpZmllZCB0aGUgZXhlY3V0YWJsZSBleGlzdHMKICAgICAgICAjIFRoZSB0ZXN0IHdhcyB0aW1pbmcgb3V0IG9uIHNvbWUgc3lzdGVtcyAoZXNwZWNpYWxseSB3aXRoIG11bHRpcGxlIFB5dGhvbiB2ZXJzaW9ucyksCiAgICAgICAgIyBhbmQgd2UnbGwgZ2V0IGJldHRlciBlcnJvciBtZXNzYWdlcyBmcm9tIHRoZSBkYWVtb24gaXRzZWxmIGlmIFB5dGhvbiBkb2Vzbid0IHdvcmsKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCJHVUk6IFNraXBwaW5nIFB5dGhvbiB0ZXN0IChhbHJlYWR5IHZlcmlmaWVkIGV4ZWN1dGFibGUgZXhpc3RzKVxuIikKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBVc2luZyBQeXRob246IHtweXRob25fY21kfVxuIikKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCJHVUk6IFByb2NlZWRpbmcgZGlyZWN0bHkgdG8gc3RhcnQgZGFlbW9uXG4iKQogICAgICAgICAgICAgICAgICAgIGYuZmx1c2goKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgICAgICMgU3RhcnQgZGFlbW9uIGluIGJhY2tncm91bmQKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBBYm91dCB0byBzdGFydCBkYWVtb24gcHJvY2VzcyB3aXRoIHN1YnByb2Nlc3MuUG9wZW5cbiIpCiAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogUHl0aG9uOiB7cHl0aG9uX2NtZH1cbiIpCiAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogU2NyaXB0OiB7c2NyaXB0X3BhdGh9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFdvcmtpbmcgZGlyOiB7QkFTRV9ESVJ9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFNjcmlwdCBleGlzdHM6IHtvcy5wYXRoLmV4aXN0cyhzY3JpcHRfcGF0aCl9XG4iKQogICAgICAgICAgICAgICAgICAgIGYuZmx1c2goKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgICAgIHRyeToKICAgICAgICAgICAgIyBVc2Ugc3VicHJvY2Vzcy5QSVBFIGJ1dCBhbHNvIGFsbG93IHNlZWluZyBvdXRwdXQgZm9yIGRlYnVnZ2luZwogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBpZiBkZWJ1Z19sb2dfY3JlYXRlZDoKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKCJHVUk6IENhbGxpbmcgc3VicHJvY2Vzcy5Qb3BlbigpIG5vdy4uLlxuIikKICAgICAgICAgICAgICAgICAgICAgICAgZi5mbHVzaCgpCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgCiAgICAgICAgICAgIENSRUFURV9OT19XSU5ET1cgPSAweDA4MDAwMDAwIGlmIGhhc2F0dHIoc3VicHJvY2VzcywgJ0NSRUFURV9OT19XSU5ET1cnKSBlbHNlIDAKICAgICAgICAgICAgaWYgc3lzLnBsYXRmb3JtID09ICJ3aW4zMiI6CiAgICAgICAgICAgICAgICBzZWxmLmRhZW1vbl9wcm9jZXNzID0gc3VicHJvY2Vzcy5Qb3BlbigKICAgICAgICAgICAgICAgICAgICBbcHl0aG9uX2NtZCwgc2NyaXB0X3BhdGhdLAogICAgICAgICAgICAgICAgICAgIGN3ZD1CQVNFX0RJUiwKICAgICAgICAgICAgICAgICAgICBzdGRvdXQ9c3VicHJvY2Vzcy5QSVBFLAogICAgICAgICAgICAgICAgICAgIHN0ZGVycj1zdWJwcm9jZXNzLlNURE9VVCwgICMgTWVyZ2Ugc3RkZXJyIGludG8gc3Rkb3V0CiAgICAgICAgICAgICAgICAgICAgdGV4dD1UcnVlLAogICAgICAgICAgICAgICAgICAgIGJ1ZnNpemU9MSwgICMgTGluZSBidWZmZXJlZAogICAgICAgICAgICAgICAgICAgIGNyZWF0aW9uZmxhZ3M9Q1JFQVRFX05PX1dJTkRPVwogICAgICAgICAgICAgICAgKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgc2VsZi5kYWVtb25fcHJvY2VzcyA9IHN1YnByb2Nlc3MuUG9wZW4oCiAgICAgICAgICAgICAgICAgICAgW3B5dGhvbl9jbWQsIHNjcmlwdF9wYXRoXSwKICAgICAgICAgICAgICAgICAgICBjd2Q9QkFTRV9ESVIsCiAgICAgICAgICAgICAgICAgICAgc3Rkb3V0PXN1YnByb2Nlc3MuUElQRSwKICAgICAgICAgICAgICAgICAgICBzdGRlcnI9c3VicHJvY2Vzcy5TVERPVVQsCiAgICAgICAgICAgICAgICAgICAgdGV4dD1UcnVlLAogICAgICAgICAgICAgICAgICAgIGJ1ZnNpemU9MQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgaWYgZGVidWdfbG9nX2NyZWF0ZWQ6CiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogc3VicHJvY2Vzcy5Qb3BlbigpIGNvbXBsZXRlZFxuIikKICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogRGFlbW9uIHByb2Nlc3MgUElEOiB7c2VsZi5kYWVtb25fcHJvY2Vzcy5waWR9XG4iKQogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBQcm9jZXNzIHBvbGwgcmVzdWx0OiB7c2VsZi5kYWVtb25fcHJvY2Vzcy5wb2xsKCl9XG4iKQogICAgICAgICAgICAgICAgICAgICAgICBmLmZsdXNoKCkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogRVJST1IgbG9nZ2luZyBwcm9jZXNzIGluZm86IHtlfVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYuZmx1c2goKQogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgICAgIHdpdGggb3BlbihHVUlfREVCVUdfTE9HLCAiYSIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IEVSUk9SIC0gRXhjZXB0aW9uIGR1cmluZyBzdWJwcm9jZXNzLlBvcGVuKCk6IHtlfVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0IHRyYWNlYmFjawogICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKHRyYWNlYmFjay5mb3JtYXRfZXhjKCkpCiAgICAgICAgICAgICAgICAgICAgICAgIGYuZmx1c2goKQogICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2Vycm9yKCJFcnJvciIsIGYiRXJyb3Igc3RhcnRpbmcgZGFlbW9uOiB7ZX1cblxuUHl0aG9uOiB7cHl0aG9uX2NtZH1cblNjcmlwdDoge3NjcmlwdF9wYXRofSIpCiAgICAgICAgICAgIHJldHVybgogICAgICAgIAogICAgICAgICMgV2FpdCBmb3IgZGFlbW9uIHRvIHN0YXJ0IC0gcG9sbCBib3RoIHByb2Nlc3MgYW5kIGxvY2sgZmlsZQogICAgICAgIG1heF93YWl0X3RpbWUgPSAxNSAgIyBXYWl0IHVwIHRvIDE1IHNlY29uZHMgKGluY3JlYXNlZCBmb3Igc2FmZXR5KQogICAgICAgIGNoZWNrX2ludGVydmFsID0gMC4yICAjIENoZWNrIGV2ZXJ5IDAuMiBzZWNvbmRzIChtb3JlIGZyZXF1ZW50KQogICAgICAgIHdhaXRlZCA9IDAKICAgICAgICBwcm9jZXNzX2V4aXRlZCA9IEZhbHNlCiAgICAgICAgbG9ja19maWxlX2NyZWF0ZWQgPSBGYWxzZQogICAgICAgIAogICAgICAgICMgRGVidWc6IExvZyBwYXRocyBiZWluZyBjaGVja2VkIHRvIGZpbGUKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiXG57Jz0nKjcwfVxuIikKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBTdGFydGluZyBkYWVtb24gYXQge3RpbWUuc3RyZnRpbWUoJyVZLSVtLSVkICVIOiVNOiVTJyl9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IENoZWNraW5nIGZvciBMT0NLX0ZJTEUgYXQ6IHtMT0NLX0ZJTEV9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IENoZWNraW5nIGZvciBSRUFEWV9GSUxFIGF0OiB7UkVBRFlfRklMRX1cbiIpCiAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogQkFTRV9ESVIgaXM6IHtCQVNFX0RJUn1cbiIpCiAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogU2NyaXB0IHBhdGg6IHtzY3JpcHRfcGF0aH1cbiIpCiAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogUHl0aG9uIGNtZDoge3B5dGhvbl9jbWR9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IExPQ0tfRklMRSBleGlzdHM6IHtvcy5wYXRoLmV4aXN0cyhMT0NLX0ZJTEUpfVxuIikKICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBSRUFEWV9GSUxFIGV4aXN0czoge29zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpfVxuIikKICAgICAgICAgICAgICAgICAgICBmLmZsdXNoKCkKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICB3aGlsZSB3YWl0ZWQgPCBtYXhfd2FpdF90aW1lOgogICAgICAgICAgICAjIExvZyBldmVyeSAyIHNlY29uZHMgd2hhdCB3ZSdyZSBjaGVja2luZwogICAgICAgICAgICBpZiB3YWl0ZWQgPiAwIGFuZCBpbnQod2FpdGVkICogMTApICUgMTAgPT0gMDogICMgRXZlcnkgMSBzZWNvbmQKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGRlYnVnX2xvZ19jcmVhdGVkOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBXYWl0IGxvb3AgLSB3YWl0ZWQge3dhaXRlZDouMWZ9cywgY2hlY2tpbmcgZmlsZXMuLi5cbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogICBMT0NLX0ZJTEUgZXhpc3RzOiB7b3MucGF0aC5leGlzdHMoTE9DS19GSUxFKX1cbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogICBSRUFEWV9GSUxFIGV4aXN0czoge29zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpfVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiAgIFByb2Nlc3MgcnVubmluZzoge3NlbGYuZGFlbW9uX3Byb2Nlc3MucG9sbCgpIGlzIE5vbmV9XG4iKQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAKICAgICAgICAgICAgIyBDaGVjayBpZiBwcm9jZXNzIGV4aXRlZCAoZXJyb3IpCiAgICAgICAgICAgIGlmIHNlbGYuZGFlbW9uX3Byb2Nlc3MucG9sbCgpIGlzIG5vdCBOb25lOgogICAgICAgICAgICAgICAgICAgIHByb2Nlc3NfZXhpdGVkID0gVHJ1ZQogICAgICAgICAgICAgICAgICAgICMgUHJvY2VzcyBleGl0ZWQgLSB0aGVyZSB3YXMgYW4gZXJyb3IKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZG91dCwgXyA9IHNlbGYuZGFlbW9uX3Byb2Nlc3MuY29tbXVuaWNhdGUodGltZW91dD0xKQogICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSAiIgogICAgICAgICAgICAgICAgICAgICAgICBpZiBzdGRvdXQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSBzdGRvdXQuc3RyaXAoKSBpZiBpc2luc3RhbmNlKHN0ZG91dCwgc3RyKSBlbHNlIHN0ZG91dC5kZWNvZGUoJ3V0Zi04JywgZXJyb3JzPSdpZ25vcmUnKS5zdHJpcCgpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBlcnJvcl9tc2c6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSBmIlByb2Nlc3MgZXhpdGVkIHdpdGggY29kZSB7c2VsZi5kYWVtb25fcHJvY2Vzcy5yZXR1cm5jb2RlfSIKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICMgQ2hlY2sgZGVidWcubG9nIGZvciBtb3JlIGRldGFpbHMKICAgICAgICAgICAgICAgICAgICAgICAgbG9nX2ZpbGUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkZWJ1Zy5sb2ciKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhsb2dfZmlsZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKGxvZ19maWxlLCAncicsIGVuY29kaW5nPSd1dGYtOCcsIGVycm9ycz0naWdub3JlJykgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBmLnJlYWRsaW5lcygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxpbmVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lcyA9ICcnLmpvaW4obGluZXNbLTU6XSkgICMgTGFzdCA1IGxpbmVzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBsYXN0X2xpbmVzLnN0cmlwKCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnICs9IGYiXG5cbkxhc3QgbG9nIGVudHJpZXM6XG57bGFzdF9saW5lc1s6NDAwXX0iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgIyBUcnkgdG8gZ2V0IG1vcmUgaW5mbyBieSBydW5uaW5nIHRoZSBzY3JpcHQgZGlyZWN0bHkKICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0X3Rlc3QgPSBzdWJwcm9jZXNzLnJ1bigKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtweXRob25fY21kLCBzY3JpcHRfcGF0aF0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dD1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dD01LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3dkPUJBU0VfRElSCiAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGlyZWN0X3Rlc3Quc3RkZXJyOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gZGlyZWN0X3Rlc3Quc3RkZXJyWzo1MDBdCiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgZGlyZWN0X3Rlc3Quc3Rkb3V0OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnID0gZGlyZWN0X3Rlc3Quc3Rkb3V0Wzo1MDBdCiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlYm94LnNob3dlcnJvcigiRXJyb3IiLCBmIkZhaWxlZCB0byBzdGFydCBkYWVtb24uXG5cblB5dGhvbjoge3B5dGhvbl9jbWR9XG5TY3JpcHQ6IHtzY3JpcHRfcGF0aH1cblxuRXJyb3I6IHtlcnJvcl9tc2dbOjUwMF19IikKICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2Vycm9yKCJFcnJvciIsIGYiRmFpbGVkIHRvIHN0YXJ0IGRhZW1vbi5cblxuUHl0aG9uOiB7cHl0aG9uX2NtZH1cblNjcmlwdDoge3NjcmlwdF9wYXRofVxuXG5Qcm9jZXNzIGV4aXRlZCBpbW1lZGlhdGVseS4gQ2hlY2sgaWYgYWxsIGRlcGVuZGVuY2llcyBhcmUgaW5zdGFsbGVkLlxuXG5FeGNlcHRpb246IHtlfSIpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIAogICAgICAgICAgICAjIENoZWNrIGlmIGxvY2sgZmlsZSBleGlzdHMgKGV2ZW4gaWYgcHJvY2VzcyBjaGVjayBmYWlscykKICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoTE9DS19GSUxFKToKICAgICAgICAgICAgICAgICAgICBsb2NrX2ZpbGVfY3JlYXRlZCA9IFRydWUKICAgICAgICAgICAgICAgICAgICBpZiB3YWl0ZWQgPCAwLjU6ICAjIE9ubHkgbG9nIG9uY2UKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBMb2NrIGZpbGUgZm91bmQgYXQ6IHtMT0NLX0ZJTEV9XG4iKQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgIyBDaGVjayBmb3IgcmVhZHkgZmlsZSAoZGFlbW9uIGZ1bGx5IGluaXRpYWxpemVkKQogICAgICAgICAgICAgICAgICAgICMgQWxzbyB2ZXJpZnkgdGhlIGZpbGUgYWN0dWFsbHkgaGFzIGNvbnRlbnQgKG5vdCBqdXN0IGNyZWF0ZWQpCiAgICAgICAgICAgICAgICAgICAgIyBUcnkgbXVsdGlwbGUgdGltZXMgd2l0aCBzbWFsbCBkZWxheSB0byBoYW5kbGUgZmlsZXN5c3RlbSBkZWxheXMKICAgICAgICAgICAgICAgICAgICByZWFkeV9maWxlX2ZvdW5kID0gRmFsc2UKICAgICAgICAgICAgICAgICAgICBmb3IgY2hlY2tfYXR0ZW1wdCBpbiByYW5nZSg1KTogICMgSW5jcmVhc2VkIHJldHJpZXMKICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoUkVBRFlfRklMRSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBWZXJpZnkgZmlsZSBoYXMgY29udGVudCBhbmQgaXMgcmVjZW50CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdCA9IG9zLnN0YXQoUkVBRFlfRklMRSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBzdGF0LnN0X3NpemUgPiAwOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIERvdWJsZS1jaGVjayB0aGUgcHJvY2VzcyBpcyBzdGlsbCBydW5uaW5nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHNlbGYuZGFlbW9uX3Byb2Nlc3MucG9sbCgpIGlzIE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIERhZW1vbiBpcyBmdWxseSByZWFkeSEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBSZWFkeSBmaWxlIGZvdW5kIGFuZCB2ZXJpZmllZCEgU2l6ZToge3N0YXQuc3Rfc2l6ZX0gYnl0ZXNcbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IERhZW1vbiBzdGFydGVkIHN1Y2Nlc3NmdWxseSFcbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi51cGRhdGVfc3RhdHVzKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2luZm8oIlN1Y2Nlc3MiLCAiRGVhdGggY291bnRlciBkYWVtb24gc3RhcnRlZCBzdWNjZXNzZnVsbHkhIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIyBQcm9jZXNzIGRpZWQgLSBicmVhayBvdXQgYW5kIHNob3cgZXJyb3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBSZWFkeSBmaWxlIGV4aXN0cyBidXQgcHJvY2VzcyBleGl0ZWQgKGNvZGU6IHtzZWxmLmRhZW1vbl9wcm9jZXNzLnJldHVybmNvZGV9KVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3BlbihHVUlfREVCVUdfTE9HLCAiYSIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogUmVhZHkgZmlsZSBleGlzdHMgYnV0IGlzIGVtcHR5IChhdHRlbXB0IHtjaGVja19hdHRlbXB0ICsgMX0pXG4iKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogRXJyb3IgY2hlY2tpbmcgcmVhZHkgZmlsZToge2V9XG4iKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgY2hlY2tfYXR0ZW1wdCA9PSAwIGFuZCB3YWl0ZWQgPiAxOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKEdVSV9ERUJVR19MT0csICJhIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFJlYWR5IGZpbGUgbm90IGZvdW5kIHlldCAoYXR0ZW1wdCB7Y2hlY2tfYXR0ZW1wdCArIDF9KSwgd2FpdGVkIHt3YWl0ZWQ6LjFmfXNcbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBMT0NLX0ZJTEUgZXhpc3RzOiB7b3MucGF0aC5leGlzdHMoTE9DS19GSUxFKX1cbiIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLndyaXRlKGYiR1VJOiBSRUFEWV9GSUxFIGV4aXN0czoge29zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpfVxuIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICAgICAgIyBTbWFsbCBkZWxheSBiZWZvcmUgcmV0cnkgKGZpbGVzeXN0ZW0gbWlnaHQgbmVlZCB0aW1lKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBjaGVja19hdHRlbXB0IDwgNDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUuc2xlZXAoMC4yKQogICAgICAgICAgICAgICAgICAgICMgTG9jayBmaWxlIGV4aXN0cyBidXQgbm90IHJlYWR5IHlldCAtIGNoZWNrIGRlYnVnLmxvZyB0byBzZWUgd2hhdCdzIGhhcHBlbmluZwogICAgICAgICAgICAgICAgICAgIGxvZ19maWxlID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZGVidWcubG9nIikKICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhsb2dfZmlsZSkgYW5kIHdhaXRlZCA+IDI6ICAjIE9ubHkgY2hlY2sgbG9nIGFmdGVyIDIgc2Vjb25kcwogICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4obG9nX2ZpbGUsICdyJywgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPSdpZ25vcmUnKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gZi5yZWFkbGluZXMoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxpbmVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmUgPSBsaW5lc1stMV0uc3RyaXAoKSBpZiBsaW5lcyBlbHNlICIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICMgSWYgd2Ugc2VlICJSZWFkeSBmaWxlIGNyZWF0ZWQiIGJ1dCBmaWxlIGRvZXNuJ3QgZXhpc3QsIHRoZXJlJ3MgYSBmaWxlc3lzdGVtIGlzc3VlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICJSZWFkeSBmaWxlIGNyZWF0ZWQiIGluIGxhc3RfbGluZSBvciAiUkVBRFlfRklMRSBjcmVhdGVkIiBpbiBsYXN0X2xpbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjIEZpbGUgc2hvdWxkIGV4aXN0IC0gbWF5YmUgZmlsZXN5c3RlbSBkZWxheSwgd2FpdCBhIGJpdCBtb3JlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDAuNSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudXBkYXRlX3N0YXR1cygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93aW5mbygiU3VjY2VzcyIsICJEZWF0aCBjb3VudGVyIGRhZW1vbiBzdGFydGVkIHN1Y2Nlc3NmdWxseSEiKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICAgICAgIyBMb2NrIGZpbGUgZXhpc3RzIGJ1dCBub3QgcmVhZHkgeWV0IC0gZ2l2ZSBpdCBtb3JlIHRpbWUKICAgICAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDAuMikKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAjIEFsc28gY2hlY2sgaWYgcHJvY2VzcyBpcyBzdGlsbCBydW5uaW5nIChldmVuIHdpdGhvdXQgbG9jayBmaWxlIHlldCkKICAgICAgICAgICAgZWxpZiBzZWxmLmRhZW1vbl9wcm9jZXNzLnBvbGwoKSBpcyBOb25lOgogICAgICAgICAgICAgICAgIyBQcm9jZXNzIGlzIHJ1bm5pbmcsIG1pZ2h0IHN0aWxsIGJlIGluaXRpYWxpemluZwogICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgCiAgICAgICAgICAgICMgV2FpdCBhIGJpdCBiZWZvcmUgY2hlY2tpbmcgYWdhaW4KICAgICAgICAgICAgdGltZS5zbGVlcChjaGVja19pbnRlcnZhbCkKICAgICAgICAgICAgd2FpdGVkICs9IGNoZWNrX2ludGVydmFsCiAgICAgICAgCiAgICAgICAgIyBUaW1lb3V0IC0gY2hlY2sgd2hhdCBoYXBwZW5lZAogICAgICAgICMgTG9nIHRpbWVvdXQgdG8gZGVidWcgZmlsZQogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgZGVidWdfbG9nX2NyZWF0ZWQ6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oR1VJX0RFQlVHX0xPRywgImEiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFRJTUVPVVQgYWZ0ZXIge3dhaXRlZDouMWZ9IHNlY29uZHNcbiIpCiAgICAgICAgICAgICAgICAgICAgZi53cml0ZShmIkdVSTogTE9DS19GSUxFIGV4aXN0czoge29zLnBhdGguZXhpc3RzKExPQ0tfRklMRSl9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFJFQURZX0ZJTEUgZXhpc3RzOiB7b3MucGF0aC5leGlzdHMoUkVBRFlfRklMRSl9XG4iKQogICAgICAgICAgICAgICAgICAgIGYud3JpdGUoZiJHVUk6IFByb2Nlc3MgcnVubmluZzoge3NlbGYuZGFlbW9uX3Byb2Nlc3MucG9sbCgpIGlzIE5vbmV9XG4iKQogICAgICAgICAgICAgICAgICAgIGYuZmx1c2goKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwogICAgICAgIAogICAgICAgICMgRmlyc3QsIGNoZWNrIGZvciBzdGFydHVwIGVycm9yIGZpbGUKICAgICAgICBzdGFydHVwX2Vycm9yX2ZpbGUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkYWVtb25fc3RhcnR1cF9lcnJvci50eHQiKQogICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKHN0YXJ0dXBfZXJyb3JfZmlsZSk6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHdpdGggb3BlbihzdGFydHVwX2Vycm9yX2ZpbGUsICdyJywgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPSdpZ25vcmUnKSBhcyBmOgogICAgICAgICAgICAgICAgICAgIGVycm9yX2NvbnRlbnQgPSBmLnJlYWQoKS5zdHJpcCgpCiAgICAgICAgICAgICAgICBpZiBlcnJvcl9jb250ZW50OgogICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2Vycm9yKCJEYWVtb24gU3RhcnR1cCBFcnJvciIsIAogICAgICAgICAgICAgICAgICAgICAgICBmIkRhZW1vbiBlbmNvdW50ZXJlZCBhbiBlcnJvciBkdXJpbmcgc3RhcnR1cDpcblxue2Vycm9yX2NvbnRlbnRbOjEwMDBdfVxuXG4iCiAgICAgICAgICAgICAgICAgICAgICAgIGYiUHl0aG9uOiB7cHl0aG9uX2NtZH1cblNjcmlwdDoge3NjcmlwdF9wYXRofSIpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAKICAgICAgICBpZiBwcm9jZXNzX2V4aXRlZDoKICAgICAgICAgICAgIyBBbHJlYWR5IGhhbmRsZWQgYWJvdmUKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgZWxpZiBsb2NrX2ZpbGVfY3JlYXRlZCBhbmQgb3MucGF0aC5leGlzdHMoUkVBRFlfRklMRSk6CiAgICAgICAgICAgICMgQm90aCBmaWxlcyBleGlzdCAtIGRhZW1vbiBzaG91bGQgYmUgcnVubmluZwogICAgICAgICAgICBpZiBzZWxmLmlzX2RhZW1vbl9ydW5uaW5nKCk6CiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZV9zdGF0dXMoKQogICAgICAgICAgICAgICAgbWVzc2FnZWJveC5zaG93aW5mbygiU3VjY2VzcyIsICJEZWF0aCBjb3VudGVyIGRhZW1vbiBzdGFydGVkIHN1Y2Nlc3NmdWxseSEiKQogICAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBlcnJvcl9tc2cgPSAiUmVhZHkgZmlsZSBleGlzdHMgYnV0IHByb2Nlc3MgaXMgbm90IHJ1bm5pbmcuIgogICAgICAgIGVsaWYgbG9ja19maWxlX2NyZWF0ZWQ6CiAgICAgICAgICAgICMgTG9jayBmaWxlIGV4aXN0cyBidXQgcmVhZHkgZmlsZSBkb2Vzbid0IC0gZGFlbW9uIG1heSBiZSBzdHVjayBpbml0aWFsaXppbmcKICAgICAgICAgICAgZXJyb3JfbXNnID0gIkxvY2sgZmlsZSBleGlzdHMgYnV0IGRhZW1vbiBkaWQgbm90IGZpbmlzaCBpbml0aWFsaXppbmcgKHJlYWR5IGZpbGUgbWlzc2luZykuIgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oTE9DS19GSUxFLCAiciIpIGFzIGY6CiAgICAgICAgICAgICAgICAgICAgcGlkX3N0ciA9IGYucmVhZCgpLnN0cmlwKCkKICAgICAgICAgICAgICAgIGVycm9yX21zZyA9IGYiTG9jayBmaWxlIGV4aXN0cyAoUElEOiB7cGlkX3N0cn0pIGJ1dCBkYWVtb24gZGlkIG5vdCBmaW5pc2ggaW5pdGlhbGl6aW5nIChyZWFkeSBmaWxlIG1pc3NpbmcpLiIKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgIyBDaGVjayBpZiBwcm9jZXNzIGlzIHN0aWxsIHJ1bm5pbmcKICAgICAgICAgICAgICAgIHByb2Nlc3NfcnVubmluZyA9IEZhbHNlCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgaW1wb3J0IHBzdXRpbAogICAgICAgICAgICAgICAgICAgIGlmIHBpZF9zdHI6CiAgICAgICAgICAgICAgICAgICAgICAgIHBpZCA9IGludChwaWRfc3RyKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBwc3V0aWwucGlkX2V4aXN0cyhwaWQpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc19ydW5uaW5nID0gVHJ1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnICs9IGYiXG5cblByb2Nlc3Mge3BpZH0gaXMgc3RpbGwgcnVubmluZy4iCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9tc2cgKz0gZiJcblxuUHJvY2VzcyB7cGlkfSBpcyBOT1QgcnVubmluZyAoc3RhbGUgbG9jayBmaWxlKS4iCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgIyBGYWxsYmFjazogY2hlY2sgaWYgZGFlbW9uIHByb2Nlc3MgaXMgc3RpbGwgcnVubmluZwogICAgICAgICAgICAgICAgICAgIGlmIHNlbGYuZGFlbW9uX3Byb2Nlc3MucG9sbCgpIGlzIE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NfcnVubmluZyA9IFRydWUKICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnICs9ICJcblxuRGFlbW9uIHByb2Nlc3MgaXMgc3RpbGwgcnVubmluZy4iCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICMgSWYgcHJvY2VzcyBpcyBydW5uaW5nIGJ1dCByZWFkeSBmaWxlIG1pc3NpbmcsIGNoZWNrIGlmIGl0J3MganVzdCBzbG93CiAgICAgICAgICAgICAgICBpZiBwcm9jZXNzX3J1bm5pbmc6CiAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnICs9ICJcblxuVGhpcyBtaWdodCBiZSBhIGZpbGVzeXN0ZW0gZGVsYXkuIFRoZSBkYWVtb24gbWF5IHN0aWxsIGJlIHN0YXJ0aW5nLiIKICAgICAgICAgICAgICAgICAgICBlcnJvcl9tc2cgKz0gIlxuQ2hlY2sgZGVidWcubG9nIHRvIHNlZSBpZiAnUmVhZHkgZmlsZSBjcmVhdGVkJyBhcHBlYXJzLiIKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAKICAgICAgICAgICAgIyBDaGVjayBkZWJ1Zy5sb2cKICAgICAgICAgICAgbG9nX2ZpbGUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkZWJ1Zy5sb2ciKQogICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhsb2dfZmlsZSk6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKGxvZ19maWxlLCAncicsIGVuY29kaW5nPSd1dGYtOCcsIGVycm9ycz0naWdub3JlJykgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBmLnJlYWRsaW5lcygpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxpbmVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lcyA9ICcnLmpvaW4obGluZXNbLTE1Ol0pICAjIExhc3QgMTUgbGluZXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX21zZyArPSBmIlxuXG5MYXN0IGxvZyBlbnRyaWVzOlxue2xhc3RfbGluZXNbOjUwMF19IgogICAgICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgCiAgICAgICAgICAgIG1lc3NhZ2Vib3guc2hvd2Vycm9yKCJFcnJvciIsIGYie2Vycm9yX21zZ31cblxuUHl0aG9uOiB7cHl0aG9uX2NtZH1cblNjcmlwdDoge3NjcmlwdF9wYXRofVxuXG5Ucnkgc3RvcHBpbmcgYW55IGV4aXN0aW5nIGRhZW1vbiBmaXJzdCwgdGhlbiBzdGFydCBhZ2Fpbi4iKQogICAgICAgIGVsaWYgc2VsZi5kYWVtb25fcHJvY2Vzcy5wb2xsKCkgaXMgTm9uZToKICAgICAgICAgICAgIyBQcm9jZXNzIGlzIHN0aWxsIHJ1bm5pbmcgYnV0IG5vIGxvY2sgZmlsZQogICAgICAgICAgICBlcnJvcl9tc2cgPSAiRGFlbW9uIHByb2Nlc3MgaXMgcnVubmluZyBidXQgZmFpbGVkIHRvIGNyZWF0ZSBsb2NrIGZpbGUuIgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAjIENoZWNrIGRlYnVnLmxvZyBmb3IgZXJyb3JzCiAgICAgICAgICAgICAgICBsb2dfZmlsZSA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYnVnLmxvZyIpCiAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhsb2dfZmlsZSk6CiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKGxvZ19maWxlLCAncicsIGVuY29kaW5nPSd1dGYtOCcsIGVycm9ycz0naWdub3JlJykgYXMgZjoKICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBmLnJlYWRsaW5lcygpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxpbmVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lcyA9ICcnLmpvaW4obGluZXNbLTE1Ol0pICAjIExhc3QgMTUgbGluZXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX21zZyArPSBmIlxuXG5MYXN0IGxvZyBlbnRyaWVzOlxue2xhc3RfbGluZXNbOjUwMF19IgogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBlcnJvcl9tc2cgKz0gIlxuXG5ObyBkZWJ1Zy5sb2cgZm91bmQgLSBkYWVtb24gbWF5IG5vdCBoYXZlIGluaXRpYWxpemVkLiIKICAgICAgICAgICAgZXhjZXB0OgogICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICBtZXNzYWdlYm94LnNob3dlcnJvcigiRXJyb3IiLCBmIntlcnJvcl9tc2d9XG5cblB5dGhvbjoge3B5dGhvbl9jbWR9XG5TY3JpcHQ6IHtzY3JpcHRfcGF0aH1cblxuQ2hlY2sgaWYgYWxsIGRlcGVuZGVuY2llcyBhcmUgaW5zdGFsbGVkIGFuZCBUZXNzZXJhY3QgT0NSIGlzIGluc3RhbGxlZC4iKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgICMgUHJvY2VzcyBleGl0ZWQgZHVyaW5nIHdhaXQKICAgICAgICAgICAgZXJyb3JfbXNnID0gIlByb2Nlc3MgZXhpdGVkIGJlZm9yZSBjcmVhdGluZyBsb2NrIGZpbGUuIgogICAgICAgICAgICAjIENoZWNrIGRlYnVnLmxvZwogICAgICAgICAgICBsb2dfZmlsZSA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYnVnLmxvZyIpCiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKGxvZ19maWxlKToKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4obG9nX2ZpbGUsICdyJywgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPSdpZ25vcmUnKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGYucmVhZGxpbmVzKCkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGluZXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmVzID0gJycuam9pbihsaW5lc1stMTU6XSkgICMgTGFzdCAxNSBsaW5lcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfbXNnICs9IGYiXG5cbkxhc3QgbG9nIGVudHJpZXM6XG57bGFzdF9saW5lc1s6NTAwXX0iCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICBtZXNzYWdlYm94LnNob3dlcnJvcigiRXJyb3IiLCBmIntlcnJvcl9tc2d9XG5cblB5dGhvbjoge3B5dGhvbl9jbWR9XG5TY3JpcHQ6IHtzY3JpcHRfcGF0aH1cblxuQ2hlY2sgZGVidWcubG9nIGZvciBkZXRhaWxzLiIpCiAgICAKICAgIGRlZiBzdG9wX2RhZW1vbihzZWxmKToKICAgICAgICAiIiJTdG9wIHRoZSBkZWF0aCBjb3VudGVyIGRhZW1vbi4iIiIKICAgICAgICBpZiBub3Qgc2VsZi5pc19kYWVtb25fcnVubmluZygpOgogICAgICAgICAgICAjIFNpbGVudGx5IHJldHVybiAtIG5vIHBvcHVwCiAgICAgICAgICAgIHJldHVybgogICAgICAgIAogICAgICAgIHRyeToKICAgICAgICAgICAgIyBDcmVhdGUgU1RPUCBmaWxlCiAgICAgICAgICAgIHdpdGggb3BlbihTVE9QX0ZJTEUsICJ3IikgYXMgZjoKICAgICAgICAgICAgICAgIGYud3JpdGUoIiIpCiAgICAgICAgICAgIAogICAgICAgICAgICAjIFdhaXQgZm9yIGRhZW1vbiB0byBzdG9wCiAgICAgICAgICAgIGZvciBpIGluIHJhbmdlKDEwKToKICAgICAgICAgICAgICAgIHRpbWUuc2xlZXAoMSkKICAgICAgICAgICAgICAgIGlmIG5vdCBzZWxmLmlzX2RhZW1vbl9ydW5uaW5nKCk6CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgCiAgICAgICAgICAgICMgSWYgc3RpbGwgcnVubmluZywgdHJ5IHRvIGtpbGwgcHJvY2VzcwogICAgICAgICAgICBpZiBzZWxmLmlzX2RhZW1vbl9ydW5uaW5nKCk6CiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKExPQ0tfRklMRSwgInIiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgICAgICBwaWQgPSBmLnJlYWQoKS5zdHJpcCgpCiAgICAgICAgICAgICAgICAgICAgaWYgcGlkOgogICAgICAgICAgICAgICAgICAgICAgICBzdWJwcm9jZXNzLnJ1bihbInRhc2traWxsIiwgIi9GIiwgIi9QSUQiLCBwaWRdLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVfb3V0cHV0PVRydWUsIGNoZWNrPUZhbHNlKQogICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKExPQ0tfRklMRSk6CiAgICAgICAgICAgICAgICAgICAgICAgIG9zLnJlbW92ZShMT0NLX0ZJTEUpCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAKICAgICAgICAgICAgIyBDbGVhbiB1cAogICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhTVE9QX0ZJTEUpOgogICAgICAgICAgICAgICAgb3MucmVtb3ZlKFNUT1BfRklMRSkKICAgICAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoUkVBRFlfRklMRSk6CiAgICAgICAgICAgICAgICBvcy5yZW1vdmUoUkVBRFlfRklMRSkKICAgICAgICAgICAgCiAgICAgICAgICAgIHNlbGYudXBkYXRlX3N0YXR1cygpCiAgICAgICAgICAgICMgU2lsZW50bHkgc3RvcCAtIG5vIHBvcHVwCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAjIFNpbGVudGx5IGZhaWwgLSBubyBwb3B1cAogICAgICAgICAgICBwYXNzCiAgICAKICAgIGRlZiB1cGRhdGVfc3RhdHVzKHNlbGYpOgogICAgICAgICIiIlVwZGF0ZSB0aGUgVUkgd2l0aCBjdXJyZW50IHN0YXR1cy4iIiIKICAgICAgICAjIENoZWNrIGlmIFVJIGVsZW1lbnRzIGV4aXN0ICh0aGV5IG1pZ2h0IG5vdCBkdXJpbmcgaW5pdGlhbGl6YXRpb24pCiAgICAgICAgaWYgbm90IGhhc2F0dHIoc2VsZiwgJ3N0YXR1c19sYWJlbCcpOgogICAgICAgICAgICByZXR1cm4KICAgICAgICAKICAgICAgICAjIFVwZGF0ZSBkYWVtb24gc3RhdHVzCiAgICAgICAgcnVubmluZyA9IHNlbGYuaXNfZGFlbW9uX3J1bm5pbmcoKQogICAgICAgIGlmIHJ1bm5pbmc6CiAgICAgICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsLmNvbmZpZyh0ZXh0PSJTdGF0dXM6IFJ1bm5pbmciLCBmb3JlZ3JvdW5kPSJncmVlbiIpCiAgICAgICAgICAgIGlmIGhhc2F0dHIoc2VsZiwgJ3N0YXJ0X2J1dHRvbicpOgogICAgICAgICAgICAgICAgc2VsZi5zdGFydF9idXR0b24uY29uZmlnKHN0YXRlPURJU0FCTEVEKQogICAgICAgICAgICBpZiBoYXNhdHRyKHNlbGYsICdzdG9wX2J1dHRvbicpOgogICAgICAgICAgICAgICAgc2VsZi5zdG9wX2J1dHRvbi5jb25maWcoc3RhdGU9Tk9STUFMKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYuc3RhdHVzX2xhYmVsLmNvbmZpZyh0ZXh0PSJTdGF0dXM6IFN0b3BwZWQiLCBmb3JlZ3JvdW5kPSJyZWQiKQogICAgICAgICAgICBpZiBoYXNhdHRyKHNlbGYsICdzdGFydF9idXR0b24nKToKICAgICAgICAgICAgICAgIHNlbGYuc3RhcnRfYnV0dG9uLmNvbmZpZyhzdGF0ZT1OT1JNQUwpCiAgICAgICAgICAgIGlmIGhhc2F0dHIoc2VsZiwgJ3N0b3BfYnV0dG9uJyk6CiAgICAgICAgICAgICAgICBzZWxmLnN0b3BfYnV0dG9uLmNvbmZpZyhzdGF0ZT1ESVNBQkxFRCkKICAgICAgICAKICAgICAgICAjIFVwZGF0ZSBnYW1lIGFuZCBkZWF0aCBjb3VudCBvbiB0aGUgYnV0dG9uCiAgICAgICAgY3VycmVudF9nYW1lID0gc2VsZi5nZXRfY3VycmVudF9nYW1lKCkKICAgICAgICBkZWF0aF9jb3VudCA9IHNlbGYuZ2V0X2RlYXRoX2NvdW50KGN1cnJlbnRfZ2FtZSkKICAgICAgICB0b3RhbF9kZWF0aHMgPSBzZWxmLmdldF90b3RhbF9kZWF0aHMoKQogICAgICAgIAogICAgICAgICMgVXBkYXRlIHRoZSBsYWJlbHMgc2VwYXJhdGVseQogICAgICAgIGlmIGhhc2F0dHIoc2VsZiwgJ2RlYXRoX2NvdW50X2xhYmVsJykgYW5kIGhhc2F0dHIoc2VsZiwgJ2dhbWVfbmFtZV9sYWJlbCcpOgogICAgICAgICAgICBzZWxmLmRlYXRoX2NvdW50X2xhYmVsLmNvbmZpZyh0ZXh0PXN0cihkZWF0aF9jb3VudCkpCiAgICAgICAgICAgIHNlbGYuZ2FtZV9uYW1lX2xhYmVsLmNvbmZpZyh0ZXh0PWN1cnJlbnRfZ2FtZSkKICAgICAgICAKICAgICAgICAjIFVwZGF0ZSB0b3RhbCBkZWF0aHMgZGlzcGxheQogICAgICAgIGlmIGhhc2F0dHIoc2VsZiwgJ3RvdGFsX2RlYXRoc19sYWJlbCcpOgogICAgICAgICAgICBzZWxmLnRvdGFsX2RlYXRoc19sYWJlbC5jb25maWcodGV4dD1mIlRvdGFsIERlYXRoczoge3RvdGFsX2RlYXRoc30iKQogICAgCiAgICBkZWYgc3RhcnRfbW9uaXRvcmluZyhzZWxmKToKICAgICAgICAiIiJTdGFydCBiYWNrZ3JvdW5kIHRocmVhZCB0byBtb25pdG9yIHN0YXR1cy4iIiIKICAgICAgICBzZWxmLm1vbml0b3JpbmcgPSBUcnVlCiAgICAgICAgCiAgICAgICAgZGVmIG1vbml0b3IoKToKICAgICAgICAgICAgd2hpbGUgc2VsZi5tb25pdG9yaW5nOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIHNlbGYucm9vdC5hZnRlcigwLCBzZWxmLnVwZGF0ZV9zdGF0dXMpCiAgICAgICAgICAgICAgICAgICAgdGltZS5zbGVlcCgyKSAgIyBVcGRhdGUgZXZlcnkgMiBzZWNvbmRzCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAKICAgICAgICB0aHJlYWQgPSB0aHJlYWRpbmcuVGhyZWFkKHRhcmdldD1tb25pdG9yLCBkYWVtb249VHJ1ZSkKICAgICAgICB0aHJlYWQuc3RhcnQoKQogICAgCiAgICBkZWYgb25fY2xvc2luZyhzZWxmKToKICAgICAgICAiIiJIYW5kbGUgd2luZG93IGNsb3NpbmcuIiIiCiAgICAgICAgc2VsZi5tb25pdG9yaW5nID0gRmFsc2UKICAgICAgICBzZWxmLnJvb3QuZGVzdHJveSgpCgoKZGVmIG1haW4oKToKICAgICMgUHJldmVudCBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIEdVSSB1c2luZyBXaW5kb3dzIG11dGV4CiAgICAjIENoZWNrIG11dGV4IEJFRk9SRSBjcmVhdGluZyBhbnkgR1VJIGVsZW1lbnRzCiAgICBtdXRleCA9IE5vbmUKICAgIGtlcm5lbDMyID0gTm9uZQogICAgdHJ5OgogICAgICAgIGltcG9ydCBjdHlwZXMKICAgICAgICBtdXRleF9uYW1lID0gIkdsb2JhbFxcRGVhdGhDb3VudGVyR1VJTXV0ZXgiCiAgICAgICAga2VybmVsMzIgPSBjdHlwZXMud2luZGxsLmtlcm5lbDMyCiAgICAgICAgbXV0ZXggPSBrZXJuZWwzMi5DcmVhdGVNdXRleFcoTm9uZSwgRmFsc2UsIG11dGV4X25hbWUpCiAgICAgICAgbGFzdF9lcnJvciA9IGtlcm5lbDMyLkdldExhc3RFcnJvcigpCiAgICAgICAgCiAgICAgICAgIyBJZiBFUlJPUl9BTFJFQURZX0VYSVNUUywgYW5vdGhlciBHVUkgaW5zdGFuY2UgaXMgcnVubmluZwogICAgICAgIGlmIGxhc3RfZXJyb3IgPT0gMTgzOiAgIyBFUlJPUl9BTFJFQURZX0VYSVNUUwogICAgICAgICAgICBpZiBtdXRleDoKICAgICAgICAgICAgICAgIGtlcm5lbDMyLkNsb3NlSGFuZGxlKG11dGV4KQogICAgICAgICAgICAjIEV4aXQgaW1tZWRpYXRlbHkgLSBHVUkgYWxyZWFkeSBydW5uaW5nCiAgICAgICAgICAgIHN5cy5leGl0KDApCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICMgSWYgbXV0ZXggZmFpbHMsIGNvbnRpbnVlIGFueXdheQogICAgICAgIHBhc3MKICAgIAogICAgcm9vdCA9IFRrKCkKICAgIGFwcCA9IERlYXRoQ291bnRlckdVSShyb290KQogICAgCiAgICBkZWYgY2xlYW51cCgpOgogICAgICAgIHRyeToKICAgICAgICAgICAgaWYgbXV0ZXggYW5kIGtlcm5lbDMyOgogICAgICAgICAgICAgICAga2VybmVsMzIuQ2xvc2VIYW5kbGUobXV0ZXgpCiAgICAgICAgZXhjZXB0OgogICAgICAgICAgICBwYXNzCiAgICAgICAgaWYgaGFzYXR0cihhcHAsICdvbl9jbG9zaW5nJyk6CiAgICAgICAgICAgIGFwcC5vbl9jbG9zaW5nKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICByb290LmRlc3Ryb3koKQogICAgCiAgICByb290LnByb3RvY29sKCJXTV9ERUxFVEVfV0lORE9XIiwgY2xlYW51cCkKICAgIAogICAgdHJ5OgogICAgICAgIHJvb3QubWFpbmxvb3AoKQogICAgZmluYWxseToKICAgICAgICBjbGVhbnVwKCkKCgppZiBfX25hbWVfXyA9PSAiX19tYWluX18iOgogICAgbWFpbigpCg==",
  "switch_game_manual.py": "IiIiDQpNYW51YWxseSBTd2l0Y2ggR2FtZQ0KU3dpdGNoIHRoZSBkZWF0aCBjb3VudGVyIHRvIGEgc3BlY2lmaWMgZ2FtZSBtYW51YWxseS4NCg0KVXNhZ2U6DQogICAgcHl0aG9uIHN3aXRjaF9nYW1lX21hbnVhbC5weSAiRWxkZW4gUmluZyINCiAgICBweXRob24gc3dpdGNoX2dhbWVfbWFudWFsLnB5ICJEYXJrIFNvdWxzIDMiDQoiIiINCg0KaW1wb3J0IG9zDQppbXBvcnQgc3lzDQppbXBvcnQganNvbg0KDQojIEdldCB0aGUgZGlyZWN0b3J5IHdoZXJlIHRoaXMgc2NyaXB0IGlzIGxvY2F0ZWQNCmRlZiBnZXRfYmFzZV9kaXIoKToNCiAgICAiIiJHZXQgdGhlIGJhc2UgZGlyZWN0b3J5IC0gc2FtZSBmb2xkZXIgYXMgdGhpcyBzY3JpcHQuIiIiDQogICAgcmV0dXJuIG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgoX19maWxlX18pKQ0KDQpCQVNFX0RJUiA9IGdldF9iYXNlX2RpcigpDQpDT05GSUdfRklMRSA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImdhbWVzX2NvbmZpZy5qc29uIikNClNUQVRFX0pTT04gPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkZWF0aF9zdGF0ZS5qc29uIikNCkRFQVRIX1RYVCA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYXRoX2NvdW50ZXIudHh0IikNCg0KDQpkZWYgbG9hZF9jb25maWcoKToNCiAgICAiIiJMb2FkIGdhbWUgY29uZmlndXJhdGlvbnMgZnJvbSBKU09OIGZpbGUuIiIiDQogICAgaWYgbm90IG9zLnBhdGguZXhpc3RzKENPTkZJR19GSUxFKToNCiAgICAgICAgcHJpbnQoZiJbRVJST1JdIENvbmZpZyBmaWxlIG5vdCBmb3VuZDoge0NPTkZJR19GSUxFfSIpDQogICAgICAgIHJldHVybiBOb25lDQogICAgDQogICAgdHJ5Og0KICAgICAgICB3aXRoIG9wZW4oQ09ORklHX0ZJTEUsICJyIiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgIHJldHVybiBqc29uLmxvYWQoZikNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIHByaW50KGYiW0VSUk9SXSBGYWlsZWQgdG8gbG9hZCBjb25maWc6IHtlfSIpDQogICAgICAgIHJldHVybiBOb25lDQoNCg0KZGVmIGxvYWRfc3RhdGUoKToNCiAgICAiIiJMb2FkIHN0YXRlIGZyb20gSlNPTiBmaWxlLiIiIg0KICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhTVEFURV9KU09OKToNCiAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICAgICJ0b3RhbF9kZWF0aHMiOiAwLA0KICAgICAgICAgICAgImdhbWVfZGVhdGhzIjoge30sDQogICAgICAgICAgICAidGljayI6IDAsDQogICAgICAgICAgICAic3RyZWFrIjogMCwNCiAgICAgICAgICAgICJsYXN0X2RlYXRoX3RzIjogMC4wLA0KICAgICAgICAgICAgImN1cnJlbnRfZ2FtZSI6IE5vbmUsDQogICAgICAgIH0NCiAgICANCiAgICB0cnk6DQogICAgICAgIHdpdGggb3BlbihTVEFURV9KU09OLCAiciIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBzdGF0ZSA9IGpzb24ubG9hZChmKQ0KICAgIGV4Y2VwdDoNCiAgICAgICAgc3RhdGUgPSB7fQ0KICAgIA0KICAgIHN0YXRlLnNldGRlZmF1bHQoInRvdGFsX2RlYXRocyIsIDApDQogICAgc3RhdGUuc2V0ZGVmYXVsdCgiZ2FtZV9kZWF0aHMiLCB7fSkNCiAgICBzdGF0ZS5zZXRkZWZhdWx0KCJ0aWNrIiwgMCkNCiAgICBzdGF0ZS5zZXRkZWZhdWx0KCJzdHJlYWsiLCAwKQ0KICAgIHN0YXRlLnNldGRlZmF1bHQoImxhc3RfZGVhdGhfdHMiLCAwLjApDQogICAgc3RhdGUuc2V0ZGVmYXVsdCgiY3VycmVudF9nYW1lIiwgTm9uZSkNCiAgICByZXR1cm4gc3RhdGUNCg0KDQpkZWYgc2F2ZV9jb25maWcoY29uZmlnKToNCiAgICAiIiJTYXZlIGNvbmZpZ3VyYXRpb24gdG8gSlNPTiBmaWxlLiIiIg0KICAgIHRyeToNCiAgICAgICAgd2l0aCBvcGVuKENPTkZJR19GSUxFLCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBqc29uLmR1bXAoY29uZmlnLCBmLCBpbmRlbnQ9MikNCiAgICAgICAgcmV0dXJuIFRydWUNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIHByaW50KGYiW0VSUk9SXSBGYWlsZWQgdG8gc2F2ZSBjb25maWc6IHtlfSIpDQogICAgICAgIHJldHVybiBGYWxzZQ0KDQoNCmRlZiBzYXZlX3N0YXRlKHN0YXRlKToNCiAgICAiIiJTYXZlIHN0YXRlIHRvIEpTT04gZmlsZS4iIiINCiAgICB0cnk6DQogICAgICAgIHdpdGggb3BlbihTVEFURV9KU09OLCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBqc29uLmR1bXAoc3RhdGUsIGYsIGluZGVudD0yKQ0KICAgICAgICByZXR1cm4gVHJ1ZQ0KICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgcHJpbnQoZiJbRVJST1JdIEZhaWxlZCB0byBzYXZlIHN0YXRlOiB7ZX0iKQ0KICAgICAgICByZXR1cm4gRmFsc2UNCg0KDQpkZWYgd3JpdGVfdGV4dChkZWF0aHMsIGdhbWVfbmFtZSk6DQogICAgIiIiV3JpdGUgZGVhdGggY291bnQgdG8gdGV4dCBmaWxlLiIiIg0KICAgIHRyeToNCiAgICAgICAgIyBXcml0ZSBtYWluIGZpbGUNCiAgICAgICAgd2l0aCBvcGVuKERFQVRIX1RYVCwgInciLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOg0KICAgICAgICAgICAgZi53cml0ZShzdHIoZGVhdGhzKSkNCiAgICAgICAgDQogICAgICAgICMgV3JpdGUgcGVyLWdhbWUgZmlsZQ0KICAgICAgICBpZiBnYW1lX25hbWU6DQogICAgICAgICAgICBnYW1lX3R4dCA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgZiJkZWF0aF9jb3VudGVyX3tnYW1lX25hbWUucmVwbGFjZSgnICcsICdfJyl9LnR4dCIpDQogICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgc3RhdGUgPSBsb2FkX3N0YXRlKCkNCiAgICAgICAgICAgICAgICBnYW1lX2RlYXRocyA9IHN0YXRlLmdldCgiZ2FtZV9kZWF0aHMiLCB7fSkuZ2V0KGdhbWVfbmFtZSwgMCkNCiAgICAgICAgICAgICAgICB3aXRoIG9wZW4oZ2FtZV90eHQsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgICAgICAgICAgZi53cml0ZShzdHIoZ2FtZV9kZWF0aHMpKQ0KICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICAgICAgICAgIHByaW50KGYiW1dBUk5JTkddIENvdWxkIG5vdCB3cml0ZSBwZXItZ2FtZSBmaWxlOiB7ZX0iKQ0KICAgICAgICByZXR1cm4gVHJ1ZQ0KICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgcHJpbnQoZiJbRVJST1JdIEZhaWxlZCB0byB3cml0ZSB0ZXh0IGZpbGU6IHtlfSIpDQogICAgICAgIHJldHVybiBGYWxzZQ0KDQoNCmRlZiBzd2l0Y2hfZ2FtZShnYW1lX25hbWUpOg0KICAgICIiIlN3aXRjaCB0byB0aGUgc3BlY2lmaWVkIGdhbWUuIiIiDQogICAgcHJpbnQoIj0iICogNzApDQogICAgcHJpbnQoIk1BTlVBTCBHQU1FIFNXSVRDSCIpDQogICAgcHJpbnQoIj0iICogNzApDQogICAgDQogICAgIyBMb2FkIGNvbmZpZw0KICAgIGNvbmZpZyA9IGxvYWRfY29uZmlnKCkNCiAgICBpZiBub3QgY29uZmlnOg0KICAgICAgICByZXR1cm4gRmFsc2UNCiAgICANCiAgICBnYW1lcyA9IGNvbmZpZy5nZXQoImdhbWVzIiwge30pDQogICAgaWYgbm90IGdhbWVzOg0KICAgICAgICBwcmludCgiW0VSUk9SXSBObyBnYW1lcyBjb25maWd1cmVkIikNCiAgICAgICAgcmV0dXJuIEZhbHNlDQogICAgDQogICAgIyBDaGVjayBpZiBnYW1lIGV4aXN0cw0KICAgIGlmIGdhbWVfbmFtZSBub3QgaW4gZ2FtZXM6DQogICAgICAgIHByaW50KGYiW0VSUk9SXSBHYW1lICd7Z2FtZV9uYW1lfScgbm90IGZvdW5kIGluIGNvbmZpZ3VyYXRpb24uIikNCiAgICAgICAgcHJpbnQoZiJcbkF2YWlsYWJsZSBnYW1lczoiKQ0KICAgICAgICBmb3IgbmFtZSBpbiBnYW1lcy5rZXlzKCk6DQogICAgICAgICAgICBwcmludChmIiAgLSB7bmFtZX0iKQ0KICAgICAgICByZXR1cm4gRmFsc2UNCiAgICANCiAgICAjIExvYWQgc3RhdGUNCiAgICBzdGF0ZSA9IGxvYWRfc3RhdGUoKQ0KICAgIG9sZF9nYW1lID0gc3RhdGUuZ2V0KCJjdXJyZW50X2dhbWUiLCAiVW5rbm93biIpDQogICAgDQogICAgIyBVcGRhdGUgc3RhdGUNCiAgICBzdGF0ZVsiY3VycmVudF9nYW1lIl0gPSBnYW1lX25hbWUNCiAgICANCiAgICAjIFVwZGF0ZSBjb25maWcNCiAgICBjb25maWdbImN1cnJlbnRfZ2FtZSJdID0gZ2FtZV9uYW1lDQogICAgDQogICAgIyBHZXQgdGhlIGdhbWUncyBkZWF0aCBjb3VudA0KICAgIGdhbWVfZGVhdGhzID0gc3RhdGUuZ2V0KCJnYW1lX2RlYXRocyIsIHt9KS5nZXQoZ2FtZV9uYW1lLCAwKQ0KICAgIA0KICAgICMgU2F2ZSBmaWxlcw0KICAgIGlmIG5vdCBzYXZlX3N0YXRlKHN0YXRlKToNCiAgICAgICAgcmV0dXJuIEZhbHNlDQogICAgDQogICAgaWYgbm90IHNhdmVfY29uZmlnKGNvbmZpZyk6DQogICAgICAgIHJldHVybiBGYWxzZQ0KICAgIA0KICAgICMgVXBkYXRlIHRleHQgZmlsZXMNCiAgICB3cml0ZV90ZXh0KGdhbWVfZGVhdGhzLCBnYW1lX25hbWUpDQogICAgDQogICAgIyBTaG93IGluZm8NCiAgICBnYW1lX2NvbmZpZyA9IGdhbWVzW2dhbWVfbmFtZV0NCiAgICBwcmludChmIlxuW09LXSBTd2l0Y2hlZCBmcm9tICd7b2xkX2dhbWV9JyB0byAne2dhbWVfbmFtZX0nIikNCiAgICBwcmludChmIlxuR2FtZSBJbmZvOiIpDQogICAgcHJpbnQoZiIgIERlYXRoczoge2dhbWVfZGVhdGhzfSIpDQogICAgcHJpbnQoZiIgIE1vbml0b3I6IHtnYW1lX2NvbmZpZy5nZXQoJ21vbml0b3JfaW5kZXgnLCAnZGVmYXVsdCcpfSIpDQogICAgcHJpbnQoZiIgIFJlZ2lvbjoge2dhbWVfY29uZmlnLmdldCgncmVnaW9uJywge30pfSIpDQogICAgcHJpbnQoZiIgIEtleXdvcmRzOiB7Z2FtZV9jb25maWcuZ2V0KCdrZXl3b3JkcycsIFtdKX0iKQ0KICAgIA0KICAgIHByaW50KGYiXG5bT0tdIFRleHQgZmlsZXMgdXBkYXRlZDoiKQ0KICAgIHByaW50KGYiICAtIHtERUFUSF9UWFR9IC0+IHtnYW1lX2RlYXRoc30iKQ0KICAgIHByaW50KGYiICAtIGRlYXRoX2NvdW50ZXJfe2dhbWVfbmFtZS5yZXBsYWNlKCcgJywgJ18nKX0udHh0IC0+IHtnYW1lX2RlYXRoc30iKQ0KICAgIA0KICAgIHByaW50KCJcbiIgKyAiPSIgKiA3MCkNCiAgICBwcmludCgiW05PVEVdIFRoZSBkYWVtb24gd2lsbCBjb250aW51ZSBydW5uaW5nIHdpdGggdGhlIG5ldyBnYW1lLiIpDQogICAgcHJpbnQoIiAgICAgICBBdXRvLWRldGVjdGlvbiB3aWxsIG92ZXJyaWRlIHRoaXMgaWYgaXQgZGV0ZWN0cyBhIGRpZmZlcmVudCBnYW1lLiIpDQogICAgcHJpbnQoIj0iICogNzApDQogICAgDQogICAgcmV0dXJuIFRydWUNCg0KDQpkZWYgbWFpbigpOg0KICAgIGlmIGxlbihzeXMuYXJndikgPCAyOg0KICAgICAgICBwcmludCgiVXNhZ2U6IHB5dGhvbiBzd2l0Y2hfZ2FtZV9tYW51YWwucHkgXCJHYW1lIE5hbWVcIiIpDQogICAgICAgIHByaW50KCJcbkV4YW1wbGVzOiIpDQogICAgICAgIHByaW50KCcgIHB5dGhvbiBzd2l0Y2hfZ2FtZV9tYW51YWwucHkgIkVsZGVuIFJpbmciJykNCiAgICAgICAgcHJpbnQoJyAgcHl0aG9uIHN3aXRjaF9nYW1lX21hbnVhbC5weSAiRGFyayBTb3VscyAzIicpDQogICAgICAgIHByaW50KCcgIHB5dGhvbiBzd2l0Y2hfZ2FtZV9tYW51YWwucHkgIkRhcmsgU291bHMgUmVtYXN0ZXJlZCInKQ0KICAgICAgICBwcmludCgnICBweXRob24gc3dpdGNoX2dhbWVfbWFudWFsLnB5ICJTZWtpcm8iJykNCiAgICAgICAgcmV0dXJuIDENCiAgICANCiAgICBnYW1lX25hbWUgPSBzeXMuYXJndlsxXQ0KICAgIA0KICAgIGlmIHN3aXRjaF9nYW1lKGdhbWVfbmFtZSk6DQogICAgICAgIHJldHVybiAwDQogICAgZWxzZToNCiAgICAgICAgcmV0dXJuIDENCg0KDQppZiBfX25hbWVfXyA9PSAiX19tYWluX18iOg0KICAgIHN5cy5leGl0KG1haW4oKSkK",
  "games_config.json": "ew0KICAic2V0dGluZ3MiOiB7DQogICAgInRpY2tfc2Vjb25kcyI6IDAuMywNCiAgICAiZGVidWdfZXZlcnlfdGlja3MiOiAzMCwNCiAgICAiY29uc2VjdXRpdmVfaGl0cyI6IDIsDQogICAgImNvb2xkb3duX3NlY29uZHMiOiA1LjAsDQogICAgIm1vbml0b3JfaW5kZXgiOiAxDQogIH0sDQogICJnYW1lcyI6IHsNCiAgICAiRWxkZW4gUmluZyI6IHsNCiAgICAgICJyZWdpb24iOiB7DQogICAgICAgICJsZWZ0IjogNTIwLA0KICAgICAgICAidG9wIjogNDcwLA0KICAgICAgICAid2lkdGgiOiA4ODAsDQogICAgICAgICJoZWlnaHQiOiAyMDANCiAgICAgIH0sDQogICAgICAia2V5d29yZHMiOiBbDQogICAgICAgICJZT1VESUVEIiwNCiAgICAgICAgIllPVURJRSIsDQogICAgICAgICJZT1VERUQiLA0KICAgICAgICAiRElFRCINCiAgICAgIF0sDQogICAgICAidGVzc2VyYWN0X2NvbmZpZyI6ICItLW9lbSAzIC0tcHNtIDcgLWMgdGVzc2VkaXRfY2hhcl93aGl0ZWxpc3Q9WU9VRElFQURGVCIsDQogICAgICAibW9uaXRvcl9pbmRleCI6IDIsDQogICAgICAicHJvY2Vzc19uYW1lcyI6IFsNCiAgICAgICAgImVsZGVucmluZy5leGUiLA0KICAgICAgICAiZWxkZW4gcmluZy5leGUiDQogICAgICBdDQogICAgfSwNCiAgICAiRGFyayBTb3VscyAzIjogew0KICAgICAgInJlZ2lvbiI6IHsNCiAgICAgICAgImxlZnQiOiA1MjAsDQogICAgICAgICJ0b3AiOiA0NzAsDQogICAgICAgICJ3aWR0aCI6IDg4MCwNCiAgICAgICAgImhlaWdodCI6IDIwMA0KICAgICAgfSwNCiAgICAgICJrZXl3b3JkcyI6IFsNCiAgICAgICAgIllPVURJRUQiLA0KICAgICAgICAiWU9VRElFIiwNCiAgICAgICAgIllPVUQxRUQiLA0KICAgICAgICAiWU9VRGxFRCIsDQogICAgICAgICJZT1VESSIsDQogICAgICAgICJPVURJRUQiLA0KICAgICAgICAiWU9VRElFMCINCiAgICAgIF0sDQogICAgICAidGVzc2VyYWN0X2NvbmZpZyI6ICItLW9lbSAzIC0tcHNtIDcgLWMgdGVzc2VkaXRfY2hhcl93aGl0ZWxpc3Q9WU9VRElFQURGVCIsDQogICAgICAibW9uaXRvcl9pbmRleCI6IDIsDQogICAgICAicHJvY2Vzc19uYW1lcyI6IFsNCiAgICAgICAgImRhcmtzb3Vsc2lpaS5leGUiLA0KICAgICAgICAiZGFyayBzb3VscyBpaWkuZXhlIg0KICAgICAgXQ0KICAgIH0sDQogICAgIkRhcmsgU291bHMgUmVtYXN0ZXJlZCI6IHsNCiAgICAgICJyZWdpb24iOiB7DQogICAgICAgICJsZWZ0IjogNTIwLA0KICAgICAgICAidG9wIjogNDcwLA0KICAgICAgICAid2lkdGgiOiA4ODAsDQogICAgICAgICJoZWlnaHQiOiAyMDANCiAgICAgIH0sDQogICAgICAia2V5d29yZHMiOiBbDQogICAgICAgICJZT1VESUVEIiwNCiAgICAgICAgIllPVURJRSIsDQogICAgICAgICJZT1VEMUVEIiwNCiAgICAgICAgIllPVURsRUQiLA0KICAgICAgICAiWU9VREkiLA0KICAgICAgICAiT1VESUVEIiwNCiAgICAgICAgIllPVURJRTAiDQogICAgICBdLA0KICAgICAgInRlc3NlcmFjdF9jb25maWciOiAiLS1vZW0gMyAtLXBzbSA3IC1jIHRlc3NlZGl0X2NoYXJfd2hpdGVsaXN0PVlPVURJRUFERlQiLA0KICAgICAgIm1vbml0b3JfaW5kZXgiOiAyLA0KICAgICAgInByb2Nlc3NfbmFtZXMiOiBbDQogICAgICAgICJkYXJrc291bHNyZW1hc3RlcmVkLmV4ZSIsDQogICAgICAgICJkYXJrIHNvdWxzIHJlbWFzdGVyZWQuZXhlIg0KICAgICAgXQ0KICAgIH0sDQogICAgIkRhcmsgU291bHMgSUk6IFNjaG9sYXIgb2YgdGhlIEZpcnN0IFNpbiI6IHsNCiAgICAgICJyZWdpb24iOiB7DQogICAgICAgICJsZWZ0IjogNTIwLA0KICAgICAgICAidG9wIjogNDcwLA0KICAgICAgICAid2lkdGgiOiA4ODAsDQogICAgICAgICJoZWlnaHQiOiAyMDANCiAgICAgIH0sDQogICAgICAia2V5d29yZHMiOiBbDQogICAgICAgICJZT1VESUVEIiwNCiAgICAgICAgIllPVURJRSIsDQogICAgICAgICJZT1VEMUVEIiwNCiAgICAgICAgIllPVURsRUQiLA0KICAgICAgICAiWU9VREkiLA0KICAgICAgICAiT1VESUVEIiwNCiAgICAgICAgIllPVURJRTAiDQogICAgICBdLA0KICAgICAgInRlc3NlcmFjdF9jb25maWciOiAiLS1vZW0gMyAtLXBzbSA3IC1jIHRlc3NlZGl0X2NoYXJfd2hpdGVsaXN0PVlPVURJRUFERlQiLA0KICAgICAgIm1vbml0b3JfaW5kZXgiOiAyLA0KICAgICAgInByb2Nlc3NfbmFtZXMiOiBbDQogICAgICAgICJkYXJrc291bHNpaS5leGUiLA0KICAgICAgICAiZGFyayBzb3VscyBpaS5leGUiLA0KICAgICAgICAiZGFya3NvdWxzMi5leGUiDQogICAgICBdDQogICAgfSwNCiAgICAiU2VraXJvIjogew0KICAgICAgInJlZ2lvbiI6IHsNCiAgICAgICAgImxlZnQiOiA1MjAsDQogICAgICAgICJ0b3AiOiA0NzAsDQogICAgICAgICJ3aWR0aCI6IDg4MCwNCiAgICAgICAgImhlaWdodCI6IDIwMA0KICAgICAgfSwNCiAgICAgICJrZXl3b3JkcyI6IFsNCiAgICAgICAgIllPVURJRUQiLA0KICAgICAgICAiWU9VRElFIiwNCiAgICAgICAgIkRFQVRIIg0KICAgICAgXSwNCiAgICAgICJ0ZXNzZXJhY3RfY29uZmlnIjogIi0tb2VtIDMgLS1wc20gNyAtYyB0ZXNzZWRpdF9jaGFyX3doaXRlbGlzdD1ZT1VESUVBREZUIiwNCiAgICAgICJtb25pdG9yX2luZGV4IjogMiwNCiAgICAgICJwcm9jZXNzX25hbWVzIjogWw0KICAgICAgICAic2VraXJvLmV4ZSINCiAgICAgIF0NCiAgICB9DQogIH0sDQogICJjdXJyZW50X2dhbWUiOiAiRGFyayBTb3VscyBSZW1hc3RlcmVkIg0KfQo=",
  "START_DEATH_COUNTER.bat": "QGVjaG8gb2ZmDQpSRU0gU3RhcnQgRGVhdGggQ291bnRlciBEYWVtb24NClJFTSBUaGlzIGJhdGNoIGZpbGUgc3RhcnRzIHRoZSBkZWF0aCBjb3VudGVyIGRhZW1vbg0KUkVNIFdpbmRvdyB3aWxsIGJlIHBvc2l0aW9uZWQgaW4gdG9wIHJpZ2h0IGNvcm5lcg0KDQpjZCAvZCAiJX5kcDAiDQoNClJFTSBQb3NpdGlvbiB0aGlzIGNvbnNvbGUgd2luZG93IHRvIHRvcCByaWdodCBiZWZvcmUgc3RhcnRpbmcNCnBvd2Vyc2hlbGwgLUNvbW1hbmQgIiRob3N0LlVJLlJhd1VJLldpbmRvd1Bvc2l0aW9uID0gTmV3LU9iamVjdCBTeXN0ZW0uTWFuYWdlbWVudC5BdXRvbWF0aW9uLkhvc3QuQ29vcmRpbmF0ZXMgKChHZXQtSG9zdCkuVUkuUmF3VUkuQnVmZmVyU2l6ZS5XaWR0aCAtIDgwMCksIDAiDQoNCnB5dGhvbiBtdWx0aV9nYW1lX2RlYXRoX2NvdW50ZXIucHkNCg0KcGF1c2UK",
  "STOP_DEATH_COUNTER.bat": "QGVjaG8gb2ZmDQpSRU0gU3RvcCBEZWF0aCBDb3VudGVyIERhZW1vbg0KUkVNIFRoaXMgYmF0Y2ggZmlsZSBzdG9wcyB0aGUgZGVhdGggY291bnRlciBkYWVtb24gYnkgY3JlYXRpbmcgYSBTVE9QIGZpbGUNCg0KY2QgL2QgIiV+ZHAwIg0KZWNoby4gPiBTVE9QDQplY2hvIFNUT1AgZmlsZSBjcmVhdGVkLiBEYWVtb24gc2hvdWxkIHN0b3Agd2l0aGluIGEgZmV3IHNlY29uZHMuDQp0aW1lb3V0IC90IDIgL25vYnJlYWsgPm51bA0KDQppZiBleGlzdCBkYWVtb24ubG9jayAoDQogICAgZWNobyBEYWVtb24gbWF5IHN0aWxsIGJlIHJ1bm5pbmcuIENoZWNraW5nIGxvY2sgZmlsZS4uLg0KICAgIGZvciAvZiAidG9rZW5zPSoiICUlaSBpbiAoZGFlbW9uLmxvY2spIGRvICgNCiAgICAgICAgZWNobyBBdHRlbXB0aW5nIHRvIGtpbGwgcHJvY2VzcyAlJWkuLi4NCiAgICAgICAgdGFza2tpbGwgL0YgL1BJRCAlJWkgPm51bCAyPiYxDQogICAgKQ0KICAgIGRlbCBkYWVtb24ubG9jayA+bnVsIDI+JjENCiAgICBlY2hvIERhZW1vbiBzdG9wcGVkLg0KKSBlbHNlICgNCiAgICBlY2hvIERhZW1vbiBpcyBub3QgcnVubmluZy4NCikNCg0KaWYgZXhpc3QgU1RPUCBkZWwgU1RPUCA+bnVsIDI+JjENCnBhdXNlCg==",
  "install_dependencies.bat": "QGVjaG8gb2ZmDQpSRU0gSW5zdGFsbCBQeXRob24gRGVwZW5kZW5jaWVzIGZvciBEZWF0aCBDb3VudGVyDQpSRU0gVGhpcyBiYXRjaCBmaWxlIGluc3RhbGxzIGFsbCByZXF1aXJlZCBQeXRob24gcGFja2FnZXMNCg0KZWNobyBJbnN0YWxsaW5nIGRlcGVuZGVuY2llcyBmb3IgRGVhdGggQ291bnRlci4uLg0KZWNoby4NCg0KY2QgL2QgIiV+ZHAwIg0KDQpweXRob24gLW0gcGlwIGluc3RhbGwgLS11cGdyYWRlIHBpcA0KcHl0aG9uIC1tIHBpcCBpbnN0YWxsIG1zcyBwaWxsb3cgcHl0ZXNzZXJhY3Qgb3BlbmN2LXB5dGhvbiBudW1weSBwc3V0aWwNCg0KZWNoby4NCmVjaG8gSW5zdGFsbGF0aW9uIGNvbXBsZXRlIQ0KZWNoby4NCmVjaG8gTm90ZTogWW91IGFsc28gbmVlZCB0byBpbnN0YWxsIFRlc3NlcmFjdCBPQ1Igc2VwYXJhdGVseToNCmVjaG8gRG93bmxvYWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL1VCLU1hbm5oZWltL3Rlc3NlcmFjdC93aWtpDQplY2hvIERlZmF1bHQgcGF0aDogQzpcUHJvZ3JhbSBGaWxlc1xUZXNzZXJhY3QtT0NSXHRlc3NlcmFjdC5leGUNCmVjaG8uDQpwYXVzZQo=",
  "change_monitor_id.py": "IiIiDQpTY3JpcHQgdG8gZWFzaWx5IGNoYW5nZSB0aGUgbW9uaXRvciBJRCBmb3IgZ2FtZXMgaW4gdGhlIGNvbmZpZy4NCkhlbHBzIHdoZW4gYXV0by1kZXRlY3Rpb24gaXNuJ3Qgd29ya2luZyBvciB5b3Ugd2FudCB0byBtYW51YWxseSBzZXQgaXQuDQoiIiINCg0KaW1wb3J0IG9zDQppbXBvcnQgc3lzDQppbXBvcnQganNvbg0KDQojIEdldCB0aGUgZGlyZWN0b3J5IHdoZXJlIHRoaXMgc2NyaXB0IGlzIGxvY2F0ZWQNCmRlZiBnZXRfYmFzZV9kaXIoKToNCiAgICAiIiJHZXQgdGhlIGJhc2UgZGlyZWN0b3J5IC0gc2FtZSBmb2xkZXIgYXMgdGhpcyBzY3JpcHQuIiIiDQogICAgaWYgZ2V0YXR0cihzeXMsICdmcm96ZW4nLCBGYWxzZSk6DQogICAgICAgIHJldHVybiBvcy5wYXRoLmRpcm5hbWUob3MucGF0aC5hYnNwYXRoKHN5cy5leGVjdXRhYmxlKSkNCiAgICBlbHNlOg0KICAgICAgICByZXR1cm4gb3MucGF0aC5kaXJuYW1lKG9zLnBhdGguYWJzcGF0aChfX2ZpbGVfXykpDQoNCkJBU0VfRElSID0gZ2V0X2Jhc2VfZGlyKCkNCkNPTkZJR19GSUxFID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZ2FtZXNfY29uZmlnLmpzb24iKQ0KDQoNCmRlZiBsb2FkX2NvbmZpZygpOg0KICAgICIiIkxvYWQgZ2FtZSBjb25maWd1cmF0aW9ucyBmcm9tIEpTT04gZmlsZS4iIiINCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoQ09ORklHX0ZJTEUpOg0KICAgICAgICBwcmludChmIkVSUk9SOiBDb25maWcgZmlsZSBub3QgZm91bmQ6IHtDT05GSUdfRklMRX0iKQ0KICAgICAgICByZXR1cm4gTm9uZQ0KICAgIA0KICAgIHRyeToNCiAgICAgICAgd2l0aCBvcGVuKENPTkZJR19GSUxFLCAiciIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBjb25maWcgPSBqc29uLmxvYWQoZikNCiAgICAgICAgcmV0dXJuIGNvbmZpZw0KICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgcHJpbnQoZiJFcnJvciBsb2FkaW5nIGNvbmZpZzoge2V9IikNCiAgICAgICAgcmV0dXJuIE5vbmUNCg0KDQpkZWYgc2F2ZV9jb25maWcoY29uZmlnKToNCiAgICAiIiJTYXZlIGNvbmZpZ3VyYXRpb24gdG8gSlNPTiBmaWxlLiIiIg0KICAgIHRyeToNCiAgICAgICAgd2l0aCBvcGVuKENPTkZJR19GSUxFLCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICBqc29uLmR1bXAoY29uZmlnLCBmLCBpbmRlbnQ9MikNCiAgICAgICAgcmV0dXJuIFRydWUNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIHByaW50KGYiRXJyb3Igc2F2aW5nIGNvbmZpZzoge2V9IikNCiAgICAgICAgcmV0dXJuIEZhbHNlDQoNCg0KZGVmIGxpc3RfbW9uaXRvcnMoKToNCiAgICAiIiJMaXN0IGF2YWlsYWJsZSBtb25pdG9ycy4iIiINCiAgICB0cnk6DQogICAgICAgIGZyb20gbXNzIGltcG9ydCBtc3MNCiAgICAgICAgd2l0aCBtc3MoKSBhcyBzY3Q6DQogICAgICAgICAgICBwcmludCgiXG5BdmFpbGFibGUgbW9uaXRvcnM6IikNCiAgICAgICAgICAgIGZvciBpLCBtb24gaW4gZW51bWVyYXRlKHNjdC5tb25pdG9ycyk6DQogICAgICAgICAgICAgICAgcHJpbnQoZiIgIE1vbml0b3Ige2l9OiB7bW9uWyd3aWR0aCddfXh7bW9uWydoZWlnaHQnXX0gYXQgKHttb25bJ2xlZnQnXX0sIHttb25bJ3RvcCddfSkiKQ0KICAgICAgICAgICAgcmV0dXJuIGxlbihzY3QubW9uaXRvcnMpDQogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICBwcmludChmIkVycm9yIGxpc3RpbmcgbW9uaXRvcnM6IHtlfSIpDQogICAgICAgIHJldHVybiAwDQoNCg0KZGVmIG1haW4oKToNCiAgICBjb25maWcgPSBsb2FkX2NvbmZpZygpDQogICAgaWYgbm90IGNvbmZpZzoNCiAgICAgICAgcmV0dXJuDQogICAgDQogICAgZ2FtZXMgPSBjb25maWcuZ2V0KCJnYW1lcyIsIHt9KQ0KICAgIGlmIG5vdCBnYW1lczoNCiAgICAgICAgcHJpbnQoIk5vIGdhbWVzIGNvbmZpZ3VyZWQhIikNCiAgICAgICAgcmV0dXJuDQogICAgDQogICAgcHJpbnQoIj0iICogNjApDQogICAgcHJpbnQoIk1vbml0b3IgSUQgQ2hhbmdlciIpDQogICAgcHJpbnQoIj0iICogNjApDQogICAgDQogICAgIyBMaXN0IGF2YWlsYWJsZSBtb25pdG9ycw0KICAgIG51bV9tb25pdG9ycyA9IGxpc3RfbW9uaXRvcnMoKQ0KICAgIA0KICAgICMgTGlzdCBnYW1lcw0KICAgIHByaW50KCJcbkNvbmZpZ3VyZWQgZ2FtZXM6IikNCiAgICBnYW1lX2xpc3QgPSBsaXN0KGdhbWVzLmtleXMoKSkNCiAgICBmb3IgaSwgZ2FtZV9uYW1lIGluIGVudW1lcmF0ZShnYW1lX2xpc3QsIDEpOg0KICAgICAgICBjdXJyZW50X21vbml0b3IgPSBnYW1lc1tnYW1lX25hbWVdLmdldCgibW9uaXRvcl9pbmRleCIsIGNvbmZpZy5nZXQoInNldHRpbmdzIiwge30pLmdldCgibW9uaXRvcl9pbmRleCIsIDEpKQ0KICAgICAgICBwcmludChmIiAge2l9LiB7Z2FtZV9uYW1lfSAoTW9uaXRvcjoge2N1cnJlbnRfbW9uaXRvcn0pIikNCiAgICANCiAgICAjIEdldCBnYW1lIHNlbGVjdGlvbg0KICAgIHByaW50KCkNCiAgICB0cnk6DQogICAgICAgIGNob2ljZSA9IGlucHV0KCJFbnRlciBnYW1lIG51bWJlciB0byBjaGFuZ2UgKG9yICdhbGwnIGZvciBhbGwgZ2FtZXMpOiAiKS5zdHJpcCgpLmxvd2VyKCkNCiAgICAgICAgDQogICAgICAgIGlmIGNob2ljZSA9PSAnYWxsJzoNCiAgICAgICAgICAgIHNlbGVjdGVkX2dhbWVzID0gZ2FtZV9saXN0DQogICAgICAgIGVsc2U6DQogICAgICAgICAgICBnYW1lX2lkeCA9IGludChjaG9pY2UpIC0gMQ0KICAgICAgICAgICAgaWYgMCA8PSBnYW1lX2lkeCA8IGxlbihnYW1lX2xpc3QpOg0KICAgICAgICAgICAgICAgIHNlbGVjdGVkX2dhbWVzID0gW2dhbWVfbGlzdFtnYW1lX2lkeF1dDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIHByaW50KCJJbnZhbGlkIHNlbGVjdGlvbiEiKQ0KICAgICAgICAgICAgICAgIHJldHVybg0KICAgIGV4Y2VwdCAoVmFsdWVFcnJvciwgS2V5Ym9hcmRJbnRlcnJ1cHQpOg0KICAgICAgICBwcmludCgiXG5DYW5jZWxsZWQuIikNCiAgICAgICAgcmV0dXJuDQogICAgDQogICAgIyBHZXQgbW9uaXRvciBJRA0KICAgIHByaW50KCkNCiAgICB0cnk6DQogICAgICAgIG1vbml0b3JfaWQgPSBpbnB1dChmIkVudGVyIG1vbml0b3IgSUQgKDAte251bV9tb25pdG9ycy0xfSk6ICIpLnN0cmlwKCkNCiAgICAgICAgbW9uaXRvcl9pZCA9IGludChtb25pdG9yX2lkKQ0KICAgICAgICANCiAgICAgICAgaWYgbW9uaXRvcl9pZCA8IDAgb3IgbW9uaXRvcl9pZCA+PSBudW1fbW9uaXRvcnM6DQogICAgICAgICAgICBwcmludChmIkludmFsaWQgbW9uaXRvciBJRCEgTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIHtudW1fbW9uaXRvcnMtMX0iKQ0KICAgICAgICAgICAgcmV0dXJuDQogICAgZXhjZXB0IChWYWx1ZUVycm9yLCBLZXlib2FyZEludGVycnVwdCk6DQogICAgICAgIHByaW50KCJcbkNhbmNlbGxlZC4iKQ0KICAgICAgICByZXR1cm4NCiAgICANCiAgICAjIFVwZGF0ZSBtb25pdG9yIElEcw0KICAgIHByaW50KCkNCiAgICBmb3IgZ2FtZV9uYW1lIGluIHNlbGVjdGVkX2dhbWVzOg0KICAgICAgICBnYW1lc1tnYW1lX25hbWVdWyJtb25pdG9yX2luZGV4Il0gPSBtb25pdG9yX2lkDQogICAgICAgIHByaW50KGYi4pyTIFNldCB7Z2FtZV9uYW1lfSB0byBtb25pdG9yIHttb25pdG9yX2lkfSIpDQogICAgDQogICAgIyBTYXZlIGNvbmZpZw0KICAgIGlmIHNhdmVfY29uZmlnKGNvbmZpZyk6DQogICAgICAgIHByaW50KGYiXG7inJMgQ29uZmlnIHNhdmVkIHRvIHtDT05GSUdfRklMRX0iKQ0KICAgICAgICBwcmludCgiXG5Ob3RlOiBUaGUgZGFlbW9uIHdpbGwgYXV0by1kZXRlY3QgdGhlIG1vbml0b3IsIGJ1dCB0aGlzIHNldHRpbmciKQ0KICAgICAgICBwcmludCgid2lsbCBiZSB1c2VkIGFzIGEgZmFsbGJhY2sgaWYgYXV0by1kZXRlY3Rpb24gZmFpbHMuIikNCiAgICBlbHNlOg0KICAgICAgICBwcmludCgiXG7inJcgRmFpbGVkIHRvIHNhdmUgY29uZmlnISIpDQoNCg0KaWYgX19uYW1lX18gPT0gIl9fbWFpbl9fIjoNCiAgICBtYWluKCkK",
  "capture_debug_once.py": "IiIiDQpPbmUtdGltZSBkZWJ1ZyBpbWFnZSBjYXB0dXJlIHNjcmlwdC4NCkNhcHR1cmVzIHRoZSBjdXJyZW50IGdhbWUncyByZWdpb24gYW5kIHNhdmVzIGJvdGggcmF3IGFuZCBwcmVwcm9jZXNzZWQgaW1hZ2VzLg0KUnVuIHRoaXMgYW55dGltZSB0byBzZWUgd2hhdCB0aGUgT0NSIGlzIHNlZWluZy4NCiIiIg0KDQppbXBvcnQgb3MNCmltcG9ydCBzeXMNCmltcG9ydCBzdWJwcm9jZXNzDQppbXBvcnQgY3R5cGVzDQppbXBvcnQganNvbg0KZnJvbSB0eXBpbmcgaW1wb3J0IERpY3QsIFR1cGxlDQoNCmltcG9ydCBjdjINCmltcG9ydCBudW1weSBhcyBucA0KZnJvbSBQSUwgaW1wb3J0IEltYWdlDQpmcm9tIG1zcyBpbXBvcnQgbXNzDQppbXBvcnQgcHl0ZXNzZXJhY3QNCg0KIyBHZXQgdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGlzIHNjcmlwdCBpcyBsb2NhdGVkDQpkZWYgZ2V0X2Jhc2VfZGlyKCk6DQogICAgIiIiR2V0IHRoZSBiYXNlIGRpcmVjdG9yeSAtIHNhbWUgZm9sZGVyIGFzIHRoaXMgc2NyaXB0LiIiIg0KICAgIGlmIGdldGF0dHIoc3lzLCAnZnJvemVuJywgRmFsc2UpOg0KICAgICAgICByZXR1cm4gb3MucGF0aC5kaXJuYW1lKG9zLnBhdGguYWJzcGF0aChzeXMuZXhlY3V0YWJsZSkpDQogICAgZWxzZToNCiAgICAgICAgcmV0dXJuIG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgoX19maWxlX18pKQ0KDQpCQVNFX0RJUiA9IGdldF9iYXNlX2RpcigpDQpDT05GSUdfRklMRSA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImdhbWVzX2NvbmZpZy5qc29uIikNCg0KIyBUcnkgdG8gZmluZCBUZXNzZXJhY3QgLSBjaGVjayBjb21tb24gbG9jYXRpb25zIGFuZCBQQVRIDQpkZWYgZmluZF90ZXNzZXJhY3QoKToNCiAgICAiIiJGaW5kIFRlc3NlcmFjdCBPQ1IgZXhlY3V0YWJsZS4iIiINCiAgICAjIENoZWNrIGlmIHRlc3NlcmFjdCBpcyBpbiBQQVRIDQogICAgdHJ5Og0KICAgICAgICByZXN1bHQgPSBzdWJwcm9jZXNzLnJ1bihbJ3Rlc3NlcmFjdCcsICctLXZlcnNpb24nXSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLCB0ZXh0PVRydWUsIHRpbWVvdXQ9MikNCiAgICAgICAgaWYgcmVzdWx0LnJldHVybmNvZGUgPT0gMDoNCiAgICAgICAgICAgIHJldHVybiAndGVzc2VyYWN0JyAgIyBVc2UgY29tbWFuZCBuYW1lIGlmIGluIFBBVEgNCiAgICBleGNlcHQ6DQogICAgICAgIHBhc3MNCiAgICANCiAgICAjIENoZWNrIGNvbW1vbiBpbnN0YWxsYXRpb24gcGF0aHMNCiAgICBjb21tb25fcGF0aHMgPSBbDQogICAgICAgIHIiQzpcUHJvZ3JhbSBGaWxlc1xUZXNzZXJhY3QtT0NSXHRlc3NlcmFjdC5leGUiLA0KICAgICAgICByIkM6XFByb2dyYW0gRmlsZXMgKHg4NilcVGVzc2VyYWN0LU9DUlx0ZXNzZXJhY3QuZXhlIiwNCiAgICAgICAgb3MucGF0aC5qb2luKG9zLmdldGVudignUHJvZ3JhbUZpbGVzJywgcidDOlxQcm9ncmFtIEZpbGVzJyksICdUZXNzZXJhY3QtT0NSJywgJ3Rlc3NlcmFjdC5leGUnKSwNCiAgICAgICAgb3MucGF0aC5qb2luKG9zLmdldGVudignUHJvZ3JhbUZpbGVzKHg4NiknLCByJ0M6XFByb2dyYW0gRmlsZXMgKHg4NiknKSwgJ1Rlc3NlcmFjdC1PQ1InLCAndGVzc2VyYWN0LmV4ZScpLA0KICAgIF0NCiAgICANCiAgICBmb3IgcGF0aCBpbiBjb21tb25fcGF0aHM6DQogICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKHBhdGgpOg0KICAgICAgICAgICAgcmV0dXJuIHBhdGgNCiAgICANCiAgICAjIERlZmF1bHQgZmFsbGJhY2sNCiAgICByZXR1cm4gciJDOlxQcm9ncmFtIEZpbGVzXFRlc3NlcmFjdC1PQ1JcdGVzc2VyYWN0LmV4ZSINCg0KdGVzc2VyYWN0X3BhdGggPSBmaW5kX3Rlc3NlcmFjdCgpDQpweXRlc3NlcmFjdC5weXRlc3NlcmFjdC50ZXNzZXJhY3RfY21kID0gdGVzc2VyYWN0X3BhdGgNCg0KREVCVUdfUkFXID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZGVidWdfY2FwdHVyZV9yYXcucG5nIikNCkRFQlVHX09DUiA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgImRlYnVnX2NhcHR1cmUucG5nIikNCg0KDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCiMgRFBJIEFXQVJFTkVTUw0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQpkZWYgZW5hYmxlX2RwaV9hd2FyZW5lc3MoKToNCiAgICB0cnk6DQogICAgICAgIGN0eXBlcy53aW5kbGwuc2hjb3JlLlNldFByb2Nlc3NEcGlBd2FyZW5lc3MoMikNCiAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICB0cnk6DQogICAgICAgICAgICBjdHlwZXMud2luZGxsLnVzZXIzMi5TZXRQcm9jZXNzRFBJQXdhcmUoKQ0KICAgICAgICBleGNlcHQgRXhjZXB0aW9uOg0KICAgICAgICAgICAgcGFzcw0KDQoNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KIyBDT05GSUdVUkFUSU9OIE1BTkFHRU1FTlQNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KZGVmIGxvYWRfY29uZmlnKCkgLT4gRGljdDoNCiAgICAiIiJMb2FkIGdhbWUgY29uZmlndXJhdGlvbnMgZnJvbSBKU09OIGZpbGUuIiIiDQogICAgaWYgbm90IG9zLnBhdGguZXhpc3RzKENPTkZJR19GSUxFKToNCiAgICAgICAgcHJpbnQoZiJFUlJPUjogQ29uZmlnIGZpbGUgbm90IGZvdW5kOiB7Q09ORklHX0ZJTEV9IikNCiAgICAgICAgcmV0dXJuIE5vbmUNCiAgICANCiAgICB0cnk6DQogICAgICAgIHdpdGggb3BlbihDT05GSUdfRklMRSwgInIiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOg0KICAgICAgICAgICAgY29uZmlnID0ganNvbi5sb2FkKGYpDQogICAgICAgIHJldHVybiBjb25maWcNCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIHByaW50KGYiRXJyb3IgbG9hZGluZyBjb25maWc6IHtlfSIpDQogICAgICAgIHJldHVybiBOb25lDQoNCg0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQojIElNQUdFIFBST0NFU1NJTkcNCiMgPT09PT09PT09PT09PT09PT09PT09PT09PQ0KZGVmIGdyYWJfcmVnaW9uKHNjdDogbXNzLCBtb25pdG9yX2luZGV4OiBpbnQsIHJlZ2lvbjogZGljdCkgLT4gSW1hZ2UuSW1hZ2U6DQogICAgIiIiQ2FwdHVyZSBhIHJlZ2lvbiBmcm9tIHRoZSBzcGVjaWZpZWQgbW9uaXRvci4iIiINCiAgICBhY3R1YWxfaW5kZXggPSBtb25pdG9yX2luZGV4IGlmIG1vbml0b3JfaW5kZXggPT0gMCBlbHNlIG1vbml0b3JfaW5kZXgNCiAgICANCiAgICBpZiBhY3R1YWxfaW5kZXggPj0gbGVuKHNjdC5tb25pdG9ycyk6DQogICAgICAgIHByaW50KGYiV0FSTklORzogTW9uaXRvciB7bW9uaXRvcl9pbmRleH0gbm90IGZvdW5kLiBVc2luZyBtb25pdG9yIDEuIikNCiAgICAgICAgYWN0dWFsX2luZGV4ID0gMQ0KICAgIA0KICAgIG1vbiA9IHNjdC5tb25pdG9yc1thY3R1YWxfaW5kZXhdDQogICAgYWJzX3JlZ2lvbiA9IHsNCiAgICAgICAgImxlZnQiOiBtb25bImxlZnQiXSArIHJlZ2lvblsibGVmdCJdLA0KICAgICAgICAidG9wIjogbW9uWyJ0b3AiXSArIHJlZ2lvblsidG9wIl0sDQogICAgICAgICJ3aWR0aCI6IHJlZ2lvblsid2lkdGgiXSwNCiAgICAgICAgImhlaWdodCI6IHJlZ2lvblsiaGVpZ2h0Il0sDQogICAgfQ0KICAgIGdyYWIgPSBzY3QuZ3JhYihhYnNfcmVnaW9uKQ0KICAgIHJldHVybiBJbWFnZS5mcm9tYnl0ZXMoIlJHQiIsIGdyYWIuc2l6ZSwgZ3JhYi5yZ2IpDQoNCg0KZGVmIHByZXByb2Nlc3NfZm9yX29jcihpbWdfcmdiOiBJbWFnZS5JbWFnZSkgLT4gVHVwbGVbSW1hZ2UuSW1hZ2UsIERpY3RdOg0KICAgICIiIg0KICAgIFByZXByb2Nlc3MgaW1hZ2UgZm9yIE9DUiB3aXRoIG11bHRpcGxlIGZhbGxiYWNrIHN0cmF0ZWdpZXMuDQogICAgU2FtZSBhcyB0aGUgbWFpbiBkYWVtb24gc2NyaXB0Lg0KICAgICIiIg0KICAgIHJnYiA9IG5wLmFycmF5KGltZ19yZ2IpDQogICAgYmdyID0gY3YyLmN2dENvbG9yKHJnYiwgY3YyLkNPTE9SX1JHQjJCR1IpDQogICAgDQogICAgZGVmIHVwc2NhbGUoaW1nX2N2KToNCiAgICAgICAgIiIiVXBzY2FsZSBpbWFnZSAyeCBmb3IgYmV0dGVyIE9DUi4iIiINCiAgICAgICAgcmV0dXJuIGN2Mi5yZXNpemUoaW1nX2N2LCBOb25lLCBmeD0yLjAsIGZ5PTIuMCwgaW50ZXJwb2xhdGlvbj1jdjIuSU5URVJfQ1VCSUMpDQogICAgDQogICAgIyBTdHJhdGVneSAxOiBUcnkgSFNWIHJlZCBtYXNrIChmb3IgIllPVSBESUVEIiByZWQgdGV4dCkNCiAgICBoc3YgPSBjdjIuY3Z0Q29sb3IoYmdyLCBjdjIuQ09MT1JfQkdSMkhTVikNCiAgICANCiAgICAjIFdpZGUgcmVkIHRocmVzaG9sZHMgKGJvdGggbG93IGFuZCBoaWdoIGh1ZSByYW5nZXMpDQogICAgbG93ZXIxID0gbnAuYXJyYXkoWzAsIDMwLCAzMF0sIGR0eXBlPW5wLnVpbnQ4KQ0KICAgIHVwcGVyMSA9IG5wLmFycmF5KFsxNSwgMjU1LCAyNTVdLCBkdHlwZT1ucC51aW50OCkNCiAgICBsb3dlcjIgPSBucC5hcnJheShbMTY1LCAzMCwgMzBdLCBkdHlwZT1ucC51aW50OCkNCiAgICB1cHBlcjIgPSBucC5hcnJheShbMTgwLCAyNTUsIDI1NV0sIGR0eXBlPW5wLnVpbnQ4KQ0KICAgIA0KICAgIG1hc2sxID0gY3YyLmluUmFuZ2UoaHN2LCBsb3dlcjEsIHVwcGVyMSkNCiAgICBtYXNrMiA9IGN2Mi5pblJhbmdlKGhzdiwgbG93ZXIyLCB1cHBlcjIpDQogICAgbWFzayA9IGN2Mi5iaXR3aXNlX29yKG1hc2sxLCBtYXNrMikNCiAgICANCiAgICAjIENsZWFuIG5vaXNlDQogICAga2VybmVsID0gbnAub25lcygoMywgMyksIG5wLnVpbnQ4KQ0KICAgIG1hc2sgPSBjdjIubW9ycGhvbG9neUV4KG1hc2ssIGN2Mi5NT1JQSF9PUEVOLCBrZXJuZWwsIGl0ZXJhdGlvbnM9MSkNCiAgICBtYXNrID0gY3YyLm1vcnBob2xvZ3lFeChtYXNrLCBjdjIuTU9SUEhfQ0xPU0UsIGtlcm5lbCwgaXRlcmF0aW9ucz0yKQ0KICAgIG1hc2sgPSBjdjIuZGlsYXRlKG1hc2ssIGtlcm5lbCwgaXRlcmF0aW9ucz0xKQ0KICAgIA0KICAgIHdoaXRlID0gaW50KGN2Mi5jb3VudE5vblplcm8obWFzaykpDQogICAgdG90YWwgPSBpbnQobWFzay5zaGFwZVswXSAqIG1hc2suc2hhcGVbMV0pDQogICAgY292ZXJhZ2UgPSB3aGl0ZSAvIG1heCgxLCB0b3RhbCkNCiAgICANCiAgICBpbmZvID0geyJtb2RlIjogIkhTVl9SRUQiLCAiY292ZXJhZ2UiOiBjb3ZlcmFnZX0NCiAgICANCiAgICAjIFVzZSByZWQgbWFzayBpZiBjb3ZlcmFnZSBpcyByZWFzb25hYmxlIChhdCBsZWFzdCAwLjUlIG9mIGltYWdlKQ0KICAgIGlmIGNvdmVyYWdlID49IDAuMDA1Og0KICAgICAgICAjIEludmVydCBtYXNrOiB3aGl0ZSB0ZXh0IG9uIGJsYWNrIGJhY2tncm91bmQgLT4gYmxhY2sgdGV4dCBvbiB3aGl0ZQ0KICAgICAgICBpbnYgPSBjdjIuYml0d2lzZV9ub3QobWFzaykNCiAgICAgICAgb3V0ID0gdXBzY2FsZShpbnYpDQogICAgICAgIHJldHVybiBJbWFnZS5mcm9tYXJyYXkob3V0KSwgaW5mbw0KICAgIA0KICAgICMgU3RyYXRlZ3kgMjogR3JheXNjYWxlIHdpdGggYWRhcHRpdmUgdGhyZXNob2xkICh3b3JrcyBmb3IgYW55IHRleHQgY29sb3IpDQogICAgZ3JheSA9IGN2Mi5jdnRDb2xvcihiZ3IsIGN2Mi5DT0xPUl9CR1IyR1JBWSkNCiAgICBncmF5X2JsdXIgPSBjdjIuR2F1c3NpYW5CbHVyKGdyYXksICgzLCAzKSwgMCkNCiAgICB0aHJfYWRhcHQgPSBjdjIuYWRhcHRpdmVUaHJlc2hvbGQoDQogICAgICAgIGdyYXlfYmx1ciwgMjU1LA0KICAgICAgICBjdjIuQURBUFRJVkVfVEhSRVNIX0dBVVNTSUFOX0MsDQogICAgICAgIGN2Mi5USFJFU0hfQklOQVJZLA0KICAgICAgICAzMSwgNQ0KICAgICkNCiAgICAjIEludmVydDogbWFrZSB0ZXh0IGRhcmsgb24gbGlnaHQgYmFja2dyb3VuZCAoVGVzc2VyYWN0IHByZWZlcnMgZGFyayB0ZXh0IG9uIGxpZ2h0KQ0KICAgIHRocl9hZGFwdF9pbnYgPSBjdjIuYml0d2lzZV9ub3QodGhyX2FkYXB0KQ0KICAgIG91dCA9IHVwc2NhbGUodGhyX2FkYXB0X2ludikNCiAgICBpbmZvWyJtb2RlIl0gPSAiQURBUFRJVkVfVEhSRVNIT0xEIg0KICAgIGluZm9bImNvdmVyYWdlIl0gPSAwLjANCiAgICByZXR1cm4gSW1hZ2UuZnJvbWFycmF5KG91dCksIGluZm8NCg0KDQojID09PT09PT09PT09PT09PT09PT09PT09PT0NCiMgTUFJTg0KIyA9PT09PT09PT09PT09PT09PT09PT09PT09DQpkZWYgbWFpbigpOg0KICAgIGVuYWJsZV9kcGlfYXdhcmVuZXNzKCkNCiAgICANCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMocHl0ZXNzZXJhY3QucHl0ZXNzZXJhY3QudGVzc2VyYWN0X2NtZCk6DQogICAgICAgIHByaW50KGYiV0FSTklORzogVGVzc2VyYWN0IG5vdCBmb3VuZCBhdDoge3B5dGVzc2VyYWN0LnB5dGVzc2VyYWN0LnRlc3NlcmFjdF9jbWR9IikNCiAgICAgICAgcHJpbnQoIk9DUiB3b24ndCB3b3JrLCBidXQgaW1hZ2VzIHdpbGwgc3RpbGwgYmUgY2FwdHVyZWQuIikNCiAgICANCiAgICBjb25maWcgPSBsb2FkX2NvbmZpZygpDQogICAgaWYgbm90IGNvbmZpZzoNCiAgICAgICAgcmV0dXJuDQogICAgDQogICAgZ2FtZXMgPSBjb25maWcuZ2V0KCJnYW1lcyIsIHt9KQ0KICAgIGN1cnJlbnRfZ2FtZSA9IGNvbmZpZy5nZXQoImN1cnJlbnRfZ2FtZSIpDQogICAgDQogICAgaWYgbm90IGN1cnJlbnRfZ2FtZSBvciBjdXJyZW50X2dhbWUgbm90IGluIGdhbWVzOg0KICAgICAgICBwcmludChmIkVSUk9SOiBDdXJyZW50IGdhbWUgJ3tjdXJyZW50X2dhbWV9JyBub3QgZm91bmQgaW4gY29uZmlnLiIpDQogICAgICAgIHByaW50KGYiQXZhaWxhYmxlIGdhbWVzOiB7bGlzdChnYW1lcy5rZXlzKCkpfSIpDQogICAgICAgIHJldHVybg0KICAgIA0KICAgIGdhbWVfY29uZmlnID0gZ2FtZXNbY3VycmVudF9nYW1lXQ0KICAgIHJlZ2lvbiA9IGdhbWVfY29uZmlnLmdldCgicmVnaW9uIiwge30pDQogICAgbW9uaXRvcl9pbmRleCA9IGdhbWVfY29uZmlnLmdldCgibW9uaXRvcl9pbmRleCIsIGNvbmZpZy5nZXQoInNldHRpbmdzIiwge30pLmdldCgibW9uaXRvcl9pbmRleCIsIDEpKQ0KICAgIA0KICAgIHByaW50KCI9IiAqIDYwKQ0KICAgIHByaW50KCJEZWJ1ZyBJbWFnZSBDYXB0dXJlIikNCiAgICBwcmludCgiPSIgKiA2MCkNCiAgICBwcmludChmIkdhbWU6IHtjdXJyZW50X2dhbWV9IikNCiAgICBwcmludChmIk1vbml0b3I6IHttb25pdG9yX2luZGV4fSIpDQogICAgcHJpbnQoZiJSZWdpb246IHtyZWdpb259IikNCiAgICBwcmludCgpDQogICAgDQogICAgd2l0aCBtc3MoKSBhcyBzY3Q6DQogICAgICAgIHByaW50KGYiQXZhaWxhYmxlIG1vbml0b3JzOiB7bGVuKHNjdC5tb25pdG9ycyl9IikNCiAgICAgICAgZm9yIGksIG1vbiBpbiBlbnVtZXJhdGUoc2N0Lm1vbml0b3JzKToNCiAgICAgICAgICAgIHByaW50KGYiICBNb25pdG9yIHtpfToge21vblsnd2lkdGgnXX14e21vblsnaGVpZ2h0J119IGF0ICh7bW9uWydsZWZ0J119LCB7bW9uWyd0b3AnXX0pIikNCiAgICAgICAgcHJpbnQoKQ0KICAgICAgICANCiAgICAgICAgIyBDYXB0dXJlIHJlZ2lvbg0KICAgICAgICBwcmludCgiQ2FwdHVyaW5nIHJlZ2lvbi4uLiIpDQogICAgICAgIGltZ19yZ2IgPSBncmFiX3JlZ2lvbihzY3QsIG1vbml0b3JfaW5kZXgsIHJlZ2lvbikNCiAgICAgICAgDQogICAgICAgICMgU2F2ZSByYXcgaW1hZ2UNCiAgICAgICAgaW1nX3JnYi5zYXZlKERFQlVHX1JBVykNCiAgICAgICAgcHJpbnQoZiLinJMgUmF3IGltYWdlIHNhdmVkOiB7REVCVUdfUkFXfSIpDQogICAgICAgIHByaW50KGYiICBTaXplOiB7aW1nX3JnYi5zaXplWzBdfXh7aW1nX3JnYi5zaXplWzFdfSIpDQogICAgICAgIA0KICAgICAgICAjIFByZXByb2Nlc3MNCiAgICAgICAgcHJpbnQoIlByZXByb2Nlc3NpbmcgZm9yIE9DUi4uLiIpDQogICAgICAgIG9jcl9pbWcsIGluZm8gPSBwcmVwcm9jZXNzX2Zvcl9vY3IoaW1nX3JnYikNCiAgICAgICAgDQogICAgICAgICMgU2F2ZSBwcm9jZXNzZWQgaW1hZ2UNCiAgICAgICAgb2NyX2ltZy5zYXZlKERFQlVHX09DUikNCiAgICAgICAgcHJpbnQoZiLinJMgUHJvY2Vzc2VkIGltYWdlIHNhdmVkOiB7REVCVUdfT0NSfSIpDQogICAgICAgIHByaW50KGYiICBTaXplOiB7b2NyX2ltZy5zaXplWzBdfXh7b2NyX2ltZy5zaXplWzFdfSIpDQogICAgICAgIHByaW50KGYiICBNb2RlOiB7aW5mb1snbW9kZSddfSIpDQogICAgICAgIGlmICdjb3ZlcmFnZScgaW4gaW5mbzoNCiAgICAgICAgICAgIHByaW50KGYiICBDb3ZlcmFnZToge2luZm9bJ2NvdmVyYWdlJ106LjRmfSIpDQogICAgICAgIA0KICAgICAgICBwcmludCgpDQogICAgICAgIHByaW50KCJEb25lISBPcGVuIHRoZSBpbWFnZXMgdG8gc2VlIHdoYXQgT0NSIGlzIHByb2Nlc3NpbmcuIikNCg0KDQppZiBfX25hbWVfXyA9PSAiX19tYWluX18iOg0KICAgIG1haW4oKQo=",
  "CHANGE_MONITOR_ID.bat": "QGVjaG8gb2ZmDQpSRU0gU2NyaXB0IHRvIGVhc2lseSBjaGFuZ2UgbW9uaXRvciBJRCBmb3IgZ2FtZXMNCmNkIC9kICIlfmRwMCINCnB5dGhvbiBjaGFuZ2VfbW9uaXRvcl9pZC5weQ0KaWYgZXJyb3JsZXZlbCAxICgNCiAgICBlY2hvLg0KICAgIGVjaG8gUHJlc3MgYW55IGtleSB0byBleGl0Li4uDQogICAgcGF1c2UgPm51bA0KKQo=",
  "CAPTURE_DEBUG.bat": "QGVjaG8gb2ZmDQpSRU0gU2NyaXB0IHRvIGNhcHR1cmUgZGVidWcgaW1hZ2VzDQpjZCAvZCAiJX5kcDAiDQpweXRob24gY2FwdHVyZV9kZWJ1Z19vbmNlLnB5DQppZiBlcnJvcmxldmVsIDEgKA0KICAgIGVjaG8uDQogICAgZWNobyBQcmVzcyBhbnkga2V5IHRvIGV4aXQuLi4NCiAgICBwYXVzZSA+bnVsDQopCg==",
  "deathcounteraction.cs": "VTBKQlJSK0xDQUFBQUFBQUJBQ1ZXRmx6MmtnUWZ0K3EvUStzbnlPWERvUlJxdllCWkZzSWJCTEFYRnJ5TUJmU2hOR3hPb3h4S3Y5OVp5VEFDTWJlSkZXS2E2WjcrdnEra2JyNThlY2ZqY1pWU0hKdzlibnhReXo0TWdJaDRjdXJXd0x5b0dISFJaU1R0UEVYRnN1TXI4TVFSUGpxMDE0YkZIa1FwMEwvTVk0MlpQY0VJditMY3hRL2t6U2pjU1RrMnJWNnJSNEZtR1FvcFVtK0Z4N00wNmlSYjJtT2dnWUtRTjVZeDJtalNERElTWGJkS0RLU05UcEZIamZxb2ZHTlN1ZjZOS3A0WEVRZHRMY2ZGWXdkWkNHTmFGaUVzMk5rUWloa1AwdU5LMjdwdEJ5Z3RKSHhuWCtxbmNaQlZJb3BGdUZqb0xkeEcyTEYxQUZTbW9hS0ZVZ1FWQ3hrcmVFTndFYkxPcGFzUFBadlFZcXl5cnFtRVYwMWlhSmlxNlUwc1dZcWx0YTZVVEJzYVcyZHRGcXFpbW9uU1FRZ0k4SnJuaGFrSm5sQnJNRGtQbzNESHMzeU9OMXhwVFZnMlh0YVgwbUVhZVRMdEE0a2VLckFzQVVZZHBHbUpNb2JmNVhsejJwUitXbGNKR2NIYWdxQWJjRXU0NWpJdktXY1VYRjRST3RDanVJSVZjNWwwanlsdnMvUlBJWG9ES2E5bFpLNmJvbVlpamhraG1VcTY3YlZWSnJXMmxEYWJRMG9TTWN0anFhdVFsTS9UZUFFYkJPMmtXNjBPTVRHRFZhYWFxdXRXT1RHVUpxbXFwdm16ZHJTNFByaWFMNUxSRUdicW5ZdWVSZlFON2l5QXdPL25VcC92aTIrbmRZaksyRG5rclN5aXV4UlBya2RSMUg5ZnNvMFVySW1IQkpFTHR5VVl2dnphalduSE5kdHRsbzlVcFRHV2J6T3I0ZDNUNnZWZmNvZGIrTjAwMnF1VnM5Ti9tSXdWRU96VnFzd1EzSEtLTHpHakYzVlRYNDc5dzkzT2JGalhOSVVMNFlKREpFL05kZ3JkbWI1bDYwNk9OOTcyTEN2WXY5MmxHenh2SitCK2FPLzFGOENaRHo2STYzclR1WW0zek1abDkvY2ptTGZ0VHMrNnMwb2ROaDMxK2svUTMzcmp4Y0JXeG96MVp2NHlVR0hjSnZpYi9WMFZSUnRoalk5ck0vbDFZT004WTc3aXJqZEFPbXpPN0J3L2ErVGJzZmRQTFlXenBndEYrTjRxWE1pUldPR3FIdU01OFRQSys3MXkvdzgvVDczcGw0Q25hbXdNUkpuSHpiRFp6Z1g4bW04RE85ZnZlazRRWFRydStGUVExR2ZjYnZyOHR6RVZFbHZSQWRQV1MzbTh1a05WUlN5d3R0MU45NzhYZ1c5b1FQbUw4eTlWZjJwdzllMmVRdDFqWXFhRGQ3eXlGeTcveDB2K2p0dmJxb0x2Y29GN1Q3dzA3bXN6OE91N1UvRFdlRFozV2c1MTVqcm1BR2NUeitLOGVoelhPYlZzWGdjTXhqbUJUUnc0WDZYK0hWWTZOcEJtZFBEWnRZRUMyNXJGNVQreGlITHZNa21rZFJkZ2tYMWNGN3NVRGdyOEIwV3NRb3NLdHVzejViemNSYzZMMU52RWFnRFI4aG5wV3d3TWFjOC9ueGdiMlFZV3hKZmwzblk3V2YzWHZnWStaNHpDN0RqK3hWM1JyOVdyL0pNOENwd2RiOTM2QmNKWDhGODZRL3VTbzRWL0E0a25MK3ZnejFQa1ZydUo0UFI1VGtaOTZ2YUgzbDRWM0hyOFlONjFmMDhNSEYzMUZqT1dmV1grVFdLWnR6ZXlPZFl2Q0w5UHZJazhiL2RVNDBoWXhoNHVzQzFzM0UzaC9oSC9yRitkbkJUNThETUdnZ2U5dktMV3E4bnNqdjlIclpEQnNPVE9DZGRGZTY2VTZ3emRha0xySU1BUzNJVTc3UUhKczZPaDk1aStMcWNZMzVQajNra01wd2xITHlkM3ZuRmsyTkYvUDBZd3AyL2NZWE42Q1NlcDlnbitzSHV6SEtwak11UzNIcDlobnV6SGFUaW5UbGo5WGpPdU84TWVkMkdNYS94UFhHR0RQWEdDZFNidnJmdzYzZTBKK0hFM1hBMHNjMUhxT1BGY3RFdkJ2YUlqamtlMEhCYkhCdEdiUE5ZSDQ2THRDNGNVNVZqV0xpT0Y4RGU4TjFZMTV4RDY5SGZmMTk4L3BPVThQWWpvWXhJT3BqOUI1ZUIzU1FIcWF6SHFiN3I0Sm1NU1Zhdy9DbWVnWlNLdHVFajNacVc3QXRldFRPb1JUUkxOWnBLVzhXQWQwTHRsZ0xXcmJWaUdoaW9hOHovZzgyTGZMYUUrb0dJbFBmMDc3UTZsdmgzVVFjZ3VyaXlCWk5GOUhFdnhMc0o4aUo4L2tvWGhHTEdRSklSN0lqV3RONDk3YzhjOUt0dS9IOWEvTjl1MUNHTDBlYlgyK3VyOTRMYnQ2M3ZocGVRTktSNVR2QTAyemZCdFRvY3hTZDErSFNSM2UrMnc4Y01Ea09CWkNaNEEvTWlmeHFWUTRoa2lBbXJqazZ0UTFuTm5HOXpZczFQU256eWN2ZVNNSXBvYm9Na0wxTFp2YmppZUlCOVA2dlZndkdqT0NYZE9POGdKRVpLYWNDbGppdm16UWd3U2R4WlhLUlZLNnlkVlQvanM5aCtWSlZaM21zSThEN1FRaUFqRXhKbE5LZlAwdVI4RmtQQTdEaG12T09Peml0WWxOYmxzdVBvZGpiUWdTaC9xbTZ5K2g0MXR3Um1uT1FrbjVEMCtZeDhiMEtiVWM2UXVqQ240VUgvWlBSKys3VkFONm9kOHBMRUtTZXZHRmNQUHlKb1ZhQ1hnM3oxRTRNQ1dCSUFydlhuSHovL0ExV240T3JoRUFBQQo=",
  "test_daemon_start.py": "IiIiDQpUZXN0IHNjcmlwdCB0byB2ZXJpZnkgZGFlbW9uIGNhbiBzdGFydCBwcm9wZXJseS4NClJ1biB0aGlzIGRpcmVjdGx5IHRvIHNlZSB3aGF0IGVycm9ycyBvY2N1ci4NCiIiIg0KaW1wb3J0IG9zDQppbXBvcnQgc3lzDQppbXBvcnQgc3VicHJvY2Vzcw0KaW1wb3J0IHRpbWUNCg0KIyBHZXQgdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGlzIHNjcmlwdCBpcyBsb2NhdGVkDQpCQVNFX0RJUiA9IG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgoX19maWxlX18pKQ0KREFFTU9OX1NDUklQVCA9IG9zLnBhdGguam9pbihCQVNFX0RJUiwgIm11bHRpX2dhbWVfZGVhdGhfY291bnRlci5weSIpDQpMT0NLX0ZJTEUgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkYWVtb24ubG9jayIpDQpSRUFEWV9GSUxFID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZGFlbW9uLnJlYWR5IikNCg0KZGVmIGZpbmRfcHl0aG9uKCk6DQogICAgIiIiRmluZCBQeXRob24gZXhlY3V0YWJsZS4iIiINCiAgICAjIFRyeSBzeXMuZXhlY3V0YWJsZSBmaXJzdA0KICAgIGlmIHN5cy5leGVjdXRhYmxlIGFuZCBzeXMuZXhlY3V0YWJsZS5lbmRzd2l0aCgncHl0aG9uLmV4ZScpOg0KICAgICAgICByZXR1cm4gc3lzLmV4ZWN1dGFibGUNCiAgICANCiAgICAjIFRyeSBjb21tb24gbG9jYXRpb25zDQogICAgaW1wb3J0IHdpbnJlZw0KICAgIHRyeToNCiAgICAgICAga2V5ID0gd2lucmVnLk9wZW5LZXkod2lucmVnLkhLRVlfTE9DQUxfTUFDSElORSwgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgciJTT0ZUV0FSRVxQeXRob25cUHl0aG9uQ29yZSIsIDAsDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lucmVnLktFWV9SRUFEIHwgd2lucmVnLktFWV9XT1c2NF82NEtFWSkNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgdmVyc2lvbiA9IHdpbnJlZy5FbnVtS2V5KGtleSwgMCkNCiAgICAgICAgICAgIGluc3RhbGxfcGF0aF9rZXkgPSB3aW5yZWcuT3BlbktleShrZXksIGYie3ZlcnNpb259XFxJbnN0YWxsUGF0aCIpDQogICAgICAgICAgICBpbnN0YWxsX3BhdGggPSB3aW5yZWcuUXVlcnlWYWx1ZUV4KGluc3RhbGxfcGF0aF9rZXksICIiKVswXQ0KICAgICAgICAgICAgcHl0aG9uX2V4ZSA9IG9zLnBhdGguam9pbihpbnN0YWxsX3BhdGgsICJweXRob24uZXhlIikNCiAgICAgICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKHB5dGhvbl9leGUpOg0KICAgICAgICAgICAgICAgIHJldHVybiBweXRob25fZXhlDQogICAgICAgIGV4Y2VwdDoNCiAgICAgICAgICAgIHBhc3MNCiAgICBleGNlcHQ6DQogICAgICAgIHBhc3MNCiAgICANCiAgICAjIFRyeSBQQVRIDQogICAgdHJ5Og0KICAgICAgICByZXN1bHQgPSBzdWJwcm9jZXNzLnJ1bihbJ3doZXJlJywgJ3B5dGhvbiddLCBjYXB0dXJlX291dHB1dD1UcnVlLCB0ZXh0PVRydWUsIHRpbWVvdXQ9MikNCiAgICAgICAgaWYgcmVzdWx0LnJldHVybmNvZGUgPT0gMCBhbmQgcmVzdWx0LnN0ZG91dC5zdHJpcCgpOg0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdGRvdXQuc3RyaXAoKS5zcGxpdCgnXG4nKVswXQ0KICAgIGV4Y2VwdDoNCiAgICAgICAgcGFzcw0KICAgIA0KICAgIHJldHVybiBOb25lDQoNCmRlZiBtYWluKCk6DQogICAgcHJpbnQoIj0iICogNzApDQogICAgcHJpbnQoIkRBRU1PTiBTVEFSVFVQIFRFU1QiKQ0KICAgIHByaW50KCI9IiAqIDcwKQ0KICAgIHByaW50KGYiQmFzZSBkaXJlY3Rvcnk6IHtCQVNFX0RJUn0iKQ0KICAgIHByaW50KGYiRGFlbW9uIHNjcmlwdDoge0RBRU1PTl9TQ1JJUFR9IikNCiAgICBwcmludChmIlNjcmlwdCBleGlzdHM6IHtvcy5wYXRoLmV4aXN0cyhEQUVNT05fU0NSSVBUKX0iKQ0KICAgIHByaW50KCkNCiAgICANCiAgICAjIENsZWFuIHVwIG9sZCBmaWxlcw0KICAgIGlmIG9zLnBhdGguZXhpc3RzKExPQ0tfRklMRSk6DQogICAgICAgIHByaW50KGYiUmVtb3Zpbmcgb2xkIGxvY2sgZmlsZToge0xPQ0tfRklMRX0iKQ0KICAgICAgICBvcy5yZW1vdmUoTE9DS19GSUxFKQ0KICAgIGlmIG9zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpOg0KICAgICAgICBwcmludChmIlJlbW92aW5nIG9sZCByZWFkeSBmaWxlOiB7UkVBRFlfRklMRX0iKQ0KICAgICAgICBvcy5yZW1vdmUoUkVBRFlfRklMRSkNCiAgICBwcmludCgpDQogICAgDQogICAgIyBGaW5kIFB5dGhvbg0KICAgIHB5dGhvbl9leGUgPSBmaW5kX3B5dGhvbigpDQogICAgaWYgbm90IHB5dGhvbl9leGU6DQogICAgICAgIHByaW50KCJFUlJPUjogQ291bGQgbm90IGZpbmQgUHl0aG9uIGV4ZWN1dGFibGUhIikNCiAgICAgICAgcmV0dXJuDQogICAgcHJpbnQoZiJQeXRob24gZXhlY3V0YWJsZToge3B5dGhvbl9leGV9IikNCiAgICBwcmludChmIlB5dGhvbiBleGlzdHM6IHtvcy5wYXRoLmV4aXN0cyhweXRob25fZXhlKX0iKQ0KICAgIHByaW50KCkNCiAgICANCiAgICAjIENoZWNrIGlmIHNjcmlwdCBleGlzdHMNCiAgICBpZiBub3Qgb3MucGF0aC5leGlzdHMoREFFTU9OX1NDUklQVCk6DQogICAgICAgIHByaW50KGYiRVJST1I6IERhZW1vbiBzY3JpcHQgbm90IGZvdW5kOiB7REFFTU9OX1NDUklQVH0iKQ0KICAgICAgICByZXR1cm4NCiAgICANCiAgICAjIFRlc3QgUHl0aG9uIGNhbiBpbXBvcnQgcmVxdWlyZWQgbW9kdWxlcw0KICAgIHByaW50KCJUZXN0aW5nIFB5dGhvbiBpbXBvcnRzLi4uIikNCiAgICB0ZXN0X2ltcG9ydHMgPSBbDQogICAgICAgICJpbXBvcnQgc3lzIiwNCiAgICAgICAgImltcG9ydCBvcyIsDQogICAgICAgICJpbXBvcnQganNvbiIsDQogICAgICAgICJpbXBvcnQgdGltZSIsDQogICAgICAgICJpbXBvcnQgc3VicHJvY2VzcyIsDQogICAgICAgICJpbXBvcnQgcHN1dGlsIiwNCiAgICAgICAgImltcG9ydCBjdjIiLA0KICAgICAgICAiaW1wb3J0IG51bXB5IiwNCiAgICAgICAgImZyb20gUElMIGltcG9ydCBJbWFnZSIsDQogICAgICAgICJmcm9tIG1zcyBpbXBvcnQgbXNzIiwNCiAgICAgICAgImltcG9ydCBweXRlc3NlcmFjdCINCiAgICBdDQogICAgDQogICAgZm9yIGltcG9ydF9zdG10IGluIHRlc3RfaW1wb3J0czoNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgcmVzdWx0ID0gc3VicHJvY2Vzcy5ydW4oDQogICAgICAgICAgICAgICAgW3B5dGhvbl9leGUsICItYyIsIGltcG9ydF9zdG10XSwNCiAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlLA0KICAgICAgICAgICAgICAgIHRleHQ9VHJ1ZSwNCiAgICAgICAgICAgICAgICB0aW1lb3V0PTUNCiAgICAgICAgICAgICkNCiAgICAgICAgICAgIGlmIHJlc3VsdC5yZXR1cm5jb2RlID09IDA6DQogICAgICAgICAgICAgICAgcHJpbnQoZiIgIOKckyB7aW1wb3J0X3N0bXR9IikNCiAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgcHJpbnQoZiIgIOKclyB7aW1wb3J0X3N0bXR9IC0gRXJyb3I6IHtyZXN1bHQuc3RkZXJyWzoxMDBdfSIpDQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgIHByaW50KGYiICDinJcge2ltcG9ydF9zdG10fSAtIEV4Y2VwdGlvbjoge2V9IikNCiAgICBwcmludCgpDQogICAgDQogICAgIyBUcnkgdG8gcnVuIGRhZW1vbiBzY3JpcHQgZGlyZWN0bHkgKHdpbGwgc2hvdyBlcnJvcnMpDQogICAgcHJpbnQoIkF0dGVtcHRpbmcgdG8gc3RhcnQgZGFlbW9uICh3aWxsIHNob3cgYW55IGVycm9ycykuLi4iKQ0KICAgIHByaW50KCI9IiAqIDcwKQ0KICAgIHRyeToNCiAgICAgICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MuUG9wZW4oDQogICAgICAgICAgICBbcHl0aG9uX2V4ZSwgREFFTU9OX1NDUklQVF0sDQogICAgICAgICAgICBjd2Q9QkFTRV9ESVIsDQogICAgICAgICAgICBzdGRvdXQ9c3VicHJvY2Vzcy5QSVBFLA0KICAgICAgICAgICAgc3RkZXJyPXN1YnByb2Nlc3MuU1RET1VULA0KICAgICAgICAgICAgdGV4dD1UcnVlLA0KICAgICAgICAgICAgYnVmc2l6ZT0xDQogICAgICAgICkNCiAgICAgICAgDQogICAgICAgICMgV2FpdCBhIGJpdCBhbmQgY2hlY2sgc3RhdHVzDQogICAgICAgIHRpbWUuc2xlZXAoMykNCiAgICAgICAgDQogICAgICAgIGlmIHByb2Nlc3MucG9sbCgpIGlzIE5vbmU6DQogICAgICAgICAgICBwcmludCgi4pyTIERhZW1vbiBwcm9jZXNzIGlzIHJ1bm5pbmciKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgcHJpbnQoZiLinJcgRGFlbW9uIHByb2Nlc3MgZXhpdGVkIHdpdGggY29kZToge3Byb2Nlc3MucmV0dXJuY29kZX0iKQ0KICAgICAgICAgICAgc3Rkb3V0LCBfID0gcHJvY2Vzcy5jb21tdW5pY2F0ZSh0aW1lb3V0PTEpDQogICAgICAgICAgICBpZiBzdGRvdXQ6DQogICAgICAgICAgICAgICAgcHJpbnQoIlxuT3V0cHV0OiIpDQogICAgICAgICAgICAgICAgcHJpbnQoc3Rkb3V0WzoxMDAwXSkNCiAgICAgICAgDQogICAgICAgICMgQ2hlY2sgZm9yIGxvY2sgZmlsZQ0KICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhMT0NLX0ZJTEUpOg0KICAgICAgICAgICAgcHJpbnQoZiLinJMgTG9jayBmaWxlIGNyZWF0ZWQ6IHtMT0NLX0ZJTEV9IikNCiAgICAgICAgICAgIHdpdGggb3BlbihMT0NLX0ZJTEUsICdyJykgYXMgZjoNCiAgICAgICAgICAgICAgICBwaWQgPSBmLnJlYWQoKS5zdHJpcCgpDQogICAgICAgICAgICBwcmludChmIiAgUElEIGluIGxvY2sgZmlsZToge3BpZH0iKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgcHJpbnQoZiLinJcgTG9jayBmaWxlIE5PVCBjcmVhdGVkOiB7TE9DS19GSUxFfSIpDQogICAgICAgIA0KICAgICAgICAjIENoZWNrIGZvciByZWFkeSBmaWxlDQogICAgICAgIGlmIG9zLnBhdGguZXhpc3RzKFJFQURZX0ZJTEUpOg0KICAgICAgICAgICAgcHJpbnQoZiLinJMgUmVhZHkgZmlsZSBjcmVhdGVkOiB7UkVBRFlfRklMRX0iKQ0KICAgICAgICAgICAgd2l0aCBvcGVuKFJFQURZX0ZJTEUsICdyJykgYXMgZjoNCiAgICAgICAgICAgICAgICBwaWQgPSBmLnJlYWQoKS5zdHJpcCgpDQogICAgICAgICAgICBwcmludChmIiAgUElEIGluIHJlYWR5IGZpbGU6IHtwaWR9IikNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIHByaW50KGYi4pyXIFJlYWR5IGZpbGUgTk9UIGNyZWF0ZWQ6IHtSRUFEWV9GSUxFfSIpDQogICAgICAgIA0KICAgICAgICAjIENoZWNrIGRlYnVnLmxvZw0KICAgICAgICBkZWJ1Z19sb2cgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkZWJ1Zy5sb2ciKQ0KICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhkZWJ1Z19sb2cpOg0KICAgICAgICAgICAgcHJpbnQoZiJcbuKckyBEZWJ1ZyBsb2cgZXhpc3RzOiB7ZGVidWdfbG9nfSIpDQogICAgICAgICAgICB3aXRoIG9wZW4oZGVidWdfbG9nLCAncicsIGVuY29kaW5nPSd1dGYtOCcsIGVycm9ycz0naWdub3JlJykgYXMgZjoNCiAgICAgICAgICAgICAgICBsaW5lcyA9IGYucmVhZGxpbmVzKCkNCiAgICAgICAgICAgICAgICBwcmludChmIiAgTGFzdCAxMCBsaW5lczoiKQ0KICAgICAgICAgICAgICAgIGZvciBsaW5lIGluIGxpbmVzWy0xMDpdOg0KICAgICAgICAgICAgICAgICAgICBwcmludChmIiAgICB7bGluZS5yc3RyaXAoKX0iKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAgICAgcHJpbnQoZiJcbuKclyBEZWJ1ZyBsb2cgTk9UIGNyZWF0ZWQ6IHtkZWJ1Z19sb2d9IikNCiAgICAgICAgDQogICAgICAgICMgU3RvcCB0aGUgZGFlbW9uDQogICAgICAgIGlmIHByb2Nlc3MucG9sbCgpIGlzIE5vbmU6DQogICAgICAgICAgICBwcmludCgiXG5TdG9wcGluZyBkYWVtb24uLi4iKQ0KICAgICAgICAgICAgc3RvcF9maWxlID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiU1RPUCIpDQogICAgICAgICAgICB3aXRoIG9wZW4oc3RvcF9maWxlLCAndycpIGFzIGY6DQogICAgICAgICAgICAgICAgZi53cml0ZSgiIikNCiAgICAgICAgICAgIHRpbWUuc2xlZXAoMSkNCiAgICAgICAgICAgIGlmIHByb2Nlc3MucG9sbCgpIGlzIE5vbmU6DQogICAgICAgICAgICAgICAgcHJvY2Vzcy50ZXJtaW5hdGUoKQ0KICAgICAgICAgICAgICAgIHRpbWUuc2xlZXAoMSkNCiAgICAgICAgICAgICAgICBpZiBwcm9jZXNzLnBvbGwoKSBpcyBOb25lOg0KICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmtpbGwoKQ0KICAgICAgICANCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgIHByaW50KGYiRVJST1IgcnVubmluZyBkYWVtb246IHtlfSIpDQogICAgICAgIGltcG9ydCB0cmFjZWJhY2sNCiAgICAgICAgdHJhY2ViYWNrLnByaW50X2V4YygpDQogICAgDQogICAgcHJpbnQoIlxuIiArICI9IiAqIDcwKQ0KICAgIHByaW50KCJURVNUIENPTVBMRVRFIikNCiAgICBwcmludCgiPSIgKiA3MCkNCg0KaWYgX19uYW1lX18gPT0gIl9fbWFpbl9fIjoNCiAgICBtYWluKCkK",
  "reset_death_counter.py": "IiIiDQpSZXNldCBEZWF0aCBDb3VudGVyDQpTaW1wbGUgc2NyaXB0IHRvIHJlc2V0IGFsbCBkZWF0aCBjb3VudHMgdG8gMC4NCldvcmtzIHdpdGggYW55IGluc3RhbGxhdGlvbiBsb2NhdGlvbi4NCiIiIg0KDQppbXBvcnQgb3MNCmltcG9ydCBzeXMNCmltcG9ydCBqc29uDQoNCiMgR2V0IHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhpcyBzY3JpcHQgaXMgbG9jYXRlZCAod29ya3MgZm9yIGJvdGggLmV4ZSBhbmQgLnB5KQ0KZGVmIGdldF9iYXNlX2RpcigpOg0KICAgICIiIkdldCB0aGUgYmFzZSBkaXJlY3RvcnkgLSBzYW1lIGZvbGRlciBhcyB0aGlzIHNjcmlwdC4iIiINCiAgICBpZiBnZXRhdHRyKHN5cywgJ2Zyb3plbicsIEZhbHNlKToNCiAgICAgICAgIyBSdW5uaW5nIGFzIGNvbXBpbGVkIC5leGUgLSB1c2UgdGhlIGRpcmVjdG9yeSB3aGVyZSAuZXhlIGlzIGxvY2F0ZWQNCiAgICAgICAgcmV0dXJuIG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgoc3lzLmV4ZWN1dGFibGUpKQ0KICAgIGVsc2U6DQogICAgICAgICMgUnVubmluZyBhcyBzY3JpcHQgLSB1c2UgdGhlIGRpcmVjdG9yeSB3aGVyZSB0aGUgc2NyaXB0IGlzIGxvY2F0ZWQNCiAgICAgICAgcmV0dXJuIG9zLnBhdGguZGlybmFtZShvcy5wYXRoLmFic3BhdGgoX19maWxlX18pKQ0KDQpCQVNFX0RJUiA9IGdldF9iYXNlX2RpcigpDQpTVEFURV9KU09OID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiZGVhdGhfc3RhdGUuanNvbiIpDQpERUFUSF9UWFQgPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsICJkZWF0aF9jb3VudGVyLnR4dCIpDQoNCg0KZGVmIHJlc2V0X2RlYXRocygpOg0KICAgICIiIlJlc2V0IGFsbCBkZWF0aCBjb3VudHMgdG8gMC4iIiINCiAgICBwcmludCgiPSIgKiA2MCkNCiAgICBwcmludCgiUkVTRVQgREVBVEggQ09VTlRFUiIpDQogICAgcHJpbnQoIj0iICogNjApDQogICAgcHJpbnQoZiJJbnN0YWxsYXRpb24gZm9sZGVyOiB7QkFTRV9ESVJ9IikNCiAgICBwcmludCgpDQogICAgDQogICAgIyBSZXNldCBzdGF0ZSBKU09ODQogICAgaWYgb3MucGF0aC5leGlzdHMoU1RBVEVfSlNPTik6DQogICAgICAgIHRyeToNCiAgICAgICAgICAgICMgTG9hZCBleGlzdGluZyBzdGF0ZSB0byBwcmVzZXJ2ZSBnYW1lIGxpc3Qgc3RydWN0dXJlDQogICAgICAgICAgICB3aXRoIG9wZW4oU1RBVEVfSlNPTiwgInIiLCBlbmNvZGluZz0idXRmLTgiKSBhcyBmOg0KICAgICAgICAgICAgICAgIG9sZF9zdGF0ZSA9IGpzb24ubG9hZChmKQ0KICAgICAgICAgICAgDQogICAgICAgICAgICAjIENyZWF0ZSBuZXcgc3RhdGUgd2l0aCB6ZXJvcyBidXQgcHJlc2VydmUgZ2FtZSBzdHJ1Y3R1cmUNCiAgICAgICAgICAgIG5ld19zdGF0ZSA9IHsNCiAgICAgICAgICAgICAgICAidG90YWxfZGVhdGhzIjogMCwNCiAgICAgICAgICAgICAgICAiZ2FtZV9kZWF0aHMiOiB7fSwNCiAgICAgICAgICAgICAgICAidGljayI6IG9sZF9zdGF0ZS5nZXQoInRpY2siLCAwKSwgICMgS2VlcCB0aWNrIGNvdW50DQogICAgICAgICAgICAgICAgInN0cmVhayI6IDAsDQogICAgICAgICAgICAgICAgImxhc3RfZGVhdGhfdHMiOiAwLjAsDQogICAgICAgICAgICAgICAgImN1cnJlbnRfZ2FtZSI6IG9sZF9zdGF0ZS5nZXQoImN1cnJlbnRfZ2FtZSIsIE5vbmUpLA0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgDQogICAgICAgICAgICAjIFByZXNlcnZlIGdhbWUgbmFtZXMgZnJvbSBvbGQgc3RhdGUsIHNldCBhbGwgdG8gMA0KICAgICAgICAgICAgaWYgImdhbWVfZGVhdGhzIiBpbiBvbGRfc3RhdGU6DQogICAgICAgICAgICAgICAgZm9yIGdhbWVfbmFtZSBpbiBvbGRfc3RhdGVbImdhbWVfZGVhdGhzIl0ua2V5cygpOg0KICAgICAgICAgICAgICAgICAgICBuZXdfc3RhdGVbImdhbWVfZGVhdGhzIl1bZ2FtZV9uYW1lXSA9IDANCiAgICAgICAgICAgIA0KICAgICAgICAgICAgIyBXcml0ZSBuZXcgc3RhdGUNCiAgICAgICAgICAgIHdpdGggb3BlbihTVEFURV9KU09OLCAidyIsIGVuY29kaW5nPSJ1dGYtOCIpIGFzIGY6DQogICAgICAgICAgICAgICAganNvbi5kdW1wKG5ld19zdGF0ZSwgZiwgaW5kZW50PTIpDQogICAgICAgICAgICBwcmludChmIuKckyBSZXNldCBzdGF0ZSBmaWxlOiB7bGVuKG5ld19zdGF0ZVsnZ2FtZV9kZWF0aHMnXSl9IGdhbWVzIHJlc2V0IHRvIDAiKQ0KICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6DQogICAgICAgICAgICBwcmludChmIuKclyBFcnJvciByZXNldHRpbmcgc3RhdGUgZmlsZToge2V9IikNCiAgICAgICAgICAgIHJldHVybiBGYWxzZQ0KICAgIGVsc2U6DQogICAgICAgIHByaW50KCLihLkgTm8gc3RhdGUgZmlsZSBmb3VuZCAod2lsbCBiZSBjcmVhdGVkIG9uIGZpcnN0IHJ1bikiKQ0KICAgIA0KICAgICMgUmVzZXQgbWFpbiB0ZXh0IGZpbGUNCiAgICB0cnk6DQogICAgICAgIHdpdGggb3BlbihERUFUSF9UWFQsICJ3IiwgZW5jb2Rpbmc9InV0Zi04IikgYXMgZjoNCiAgICAgICAgICAgIGYud3JpdGUoIjAiKQ0KICAgICAgICBwcmludCgi4pyTIFJlc2V0IG1haW4gdGV4dCBmaWxlIHRvIDAiKQ0KICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgcHJpbnQoZiLinJcgRXJyb3IgcmVzZXR0aW5nIG1haW4gdGV4dCBmaWxlOiB7ZX0iKQ0KICAgICAgICByZXR1cm4gRmFsc2UNCiAgICANCiAgICAjIERlbGV0ZSBwZXItZ2FtZSB0ZXh0IGZpbGVzDQogICAgdHJ5Og0KICAgICAgICBkZWxldGVkX2NvdW50ID0gMA0KICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyhCQVNFX0RJUik6DQogICAgICAgICAgICBmb3IgZmlsZW5hbWUgaW4gb3MubGlzdGRpcihCQVNFX0RJUik6DQogICAgICAgICAgICAgICAgaWYgZmlsZW5hbWUuc3RhcnRzd2l0aCgiZGVhdGhfY291bnRlcl8iKSBhbmQgZmlsZW5hbWUuZW5kc3dpdGgoIi50eHQiKSBhbmQgZmlsZW5hbWUgIT0gImRlYXRoX2NvdW50ZXIudHh0IjoNCiAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGggPSBvcy5wYXRoLmpvaW4oQkFTRV9ESVIsIGZpbGVuYW1lKQ0KICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUoZmlsZXBhdGgpDQogICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkX2NvdW50ICs9IDENCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0Og0KICAgICAgICAgICAgICAgICAgICAgICAgcGFzcw0KICAgICAgICBpZiBkZWxldGVkX2NvdW50ID4gMDoNCiAgICAgICAgICAgIHByaW50KGYi4pyTIERlbGV0ZWQge2RlbGV0ZWRfY291bnR9IHBlci1nYW1lIHRleHQgZmlsZShzKSIpDQogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KICAgICAgICBwcmludChmIuKaoCBDb3VsZCBub3QgY2xlYW4gdXAgcGVyLWdhbWUgZmlsZXM6IHtlfSIpDQogICAgDQogICAgcHJpbnQoKQ0KICAgIHByaW50KCI9IiAqIDYwKQ0KICAgIHByaW50KCJTVUNDRVNTISBBbGwgZGVhdGggY291bnRzIHJlc2V0IHRvIDAuIikNCiAgICBwcmludCgiPSIgKiA2MCkNCiAgICBwcmludCgpDQogICAgcHJpbnQoIk5vdGU6IFRoZSBkYWVtb24gd2lsbCBhdXRvbWF0aWNhbGx5IHBpY2sgdXAgdGhlIGNoYW5nZXMuIikNCiAgICBwcmludCgiICAgICAgTm8gbmVlZCB0byByZXN0YXJ0IHRoZSBkYWVtb24uIikNCiAgICANCiAgICByZXR1cm4gVHJ1ZQ0KDQoNCmlmIF9fbmFtZV9fID09ICJfX21haW5fXyI6DQogICAgdHJ5Og0KICAgICAgICBzdWNjZXNzID0gcmVzZXRfZGVhdGhzKCkNCiAgICAgICAgaWYgbm90IHN1Y2Nlc3M6DQogICAgICAgICAgICBwcmludCgiXG5QcmVzcyBFbnRlciB0byBleGl0Li4uIikNCiAgICAgICAgICAgIGlucHV0KCkNCiAgICAgICAgICAgIHN5cy5leGl0KDEpDQogICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0Og0KICAgICAgICBwcmludCgiXG5cblJlc2V0IGNhbmNlbGxlZC4iKQ0KICAgICAgICBzeXMuZXhpdCgxKQ0KICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgcHJpbnQoZiJcbuKclyBVbmV4cGVjdGVkIGVycm9yOiB7ZX0iKQ0KICAgICAgICBwcmludCgiXG5QcmVzcyBFbnRlciB0byBleGl0Li4uIikNCiAgICAgICAgaW5wdXQoKQ0KICAgICAgICBzeXMuZXhpdCgxKQo=",
  "RESET_DEATH_COUNTER.bat": "QGVjaG8gb2ZmDQpSRU0gUmVzZXQgRGVhdGggQ291bnRlcg0KUkVNIFRoaXMgYmF0Y2ggZmlsZSByZXNldHMgYWxsIGRlYXRoIGNvdW50cyB0byAwDQoNCmNkIC9kICIlfmRwMCINCnB5dGhvbiByZXNldF9kZWF0aF9jb3VudGVyLnB5DQppZiBlcnJvcmxldmVsIDEgKA0KICAgIGVjaG8uDQogICAgZWNobyBQcmVzcyBhbnkga2V5IHRvIGV4aXQuLi4NCiAgICBwYXVzZSA+bnVsDQopCg=="
}

# Get the directory where the installer is located (works for both .exe and .py)
def get_install_dir():
    """Get the installation directory - same folder as the installer executable."""
    if getattr(sys, 'frozen', False):
        # Running as compiled .exe - use the directory where .exe is located
        return os.path.dirname(os.path.abspath(sys.executable))
    else:
        # Running as script - use the directory where the script is located
        return os.path.dirname(os.path.abspath(__file__))

INSTALL_DIR = get_install_dir()

def extract_files():
    """Extract all embedded files."""
    extracted = []
    os.makedirs(INSTALL_DIR, exist_ok=True)
    
    for filename, content_b64 in EMBEDDED_FILES.items():
        try:
            content = base64.b64decode(content_b64)
            filepath = os.path.join(INSTALL_DIR, filename)
            
            # Write file
            with open(filepath, 'wb') as f:
                f.write(content)
            
            extracted.append(filepath)
            print(f"Extracted: {filename}")
        except Exception as e:
            print(f"Error extracting {filename}: {e}")
    
    return extracted

def find_python_executable(use_pythonw=False):
    """Find the actual Python executable (not the installer exe).
    Comprehensive search for general public use.
    If use_pythonw=True, searches for pythonw.exe (no console window)."""
    # If running as a script (not frozen), use sys.executable
    if not getattr(sys, 'frozen', False):
        if use_pythonw:
            # Try to find pythonw.exe in the same directory as python.exe
            python_dir = os.path.dirname(sys.executable)
            pythonw_exe = os.path.join(python_dir, "pythonw.exe")
            if os.path.exists(pythonw_exe):
                return pythonw_exe
            return sys.executable  # Fallback to python.exe
        return sys.executable
    
    exe_name = "pythonw.exe" if use_pythonw else "python.exe"
    command_name = "pythonw" if use_pythonw else "python"
    
    # If running as PyInstaller exe, we need to find Python
    # Method 1: Try command (if in PATH) - most reliable
    if not use_pythonw:  # pythonw is rarely in PATH
        try:
            result = subprocess.run([command_name, '--version'], 
                                  capture_output=True, text=True, timeout=2)
            if result.returncode == 0:
                return command_name
        except:
            pass
    
    # Method 2: Try 'py' launcher (Windows Python launcher) - also reliable
    if not use_pythonw:  # py launcher doesn't support pythonw directly
        try:
            result = subprocess.run(['py', '--version'], 
                                  capture_output=True, text=True, timeout=2)
            if result.returncode == 0:
                return 'py'
        except:
            pass
    
    # Method 3: Search Windows Registry for Python installations
    try:
        import winreg
        # Check both 32-bit and 64-bit registry
        for arch in [winreg.KEY_WOW64_64KEY, winreg.KEY_WOW64_32KEY]:
            try:
                # Check HKEY_LOCAL_MACHINE
                key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 
                                    r"SOFTWARE\Python\PythonCore", 0,
                                    winreg.KEY_READ | arch)
                try:
                    # Get all installed Python versions
                    i = 0
                    while True:
                        try:
                            version = winreg.EnumKey(key, i)
                            install_path_key = winreg.OpenKey(key, rf"{version}\InstallPath")
                            try:
                                install_path = winreg.QueryValueEx(install_path_key, "")[0]
                                python_exe = os.path.join(install_path, exe_name)
                                if os.path.exists(python_exe):
                                    winreg.CloseKey(install_path_key)
                                    winreg.CloseKey(key)
                                    return python_exe
                                # If pythonw.exe not found, try python.exe as fallback
                                if use_pythonw:
                                    python_exe = os.path.join(install_path, "python.exe")
                                    if os.path.exists(python_exe):
                                        winreg.CloseKey(install_path_key)
                                        winreg.CloseKey(key)
                                        return python_exe
                                winreg.CloseKey(install_path_key)
                            except:
                                pass
                            i += 1
                        except OSError:
                            break
                    winreg.CloseKey(key)
                except:
                    try:
                        winreg.CloseKey(key)
                    except:
                        pass
            except:
                pass
    except:
        pass
    
    # Method 4: Search common installation locations
    userprofile = os.getenv('USERPROFILE', '')
    programfiles = os.getenv('ProgramFiles', r'C:\Program Files')
    programfiles_x86 = os.getenv('ProgramFiles(x86)', r'C:\Program Files (x86)')
    
    search_paths = []
    
    # User AppData locations (most common for Python 3.8+)
    if userprofile:
        appdata_local = os.path.join(userprofile, r"AppData\Local\Programs\Python")
        if os.path.exists(appdata_local):
            # Search all Python versions in this directory
            try:
                for item in os.listdir(appdata_local):
                    python_dir = os.path.join(appdata_local, item)
                    if os.path.isdir(python_dir):
                        python_exe = os.path.join(python_dir, exe_name)
                        if os.path.exists(python_exe):
                            search_paths.append(python_exe)
                        # If pythonw.exe not found, try python.exe as fallback
                        elif use_pythonw:
                            python_exe = os.path.join(python_dir, "python.exe")
                            if os.path.exists(python_exe):
                                search_paths.append(python_exe)
            except:
                pass
    
    # Common root-level Python installations
    for version in ['312', '311', '310', '39', '38']:
        search_paths.extend([
            os.path.join(r"C:\Python" + version, exe_name),
            os.path.join(programfiles, f"Python{version}", exe_name),
            os.path.join(programfiles_x86, f"Python{version}", exe_name),
        ])
        # If pythonw.exe not found, add python.exe as fallback
        if use_pythonw:
            search_paths.extend([
                os.path.join(r"C:\Python" + version, "python.exe"),
                os.path.join(programfiles, f"Python{version}", "python.exe"),
                os.path.join(programfiles_x86, f"Python{version}", "python.exe"),
            ])
    
    # Check all collected paths
    for path in search_paths:
        if os.path.exists(path):
            return path
    
    # Method 5: Recursive search in Program Files (last resort, slower)
    try:
        for root_dir in [programfiles, programfiles_x86]:
            if os.path.exists(root_dir):
                for root, dirs, files in os.walk(root_dir):
                    # Limit depth to avoid slow searches
                    depth = root[len(root_dir):].count(os.sep)
                    if depth > 2:  # Max 2 levels deep
                        dirs[:] = []  # Don't recurse deeper
                        continue
                    
                    if exe_name in files or (use_pythonw and 'python.exe' in files):
                        python_exe = os.path.join(root, exe_name if exe_name in files else 'python.exe')
                        # Verify it's actually Python
                        try:
                            result = subprocess.run([python_exe, '--version'], 
                                                  capture_output=True, timeout=1)
                            if result.returncode == 0:
                                return python_exe
                        except:
                            pass
    except:
        pass
    
    return None

def is_python_version_compatible(python_exe):
    """Check if Python version is compatible (3.8-3.12)."""
    try:
        result = subprocess.run(
            [python_exe, '--version'],
            capture_output=True,
            text=True,
            timeout=1
        )
        if result.returncode == 0:
            version_str = result.stdout.strip() or result.stderr.strip()
            # Parse version (e.g., "Python 3.12.0" -> (3, 12))
            import re
            match = re.search(r'(\d+)\.(\d+)', version_str)
            if match:
                major = int(match.group(1))
                minor = int(match.group(2))
                # Check if version is 3.8-3.12 (3.13 has Tcl/Tk compatibility issues)
                if major == 3 and 8 <= minor <= 12:
                    return True
    except:
        pass
    return False

def check_python():
    """Check if Python is installed and return version info."""
    python_exe = find_python_executable()
    if not python_exe:
        return False, None, None
    
    try:
        result = subprocess.run([python_exe, '--version'], 
                              capture_output=True, text=True, timeout=5)
        version_str = result.stdout.strip()
        is_compatible = is_python_version_compatible(python_exe)
        return True, version_str, is_compatible
    except:
        return False, None, None

def check_tesseract():
    """Check if Tesseract OCR is installed."""
    default_path = r"C:\Program Files\Tesseract-OCR\tesseract.exe"
    if os.path.exists(default_path):
        return True, default_path
    try:
        result = subprocess.run(['tesseract', '--version'], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            return True, "tesseract"
    except:
        pass
    return False, None

def find_tesseract_tessdata():
    """Find the Tesseract tessdata directory."""
    tesseract_paths = [
        r"C:\Program Files\Tesseract-OCR\tessdata",
        r"C:\Program Files (x86)\Tesseract-OCR\tessdata",
    ]
    for path in tesseract_paths:
        if os.path.exists(path):
            return path
    return None

def check_japanese_lang_pack():
    """Check if Japanese language pack is installed."""
    tessdata_dir = find_tesseract_tessdata()
    if not tessdata_dir:
        return False
    jpn_file = os.path.join(tessdata_dir, "jpn.traineddata")
    jpn_vert_file = os.path.join(tessdata_dir, "jpn_vert.traineddata")
    return os.path.exists(jpn_file) and os.path.exists(jpn_vert_file)

def download_japanese_lang_pack(log_callback=None):
    """Download Japanese language pack for Tesseract with multiple fallbacks.
    
    Args:
        log_callback: Optional function to call for logging messages (takes a string)
    
    Returns:
        tuple: (success: bool, message: str)
    """
    def log(msg):
        if log_callback:
            log_callback(msg)
    
    tessdata_dir = find_tesseract_tessdata()
    if not tessdata_dir:
        return False, "Tesseract tessdata directory not found"
    
    urls = {
        "jpn.traineddata": "https://github.com/tesseract-ocr/tessdata/raw/main/jpn.traineddata",
        "jpn_vert.traineddata": "https://github.com/tesseract-ocr/tessdata/raw/main/jpn_vert.traineddata",
    }
    
    import ssl
    import shutil
    
    log("Downloading Japanese language packs for Tesseract...")
    log("Note: Japanese packs are required for reliable Sekiro detection (Japanese '' character)")
    
    temp_dir = tempfile.mkdtemp()
    
    try:
        # Download files to temp directory first (no admin needed)
        files_to_download = []
        for filename, url in urls.items():
            target_file = os.path.join(tessdata_dir, filename)
            if not os.path.exists(target_file):
                files_to_download.append((filename, url))
        
        if not files_to_download:
            log("Japanese language packs already installed.")
            return True, "Japanese pack already installed"
        
        # Attempt 1: Standard urllib with SSL verification
        log("Attempt 1: Downloading to temp with standard SSL verification...")
        attempt1_success = {}
        for filename, url in files_to_download:
            temp_file = os.path.join(temp_dir, filename)
            try:
                import urllib.request
                # Use urlopen for better compatibility
                with urllib.request.urlopen(url) as response:
                    with open(temp_file, 'wb') as out_file:
                        shutil.copyfileobj(response, out_file)
                attempt1_success[filename] = True
            except Exception as e1:
                attempt1_success[filename] = False
                log(f"Attempt 1 failed for {filename}: {e1}")
        
        # If attempt 1 failed for any files, try attempt 2
        failed_files = [f for f, success in attempt1_success.items() if not success]
        if failed_files:
            attempt_num = 2
            log(f"Attempt {attempt_num}: Downloading to temp with relaxed SSL (ignoring certificate validation)...")
            attempt2_success = {}
            for filename, url in files_to_download:
                if filename in failed_files:
                    temp_file = os.path.join(temp_dir, filename)
                    try:
                        # Use urlopen with context instead of urlretrieve (more compatible)
                        ssl_context = ssl.create_default_context()
                        ssl_context.check_hostname = False
                        ssl_context.verify_mode = ssl.CERT_NONE
                        with urllib.request.urlopen(url, context=ssl_context) as response:
                            with open(temp_file, 'wb') as out_file:
                                shutil.copyfileobj(response, out_file)
                        attempt2_success[filename] = True
                    except Exception as e2:
                        attempt2_success[filename] = False
                        log(f"Attempt {attempt_num} failed for {filename}: {e2}")
                        # Attempt 3: PowerShell Invoke-WebRequest with -SkipCertificateCheck (non-elevated)
                        attempt_num = 3
                        log(f"Attempt {attempt_num}: Downloading with PowerShell (bypassing certificate check)...")
                        try:
                            ps_cmd = f'Invoke-WebRequest -Uri "{url}" -OutFile "{temp_file}" -SkipCertificateCheck'
                            result = subprocess.run(
                                ['powershell', '-Command', ps_cmd],
                                capture_output=True,
                                timeout=60
                            )
                            if result.returncode == 0 and os.path.exists(temp_file):
                                attempt2_success[filename] = True
                            else:
                                attempt2_success[filename] = False
                                log(f"Attempt {attempt_num} failed for {filename}: PowerShell returned code {result.returncode}")
                                # Attempt 4: Elevated PowerShell download (downloads to temp, then copies)
                                attempt_num = 4
                                log(f"Attempt {attempt_num}: Downloading with elevated PowerShell (staged download)...")
                                try:
                                    # Download to temp with elevated PowerShell
                                    ps_cmd = f'Start-Process powershell -ArgumentList "-Command", "Invoke-WebRequest -Uri \'{url}\' -OutFile \'{temp_file}\' -SkipCertificateCheck" -Verb RunAs -Wait'
                                    result = subprocess.run(
                                        ['powershell', '-Command', ps_cmd],
                                        capture_output=True,
                                        timeout=90
                                    )
                                    if result.returncode == 0 and os.path.exists(temp_file):
                                        attempt2_success[filename] = True
                                    else:
                                        attempt2_success[filename] = False
                                        log(f"Attempt {attempt_num} failed for {filename}: Elevated PowerShell returned code {result.returncode}")
                                except Exception as e4:
                                    attempt2_success[filename] = False
                                    log(f"Attempt {attempt_num} failed for {filename}: {e4}")
                        except Exception as e3:
                            attempt2_success[filename] = False
                            log(f"Attempt {attempt_num} failed for {filename}: {e3}")
                else:
                    attempt2_success[filename] = True  # Already downloaded in attempt 1
            
            # Check if all files downloaded successfully
            all_success = all(attempt2_success.get(f, False) for f, _ in files_to_download)
            if all_success:
                log(f"Downloaded to temp successfully (Attempt 2 - unverified SSL)")
            else:
                failed = [f for f, success in attempt2_success.items() if not success]
                return False, f"Failed to download: {', '.join(failed)}"
        else:
            # All files downloaded in attempt 1
            log("Downloaded to temp successfully (Attempt 1 - standard SSL)")
        
        # Copy files from temp to tessdata (may need elevation)
        log("Attempting elevated copy (UAC prompt) to install Japanese packs...")
        elevation_used = False
        for filename in urls.keys():
            temp_file = os.path.join(temp_dir, filename)
            target_file = os.path.join(tessdata_dir, filename)
            
            if not os.path.exists(temp_file):
                continue
            
            try:
                shutil.copy2(temp_file, target_file)
            except PermissionError:
                # Attempt elevated PowerShell copy
                elevation_used = True
                try:
                    ps_cmd = f'Start-Process powershell -ArgumentList "-Command", "Copy-Item -Path \'{temp_file}\' -Destination \'{target_file}\' -Force" -Verb RunAs -Wait'
                    result = subprocess.run(
                        ['powershell', '-Command', ps_cmd],
                        capture_output=True,
                        timeout=30
                    )
                    if not os.path.exists(target_file):
                        return False, f"Permission denied copying {filename}"
                except Exception as e:
                    return False, f"Permission denied copying {filename}: {e}"
        
        if elevation_used:
            log("Japanese language packs installed via elevated copy. Sekiro detection is now fully supported!")
        
        log("Japanese pack downloaded successfully! Sekiro detection is now fully supported!")
        return True, "Japanese pack downloaded successfully"
    
    except Exception as e:
        log(f"Error during download: {e}")
        return False, str(e)
    finally:
        # Clean up temp directory
        try:
            shutil.rmtree(temp_dir, ignore_errors=True)
        except:
            pass

def install_dependencies():
    """Install Python dependencies."""
    python_exe = find_python_executable()
    if not python_exe:
        return False
    
    try:
        packages = ['mss', 'pillow', 'pytesseract', 'opencv-python', 'numpy', 'psutil']
        subprocess.run([python_exe, '-m', 'pip', 'install', '--upgrade', 'pip'], 
                      check=False, capture_output=True)
        subprocess.run([python_exe, '-m', 'pip', 'install'] + packages, 
                      check=True, capture_output=True)
        return True
    except subprocess.CalledProcessError as e:
        return False

class InstallerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Death Counter - Installer & Launcher")
        self.root.geometry("850x650")
        self.root.resizable(False, False)
        
        self.setup_complete = False
        self.streamerbot_imported = False
        self.create_ui()
        self.check_system()
    
    def create_ui(self):
        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        title = ttk.Label(main_frame, text="Death Counter", 
                         font=("Arial", 18, "bold"))
        title.grid(row=0, column=0, columnspan=2, pady=(0, 20))
        
        status_frame = ttk.LabelFrame(main_frame, text="System Check", padding="10")
        status_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        self.python_status = ttk.Label(status_frame, text="Checking Python...")
        self.python_status.grid(row=0, column=0, sticky=tk.W, pady=2)
        
        self.tesseract_status = ttk.Label(status_frame, text="Checking Tesseract OCR...")
        self.tesseract_status.grid(row=1, column=0, sticky=tk.W, pady=2)
        
        self.deps_status = ttk.Label(status_frame, text="Checking dependencies...")
        self.deps_status.grid(row=2, column=0, sticky=tk.W, pady=2)
        
        self.japanese_pack_status = ttk.Label(status_frame, text="Checking Japanese pack...")
        self.japanese_pack_status.grid(row=3, column=0, sticky=tk.W, pady=2)
        
        log_frame = ttk.LabelFrame(main_frame, text="Log", padding="10")
        log_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        main_frame.rowconfigure(2, weight=1)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=10, width=80)
        self.log_text.pack(fill=tk.BOTH, expand=True)
        
        # First row of buttons
        button_frame1 = ttk.Frame(main_frame)
        button_frame1.grid(row=3, column=0, columnspan=2, pady=(0, 5))
        
        self.install_button = ttk.Button(button_frame1, text="Install/Update Files", 
                                         command=self.install_files, width=22)
        self.install_button.pack(side=tk.LEFT, padx=3)
        
        self.install_python_button = ttk.Button(button_frame1, text="Install Python", 
                                               command=self.install_python, width=22)
        self.install_python_button.pack(side=tk.LEFT, padx=3)
        
        self.install_tesseract_button = ttk.Button(button_frame1, text="Install Tesseract", 
                                                   command=self.install_tesseract, width=22)
        self.install_tesseract_button.pack(side=tk.LEFT, padx=3)
        
        self.install_deps_button = ttk.Button(button_frame1, text="Install Dependencies", 
                                              command=self.install_deps, width=22)
        self.install_deps_button.pack(side=tk.LEFT, padx=3)
        
        # Second row of buttons
        button_frame2 = ttk.Frame(main_frame)
        button_frame2.grid(row=4, column=0, columnspan=2, pady=(0, 10))
        
        self.streamerbot_download_button = ttk.Button(button_frame2, text="Streamer.bot Download", 
                                                      command=self.download_streamerbot, width=22)
        self.streamerbot_download_button.pack(side=tk.LEFT, padx=3)
        
        self.streamerbot_import_button = ttk.Button(button_frame2, text="Import to Streamer.bot", 
                                                    command=self.import_streamerbot, width=22)
        self.streamerbot_import_button.pack(side=tk.LEFT, padx=3)
        
        self.confirm_import_button = ttk.Button(button_frame2, text=" Confirm Import", 
                                                command=self.confirm_import, width=22, state=tk.DISABLED)
        self.confirm_import_button.pack(side=tk.LEFT, padx=3)
        
        self.launch_button = ttk.Button(button_frame2, text="Launch Death Counter", 
                                       command=self.launch_app, width=22, state=tk.DISABLED)
        self.launch_button.pack(side=tk.LEFT, padx=3)
        
        info_text = ("1. Click 'Install/Update Files' to extract all files (auto-downloads Japanese pack for Sekiro)\n"
                    "2. Click 'Install Dependencies' to install Python packages\n"
                    "3. Install Tesseract OCR from: https://github.com/UB-Mannheim/tesseract/wiki\n"
                    "4. Click 'Streamer.bot Download' to download and install Streamer.bot (optional)\n"
                    "5. Click 'Import to Streamer.bot' and import the action file, then click 'Confirm Import' (optional)\n"
                    "6. Click 'Launch Death Counter' to start")
        info_label = ttk.Label(main_frame, text=info_text, justify=tk.LEFT)
        info_label.grid(row=5, column=0, columnspan=2, sticky=tk.W)
    
    def log(self, message):
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.root.update()
    
    def check_system(self):
        python_ok, python_version, is_compatible = check_python()
        if python_ok:
            if is_compatible:
                self.python_status.config(text=f" Python: {python_version}", foreground="green")
            else:
                self.python_status.config(text=f" Python: {python_version} (Requires 3.8-3.12)", foreground="orange")
                messagebox.showwarning("Python Version Warning", 
                    f"Your Python version ({python_version}) may not be fully compatible.\n\n"
                    "This application requires Python 3.8-3.12 for optimal compatibility.\n\n"
                    "Please install a compatible Python version from:\n"
                    "https://www.python.org/downloads/release/python-3121/\n\n"
                    "The application may still work, but some features may not function correctly.")
        else:
            self.python_status.config(text=" Python not found", foreground="red")
        
        tesseract_ok, tesseract_path = check_tesseract()
        if tesseract_ok:
            self.tesseract_status.config(text=" Tesseract OCR: Found", foreground="green")
            # Check Japanese pack if Tesseract is found
            try:
                if check_japanese_lang_pack():
                    self.japanese_pack_status.config(text=" Japanese Pack: Installed (Sekiro support)", foreground="green")
                else:
                    self.japanese_pack_status.config(text=" Japanese Pack: Not found (auto-download on install)", foreground="orange")
            except Exception as e:
                self.japanese_pack_status.config(text=" Japanese Pack: Error checking status", foreground="orange")
                self.log(f"Error checking Japanese pack: {e}")
        else:
            self.tesseract_status.config(text=" Tesseract OCR: Not found (install from link below)", foreground="orange")
            self.japanese_pack_status.config(text=" Japanese Pack: Tesseract required", foreground="gray")
        
        try:
            import mss
            import cv2
            import pytesseract
            import psutil
            self.deps_status.config(text=" Dependencies: Installed", foreground="green")
        except ImportError:
            self.deps_status.config(text=" Dependencies: Not installed", foreground="red")
        
        gui_path = os.path.join(INSTALL_DIR, "death_counter_gui.py")
        cs_file_path = os.path.join(INSTALL_DIR, "deathcounteraction.cs")
        if os.path.exists(gui_path):
            self.setup_complete = True
            if os.path.exists(cs_file_path):
                self.log("Files already installed. Import to Streamer.bot to enable launch button.")
                # Enable Confirm Import button if action file exists
                self.confirm_import_button.config(state=tk.NORMAL)
            else:
                self.log("Files already installed. Ready to launch!")
                self.update_launch_button_state()
        else:
            self.log("Files not yet installed. Click 'Install/Update Files' first.")
    
    def update_launch_button_state(self):
        """Update launch button state based on setup completion and Streamer.bot import status."""
        if self.setup_complete:
            if self.streamerbot_imported:
                self.launch_button.config(state=tk.NORMAL)
            else:
                cs_file_path = os.path.join(INSTALL_DIR, "deathcounteraction.cs")
                if not os.path.exists(cs_file_path):
                    # If no Streamer.bot action file, allow launch without import
                    self.launch_button.config(state=tk.NORMAL)
                else:
                    # Action file exists, require import confirmation
                    self.launch_button.config(state=tk.DISABLED)
    
    def install_python(self):
        """Open Python download page."""
        self.log("Opening Python 3.12.1 download page...")
        webbrowser.open("https://www.python.org/downloads/release/python-3121/")
        self.log("Python 3.12.1 download page opened. After installing, restart this installer.")
        messagebox.showinfo("Python Installation", 
                          "After installing Python 3.12.1, please:\n"
                          "1. Check 'Add Python to PATH' during installation\n"
                          "2. Restart this installer")
    
    def install_tesseract(self):
        """Open Tesseract OCR download page."""
        self.log("Opening Tesseract OCR download page...")
        webbrowser.open("https://github.com/UB-Mannheim/tesseract/wiki")
        self.log("Tesseract OCR download page opened.")
        messagebox.showinfo("Tesseract OCR Installation", 
                          "Default install path: C:\\Program Files\\Tesseract-OCR\\\n"
                          "After installing, restart this installer.")
    
    def download_streamerbot(self):
        """Open Streamer.bot download page."""
        self.log("Opening Streamer.bot download page...")
        webbrowser.open("https://streamer.bot/")
        self.log("Streamer.bot download page opened.")
    
    def import_streamerbot(self):
        """Open file location for Streamer.bot action file."""
        cs_file_path = os.path.join(INSTALL_DIR, "deathcounteraction.cs")
        if not os.path.exists(cs_file_path):
            self.log("Action file not found. Please install files first.")
            messagebox.showerror("Error", 
                               "The action file has not been extracted yet.\n\n"
                               "Please click 'Install/Update Files' first to extract all files.")
            return
        
        # Open the file location in Explorer
        try:
            subprocess.Popen(f'explorer /select,"{cs_file_path}"')
            self.log("Opened file location: {cs_file_path}")
            self.log("Streamer.bot import instructions displayed.")
            # Enable the Confirm Import button after showing instructions
            self.confirm_import_button.config(state=tk.NORMAL)
            messagebox.showinfo("Import to Streamer.bot", 
                              "1. In Streamer.bot, go to Actions\n"
                              "2. Click 'Import'\n"
                              "3. Select the deathcounteraction.cs file\n"
                              "4. After importing, click 'Confirm Import' button")
        except Exception as e:
            self.log(f"Error opening file location: {e}")
            messagebox.showerror("Error", f"Could not open file location: {e}")
    
    def confirm_import(self):
        """Confirm that Streamer.bot action has been imported."""
        self.streamerbot_imported = True
        self.confirm_import_button.config(state=tk.DISABLED)
        self.update_launch_button_state()
        self.log("Streamer.bot import confirmed! Launch button enabled.")
        messagebox.showinfo("Import Confirmed", "Streamer.bot import confirmed. You can now launch the Death Counter!")
    
    def install_files(self):
        self.log("Installing files...")
        self.install_button.config(state=tk.DISABLED)
        
        def do_install():
            try:
                extracted = extract_files()
                self.log(f"Extracted {len(extracted)} files successfully!")
                
                # Auto-download Japanese pack if Tesseract is found and pack is missing
                tesseract_ok, _ = check_tesseract()
                if tesseract_ok:
                    if not check_japanese_lang_pack():
                        self.log("Japanese language pack not found. Attempting auto-download...")
                        self.log("Note: Japanese pack is required for reliable Sekiro detection (Japanese '' character)")
                        success, message = download_japanese_lang_pack(log_callback=self.log)
                        if success:
                            self.japanese_pack_status.config(text=" Japanese Pack: Installed (Sekiro support)", foreground="green")
                        else:
                            self.log(f"Japanese pack auto-download failed. Manual download recommended for Sekiro.")
                            self.log("Download from:")
                            self.log("  https://github.com/tesseract-ocr/tessdata/raw/main/jpn.traineddata")
                            self.log("  https://github.com/tesseract-ocr/tessdata/raw/main/jpn_vert.traineddata")
                            self.log(f"Save to: {find_tesseract_tessdata() or 'Tesseract tessdata directory'}")
                            self.japanese_pack_status.config(text=" Japanese Pack: Auto-download failed", foreground="orange")
                    else:
                        self.log("Japanese language pack already installed.")
                
                self.setup_complete = True
                self.update_launch_button_state()
            except Exception as e:
                self.log(f"Error installing files: {e}")
                messagebox.showerror("Error", f"Failed to install files: {e}")
            finally:
                self.install_button.config(state=tk.NORMAL)
        
        threading.Thread(target=do_install, daemon=True).start()
    
    def install_deps(self):
        self.log("Installing dependencies...")
        self.install_deps_button.config(state=tk.DISABLED)
        
        def do_install():
            try:
                if install_dependencies():
                    self.log("Dependencies installed successfully!")
                    self.check_system()
                else:
                    self.log("Failed to install dependencies.")
                    messagebox.showerror("Error", "Failed to install dependencies.")
            except Exception as e:
                self.log(f"Error: {e}")
                messagebox.showerror("Error", f"Failed to install dependencies: {e}")
            finally:
                self.install_deps_button.config(state=tk.NORMAL)
        
        threading.Thread(target=do_install, daemon=True).start()
    
    def launch_app(self):
        gui_path = os.path.join(INSTALL_DIR, "death_counter_gui.py")
        if not os.path.exists(gui_path):
            messagebox.showerror("Error", "Death Counter GUI not found. Please install files first.")
            return
        
        try:
            # Find pythonw.exe (no console window) for GUI applications
            python_exe = find_python_executable(use_pythonw=True)
            if not python_exe:
                error_msg = "Python executable not found. Please install Python and ensure it's in PATH."
                self.log(error_msg)
                messagebox.showerror("Error", error_msg)
                return
            
            # CRITICAL: Fix Tcl/Tk version conflicts by setting environment variables
            # Find the Python installation's Tcl/Tk directories
            env = os.environ.copy()
            try:
                python_dir = os.path.dirname(os.path.abspath(python_exe))
                python_lib = os.path.join(python_dir, 'Lib')
                tkinter_path = os.path.join(python_lib, 'tkinter')
                
                if os.path.exists(tkinter_path):
                    tcl_path = os.path.join(tkinter_path, 'tcl')
                    tk_path = os.path.join(tkinter_path, 'tk')
                    
                    # Verify Tcl/Tk directories exist and contain init files
                    if os.path.exists(tcl_path) and os.path.exists(tk_path):
                        init_tcl = os.path.join(tcl_path, 'init.tcl')
                        if os.path.exists(init_tcl):
                            # Set environment variables to use system Tcl/Tk
                            tcl_abs = os.path.abspath(tcl_path)
                            tk_abs = os.path.abspath(tk_path)
                            env['TCL_LIBRARY'] = tcl_abs
                            env['TK_LIBRARY'] = tk_abs
                            env['TCL_LIBRARY_PATH'] = tcl_abs
                            env['TK_LIBRARY_PATH'] = tk_abs
                            # Clear any PyInstaller temp directory references
                            for key in list(env.keys()):
                                if '_MEI' in key or 'MEIPASS' in key:
                                    # Don't delete, but ensure TCL/TK paths take precedence
                                    pass
                            self.log(f"Using system Tcl/Tk: {tcl_abs}")
            except Exception as e:
                self.log(f"Warning: Could not set Tcl/Tk paths: {e}")
            
            self.log(f"Launching: {python_exe} {gui_path}")
            self.log(f"Working directory: {INSTALL_DIR}")
            
            # Launch with CREATE_NO_WINDOW to hide console window
            # Use pythonw.exe which doesn't create a console window
            CREATE_NO_WINDOW = 0x08000000 if hasattr(subprocess, 'CREATE_NO_WINDOW') else 0
            process = subprocess.Popen(
                [python_exe, gui_path], 
                cwd=INSTALL_DIR,
                env=env,  # Pass environment with Tcl/Tk paths
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                creationflags=CREATE_NO_WINDOW  # Hide console window
            )
            
            # Give it a moment to start, then check if it's still running
            import time
            time.sleep(0.5)
            
            if process.poll() is None:
                # Process is still running (good)
                self.log("Death Counter launched successfully!")
                messagebox.showinfo("Success", "Death Counter GUI launched!")
            else:
                # Process exited immediately (error)
                stdout, stderr = process.communicate()
                error_msg = stderr.decode('utf-8', errors='ignore') if stderr else "Unknown error"
                self.log(f"Process exited immediately. Error: {error_msg}")
                messagebox.showerror("Error", f"Death Counter failed to start:\n{error_msg}")
                
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            self.log(f"Error launching: {e}")
            self.log(f"Details: {error_details}")
            messagebox.showerror("Error", f"Failed to launch: {e}")

def main():
    root = tk.Tk()
    app = InstallerGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
